(function(e){function a(a){for(var s,n,i=a[0],m=a[1],u=a[2],c=0,l=[];c<i.length;c++)n=i[c],Object.prototype.hasOwnProperty.call(r,n)&&r[n]&&l.push(r[n][0]),r[n]=0;for(s in m)Object.prototype.hasOwnProperty.call(m,s)&&(e[s]=m[s]);d&&d(a);while(l.length)l.shift()();return t.push.apply(t,u||[]),o()}function o(){for(var e,a=0;a<t.length;a++){for(var o=t[a],s=!0,i=1;i<o.length;i++){var m=o[i];0!==r[m]&&(s=!1)}s&&(t.splice(a--,1),e=n(n.s=o[0]))}return e}var s={},r={app:0},t=[];function n(a){if(s[a])return s[a].exports;var o=s[a]={i:a,l:!1,exports:{}};return e[a].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=s,n.d=function(e,a,o){n.o(e,a)||Object.defineProperty(e,a,{enumerable:!0,get:o})},n.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,a){if(1&a&&(e=n(e)),8&a)return e;if(4&a&&"object"===typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&a&&"string"!=typeof e)for(var s in e)n.d(o,s,function(a){return e[a]}.bind(null,s));return o},n.n=function(e){var a=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(a,"a",a),a},n.o=function(e,a){return Object.prototype.hasOwnProperty.call(e,a)},n.p="/";var i=window["webpackJsonp"]=window["webpackJsonp"]||[],m=i.push.bind(i);i.push=a,i=i.slice();for(var u=0;u<i.length;u++)a(i[u]);var d=m;t.push([0,"chunk-vendors"]),o()})({0:function(e,a,o){e.exports=o("56d7")},"034f":function(e,a,o){"use strict";var s=o("64a9"),r=o.n(s);r.a},"0919":function(e,a,o){"use strict";var s=o("4a62"),r=o.n(s);r.a},"2aad":function(e,a,o){},"4a62":function(e,a,o){},"56d7":function(e,a,o){"use strict";o.r(a);o("cadf"),o("551c"),o("f751"),o("097d");var s=o("2b0e"),r=o("8c4f"),t=o("0284"),n=o.n(t),i=o("d36c"),m=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{attrs:{id:"app"}},[o("transition",{attrs:{name:"slide"}},[o("router-view")],1)],1)},u=[],d={name:"app"},c=d,l=(o("034f"),o("2877")),v=Object(l["a"])(c,m,u,!1,null,null,null),p=v.exports,_=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("span")},f=[],g={props:["entry"]},q=g,b=Object(l["a"])(q,_,f,!1,null,null,null),x=b.exports,j=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{staticClass:"card bg-light"},[o("div",{staticClass:"card-heading bg-primary text-light"},[o("b",[e._v(e._s(e.title))])]),o("div",{staticClass:"card-body"},[e._t("default")],2)])},h=[],y={props:["title"]},C=y,z=(o("ed52"),Object(l["a"])(C,j,h,!1,null,null,null)),E=z.exports,P=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("blockquote",{staticClass:"blockquote"},[o("p",{staticClass:"mb-0"},[e._t("default")],2),o("footer",{staticClass:"blockquote-footer"},[e._v(e._s(e.author)+" "),o("cite",{directives:[{name:"title",rawName:"v-title",value:e.work,expression:"work"}]},[e._v(e._s(e.work))])])])},A=[],O={props:["author","work"],directives:{title:{}}},V=O,S=Object(l["a"])(V,P,A,!1,null,null,null),w=S.exports,N=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div")},J=[],L={name:"Comment"},R=L,k=Object(l["a"])(R,N,J,!1,null,null,null),T=k.exports,I=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",[o("BigHeader"),o("HomeContent"),o("BigFooter")],1)},U=[],D=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{staticClass:"jumbotron jumbotron-fluid bg-secondary text-light"},[o("div",{staticClass:"container"},[o("h4",[e._v("O autor")]),o("p",{staticClass:"lead"},[e._v("Plínio Balduino ")]),o("p",[e._v("Plínio Balduino desenvolve softwares para diversas plataformas há quase vinte anos, tenta tocar baixo decentemente há dez, é casado com Roberta e pai de Gustavo, Mariana e Duda. É autor do livro Dominando JavaScript com jQuery, publicado pela Editora Casa do Código.")]),o("p",[e._v("É também mantenedor dos sites ClojureDocs BR, e Clojure Brasil, além de ser um dos organizadores do (clj-sp), o grupo de usuários Clojure de São Paulo e Rio de Janeiro, administrador da lista de discussão ClojureBrasil e membro ativo da lista oficial do Clojure e da lista Clojure Portugal.")]),o("p",[e._v("No último capítulo há uma lista com os links dos sites citados aqui e mais alguns muito interessantes para o desenvolvedor Clojure.")]),o("hr"),o("h5",[e._v("Licenças e direitos autorais")]),e._m(0),e._m(1),e._m(2),o("Version")],1)])},M=[function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("p",[o("small",[e._v("Os direitos autorais deste site e de seu conteúdo pertencem a Plínio Balduino, exceto onde seja informado o contrário. Você pode compartilhar, copiar e citar o conteúdo aqui presente, desde que informando a fonte. Você não pode utilizar o conteúdo aqui presente como se fosse o autor. Ao utilizar este site e seu conteúdo, você está automaticamente concordando com estes termos.")])])},function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("p",[o("small",[e._v("Os direitos autorais do Clojure, o nome Clojure e qualquer recurso relacionado pertencem a Rich Hickey e/ou seus respectivos autores, exceto onde informado o contrário.")])])},function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("p",[o("small",[e._v("Os direitos autorais sobre o logotipo do Clojure pertencem a Tom Hickey.")])])}],B=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{attrs:{id:"version"}},[o("small",[e._v("Versão: "+e._s(e.GitHash))])])},F=[],$=o("8f96"),Q={name:"Version",data:function(){return{GitHash:$}}},G=Q,H=Object(l["a"])(G,B,F,!1,null,null,null),W=H.exports,X={name:"BigFooter",components:{Version:W}},K=X,Y=Object(l["a"])(K,D,M,!1,null,null,null),Z=Y.exports,ee=function(){var e=this,a=e.$createElement;e._self._c;return e._m(0)},ae=[function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{staticClass:"jumbotron jumbotron-fluid bg-primary text-light"},[o("div",{staticClass:"container"},[o("h1",{staticClass:"display-4"},[o("img",{staticClass:"d-none d-md-inline",attrs:{src:"https://clojure.org/images/clojure-logo-120b.png"}}),e._v("\n      Descobrindo Clojure\n    ")]),o("h2",[e._v("Programação funcional descomplicada para a JVM")])])])}],oe={name:"BigHeader"},se=oe,re=Object(l["a"])(se,ee,ae,!1,null,null,null),te=re.exports,ne=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{staticClass:"container"},[e._m(0),o("div",{staticClass:"row"},[o("ToC"),e._m(1)],1)])},ie=[function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{staticClass:"row"},[o("div",{staticClass:"col-sm text-clojure-dark-blue"},[o("p",{staticClass:"text-justify"},[e._v("\n        Você sempre quis aprender Clojure mas, por qualquer motivo, prefere um material em Português? E se, além de estar no seu idioma preferido, ele ainda for tão bom quanto os melhores livros em Inglês e o mais completo em Português?\n      ")]),o("p",{staticClass:"text-justify"},[e._v("\n        Seria excelente, não?\n      ")]),o("p",{staticClass:"text-justify"},[e._v("\n        Depois de mais tempo do que eu gostaria, estou disponibilizando o conteúdo do meu livro gratuitamente e online para que você possa entender, aprender e se tornar um programador Clojure. Ou simplesmente se tornar um melhor programador em qualquer linguagem que você prefira usar, apenas por ter aprendido práticas de programação funcional.\n      ")]),o("p",{staticClass:"text-justify"},[e._v("\n        Caso você prefira ler no conforto do seu leitor de e-books, em breve vou disponibilizar o conteúdo neste formato. Ou, caso você prefira o bom e velho livro em papel, também em breve você poderá adquirí-lo através da Amazon.\n      ")])])])},function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{staticClass:"col-sm-3 text-clojure-dark-blue"},[o("h3",[e._v("Quero o livro")]),o("p",[o("img",{staticClass:"img-fluid img-cover",attrs:{src:"img/cover.png"}})]),o("p",[e._v("\n        Quer comprar ou baixar? Aguarde.\n        ")])])}],me=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{staticClass:"col-sm mr-1 text-clojure-dark-blue",attrs:{id:"index"}},[o("a",{attrs:{name:"toc"}}),o("h3",[e._v("Quero ler online")]),o("ul",[o("li",[o("router-link",{attrs:{to:"/online"}},[e._v("Sobre a versão online")])],1),o("li",[e._v("Introdução")]),o("ul",[o("li",[o("router-link",{attrs:{to:"/dedication"}},[e._v("Dedicatória")])],1),o("li",[o("router-link",{attrs:{to:"/foreword"}},[e._v("Prefácio")])],1),o("li",[o("router-link",{attrs:{to:"/thanks"}},[e._v("Agradecimentos")])],1),o("li",[o("router-link",{attrs:{to:"/author"}},[e._v("Sobre o autor")])],1),o("li",[o("router-link",{attrs:{to:"/warning"}},[e._v("Aviso")])],1)])]),o("ol",[o("li",[o("router-link",{attrs:{to:"/presentation"}},[e._v("Apresentação")])],1),e._m(0),o("li",[o("router-link",{attrs:{to:"/gentleintro"}},[e._v("Uma introdução gentil ao Clojure")])],1),e._m(1),o("li",[o("router-link",{attrs:{to:"/repl"}},[e._v("O REPL é tão importante...")])],1),e._m(2),o("li",[o("router-link",{attrs:{to:"/functions"}},[e._v("Descobrindo o poder das funções")])],1),e._m(3),o("li",[o("router-link",{attrs:{to:"/data"}},[e._v("Dados e metadados")])],1),o("ul"),o("li",[e._v("Namespaces para organizar o código")]),o("li",[e._v("Calculando o infinito com lazy sequences")]),o("li",[e._v("Integrando Clojure com Java")]),o("li",[e._v("Concorrência e multithreading")]),o("li",[e._v("Estendendo a linguagem com macros")]),o("li",[e._v("Dicas para um bom desenvolvimento em Clojure")]),o("li",[e._v("Onde aprender mais")])]),e._v("\nE vem muito mais por aí\n")])},ue=[function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("ul",[o("li",[e._v("Por que Clojure?")]),o("li",[e._v("Para quem é esse livro")]),o("li",[e._v("Como o livro está organizado")]),o("li",[e._v("Lista de discussão e código fonte")])])},function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("ul",[o("li",[e._v("O que é Clojure?")]),o("li",[e._v("Configurando o ambiente")]),o("li",[e._v("Explicando a sintaxe")]),o("li",[e._v("Explicando os parênteses")])])},function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("ul",[o("li",[e._v("...que merece um capítulo a parte")]),o("li",[e._v("Alguns truques rápidos com o REPL")]),o("li",[e._v("Desenvolvimento baseado no REPL")]),o("li",[e._v("Criando uma aplicação de exemplo")]),o("li",[e._v("Modificando a aplicação através do REPL")])])},function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("ul",[o("li",[e._v("O que são funções")]),o("li",[e._v("Transformando dados")]),o("li",[e._v("Funções anônimas")]),o("li",[e._v("Dando nomes às funções")]),o("li",[e._v("Sobrecarga de função e parâmetros opcionais")]),o("li",[e._v("Documentação")]),o("li",[e._v("Criando escopos locais")]),o("li",[e._v("Escopos global, léxico e dinâmico")]),o("li",[e._v("Contratos e condições")]),o("li",[e._v("Destructuring")]),o("li",[e._v("Usando recursão")]),o("li",[e._v("Closures, currying e aplicações parciais")]),o("li",[e._v("Memoização")]),o("li",[e._v("Recursão mútua com trampoline")]),o("li",[e._v("Composição de funções")]),o("li",[e._v("Thread macros")]),o("li",[e._v("Polimorfismo com multimethods")]),o("li",[e._v("Polimorfismo com protocolos")])])}],de={name:"ToC"},ce=de,le=(o("0919"),Object(l["a"])(ce,me,ue,!1,null,null,null)),ve=le.exports,pe={name:"HomeContent",components:{ToC:ve}},_e=pe,fe=Object(l["a"])(_e,ne,ie,!1,null,null,null),ge=fe.exports,qe={name:"Home",components:{BigFooter:Z,BigHeader:te,HomeContent:ge}},be=qe,xe=Object(l["a"])(be,I,U,!1,null,null,null),je=xe.exports,he=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("img",{directives:[{name:"src",rawName:"v-src",value:e.src,expression:"src"},{name:"alt",rawName:"v-alt",value:e.description,expression:"description"}]})},ye=[],Ce={props:["src","description","width","label"]},ze=Ce,Ee=Object(l["a"])(ze,he,ye,!1,null,null,null),Pe=Ee.exports,Ae=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("span")},Oe=[],Ve={props:["entry"]},Se=Ve,we=Object(l["a"])(Se,Ae,Oe,!1,null,null,null),Ne=we.exports,Je=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("span")},Le=[],Re={props:["entry"]},ke=Re,Te=Object(l["a"])(ke,Je,Le,!1,null,null,null),Ie=Te.exports,Ue=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",[o("LittleHeader"),o("div",{staticClass:"container"},[o("div",{staticClass:"row"},[o("div",{staticClass:"col-sm text-clojure-dark-blue"},[e._t("default")],2)])]),o("LittleFooter")],1)},De=[],Me=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{staticClass:"jumbotron jumbotron-fluid bg-secondary text-light"},[o("div",{staticClass:"container"},[e._m(0),e._m(1),e._m(2),o("Version")],1)])},Be=[function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("p",{staticClass:"text-justify"},[o("small",[e._v("Os direitos autorais deste site e de seu conteúdo pertencem a Plínio Balduino, exceto onde seja informado o contrário. Você pode compartilhar, copiar e citar o conteúdo aqui presente, desde que informando a fonte. Você não pode utilizar o conteúdo aqui presente como se fosse o autor. Ao utilizar este site e seu conteúdo, você está automaticamente concordando com estes termos.")])])},function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("p",{staticClass:"text-justify"},[o("small",[e._v("Os direitos autorais do Clojure, o nome Clojure e qualquer recurso relacionado pertencem a Rich Hickey e/ou seus respectivos autores, exceto onde informado o contrário.")])])},function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("p",{staticClass:"text-justify"},[o("small",[e._v("Os direitos autorais sobre o logotipo do Clojure pertencem a Tom Hickey.")])])}],Fe={name:"LittleFooter",components:{Version:W}},$e=Fe,Qe=Object(l["a"])($e,Me,Be,!1,null,null,null),Ge=Qe.exports,He=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{staticClass:"jumbotron jumbotron-fluid bg-primary text-light"},[o("div",{staticClass:"container"},[o("h1",{staticClass:"display-4 text-light"},[o("router-link",{attrs:{to:"/"}},[o("img",{staticClass:"d-none d-md-inline",attrs:{src:"https://clojure.org/images/clojure-logo-120b.png"}}),e._v("\n        Descobrindo Clojure\n      ")])],1)])])},We=[],Xe={name:"LittleHeader"},Ke=Xe,Ye=Object(l["a"])(Ke,He,We,!1,null,null,null),Ze=Ye.exports,ea={components:{LittleHeader:Ze,LittleFooter:Ge}},aa=ea,oa=Object(l["a"])(aa,Ue,De,!1,null,null,null),sa=oa.exports,ra=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("page",[o("NotFound")],1)},ta=[],na=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("pre",[e._v("user=> ("+e._s(e.$route.params.chapter)+"/read)\nSyntax error compiling at (REPL:1:1).\nNo such namespace: "+e._s(e.$route.params.chapter)+"\n\n; 404 - A página que você procura não existe ou mudou de lugar\n; "),o("router-link",{attrs:{to:"/"}},[e._v("Clique aqui")]),e._v(" para voltar à página inicial")],1)},ia=[],ma={name:"NotFound"},ua=ma,da=Object(l["a"])(ua,na,ia,!1,null,null,null),ca=da.exports,la={name:"Reader",components:{NotFound:ca}},va=la,pa=Object(l["a"])(va,ra,ta,!1,null,null,null),_a=pa.exports,fa=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{directives:[{name:"highlight",rawName:"v-highlight"}]},[o("pre",{class:e.className},[o("code",[e._t("default")],2)])])},ga=[],qa=(o("4917"),o("a481"),o("ac6a"),o("f3e2"),o("28a5"),o("78b6"));o("80be"),o("9999"),o("877c"),o("27f2");(function(){if("undefined"!==typeof self&&self.Prism&&self.document){var e="line-numbers",a=/\n(?!$)/g,o=function(e){var o=s(e),r=o["white-space"];if("pre-wrap"===r||"pre-line"===r){var t=e.querySelector("code"),n=e.querySelector(".line-numbers-rows"),i=e.querySelector(".line-numbers-sizer"),m=t.textContent.split(a);i||(i=document.createElement("span"),i.className="line-numbers-sizer",t.appendChild(i)),i.style.display="block",m.forEach(function(e,a){i.textContent=e||"\n";var o=i.getBoundingClientRect().height;n.children[a].style.height=o+"px"}),i.textContent="",i.style.display="none"}},s=function(e){return e?window.getComputedStyle?getComputedStyle(e):e.currentStyle||null:null};window.addEventListener("resize",function(){Array.prototype.forEach.call(document.querySelectorAll("pre."+e),o)}),qa["a"].hooks.add("complete",function(e){if(e.code){var s=e.element,r=s.parentNode;if(r&&/pre/i.test(r.nodeName)&&!s.querySelector(".line-numbers-rows")){for(var t=!1,n=/(?:^|\s)line-numbers(?:\s|$)/,i=s;i;i=i.parentNode)if(n.test(i.className)){t=!0;break}if(t){s.className=s.className.replace(n," "),n.test(r.className)||(r.className+=" line-numbers");var m,u=e.code.match(a),d=u?u.length+1:1,c=new Array(d+1).join("<span></span>");m=document.createElement("span"),m.setAttribute("aria-hidden","true"),m.className="line-numbers-rows",m.innerHTML=c,r.hasAttribute("data-start")&&(r.style.counterReset="linenumber "+(parseInt(r.getAttribute("data-start"),10)-1)),e.element.appendChild(m),o(r),qa["a"].hooks.run("line-numbers",e)}}}}),qa["a"].hooks.add("line-numbers",function(e){e.plugins=e.plugins||{},e.plugins.lineNumbers=!0}),qa["a"].plugins.lineNumbers={getLine:function(a,o){if("PRE"===a.tagName&&a.classList.contains(e)){var s=a.querySelector(".line-numbers-rows"),r=parseInt(a.getAttribute("data-start"),10)||1,t=r+(s.children.length-1);o<r&&(o=r),o>t&&(o=t);var n=o-r;return s.children[n]}}}}})();var ba={props:{language:String},directives:{class:{}},computed:{className:function(){return"language-".concat(this.language)}},created:function(){}},xa=ba,ja=(o("d140"),Object(l["a"])(xa,fa,ga,!1,null,null,null)),ha=ja.exports,ya=function(){var e=this,a=e.$createElement;e._self._c;return e._m(0)},Ca=[function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{staticClass:"alert alert-danger",attrs:{id:"wip",role:"alert"}},[o("p",{staticClass:"text-justify"},[o("b",[e._v("Este capítulo contém trabalho em andamento.")])]),o("p",{staticClass:"text-justify"},[e._v("Isso significa que esse capítulo pode conter conteúdo em revisão,\ntexto que ainda precisa ser formatado ou algum trecho que precisa ser escrito.")])])}],za={name:"Wip"},Ea=za,Pa=Object(l["a"])(Ea,ya,Ca,!1,null,null,null),Aa=Pa.exports,Oa=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("page",[o("div",{staticClass:"col-sm text-clojure-dark-blue"},[o("h1",[e._v("Sobre o autor")]),o("p",{staticClass:"text-justify"},[e._v("Plínio Balduino desenvolve softwares para diversas plataformas há quase vinte anos, tenta tocar baixo decentemente há cinco, é casado com a Roberta e pai de Gustavo, Mariana e Duda. É autor do livro "),o("i",[e._v("Dominando JavaScript com jQuery")]),o("bib",{attrs:{index:"dominando-js"}}),e._v(", publicado pela Editora Casa do Código.")],1),o("p",{staticClass:"text-justify"},[e._v("É também mantenedor dos sites ClojureDocs BR, e Clojure Brasil, além de ser um dos organizadores do (clj-sp), o grupo de usuários Clojure de São Paulo e Rio de Janeiro, administrador da lista de discussão ClojureBrasil e membro ativo da lista oficial do Clojure e da lista Clojure Portugal.")]),o("p",{staticClass:"text-justify"},[e._v("No último capítulo há uma lista com os links dos sites citados aqui e mais alguns muito interessantes para o desenvolvedor Clojure.")]),o("img",{staticClass:"img-fluid img-cover",attrs:{src:"./img/autor.jpg",alt:"Autor falando sobre Clojure na QCon SP 2013"}})])])},Va=[],Sa={name:"Author"},wa=Sa,Na=Object(l["a"])(wa,Oa,Va,!1,null,null,null),Ja=Na.exports,La=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("page",[o("wip"),o("h1",[e._v("Dados e metadados")]),o("index",{attrs:{entry:"capitulo-dados"}}),o("chapter-quote",{attrs:{author:"Rich Hickey",work:", criador do Clojure"}},[e._v('"Choose immutability and see where it takes you"')]),o("p",{staticClass:"text-justify"},[e._v("Uma das coisas mais difíceis de entender e aceitar em uma linguagem funcional, quando estamos tendo um primeiro contato, é o fato dos dados, na maioria das vezes, não poderem ser alterados depois de criados.")]),o("p",{staticClass:"text-justify"},[e._v("Essa característica de não podermos alterar o dado após sua criação é chamada de.")]),o("p",{staticClass:"text-justify"},[e._v("Em uma linguagem como o Java, por exemplo, é comum criarmos uma variável temporária e alterarmos seu valor até chegarmos ao resultado que queremos.")]),o("p",{staticClass:"text-justify"},[e._v("Lá nos primórdios das linguagens de programação, memória e processamento eram recursos caríssimos, então cadafazia a diferença. O conceito deaté já existia, mas era inviável nas máquinas comerciais existentes.")]),o("p",{staticClass:"text-justify"},[e._v("Por conta disso, o reaproveitamento de variáveis era considerada uma boa prática, e a mutabilidade de dados numa linguagem era quase obrigatória.")]),o("p",{staticClass:"text-justify"},[e._v("De certo modo, modificar o valor de uma variável, desde que isso não insira bugs no código, não é uma prática ruim. O problema começa quando você tem que compartilhar esse valor entre diferentes processos ou.")]),o("p",{staticClass:"text-justify"},[e._v("Partindo do pressuposto que o leitor teve infância, tente imaginar que você tenha um saquinho de bolas de gude (burca, fubeca, ou bila dependendo da época e do lugar da sua infância) e você, na solidão de um quintal ou do carpete da avó, queira contar quantas bolinhas existem ali.")]),o("p",{staticClass:"text-justify"},[e._v("Estando você sozinho, fica fácil de contar por mais que isso demore. Você pegas as bolinhas de um lugar, coloca em outro e incrementa um contador mental. Ao acabar as bolinhas, você tem a quantidade.")]),o("p",{staticClass:"text-justify"},[e._v("Agora imagine que você tenha um irmão que goste de atrapalhar. Irmãos são ótimos para isso. Enquanto você conta as bolinhas, ele muda a quantidade de bolinhas de um lado, do outro, ou mesmo começa a sumir com as bolinhas.")]),o("p",{staticClass:"text-justify"},[e._v("Mesmo que você consiga terminar, sua contagem não vai servir para nada.")]),o("p",{staticClass:"text-justify"},[e._v("Então você resolve organizar as coisas.")]),o("p",{staticClass:"text-justify"},[e._v("Você separa suas bolinhas em dois grupos. Uma para o irmão bagunceiro, outra para você. Ele conta o grupo de lá, você conta o grupo de cá e no final vocês somam os totais.")]),o("p",{staticClass:"text-justify"},[e._v("Bacana, assim funcionou.")]),o("p",{staticClass:"text-justify"},[e._v("Não acho que estavam pensando em bolinhas de gude, mas as pessoas que criam linguagens de programação resolveram colocar semáforos, como esses de trânsito, para que dois processos não alterem a mesma variável, como dois irmãos fazendo bagunça. No Java os semáforos são chamados de.")]),o("p",{staticClass:"text-justify"},[e._v("A história dos semáforos funciona muito bem quando temos dois processos querendo mexer no mesmo valor, mas a coisa começa a ficar bem complicada quando passamos a ter vários processos querendo mexer no mesmo lugar.")]),o("p",{staticClass:"text-justify"},[e._v("Muitos algoritmos foram desenvolvidos, muitas ideias foram pensadas e muitas noites de sono foram perdidas até que alguém se perguntou se não seria uma boa se os valores simplesmente não mudassem.")]),o("p",{staticClass:"text-justify"},[e._v("E essa pessoa estava certa.")]),o("p",{staticClass:"text-justify"},[e._v("Se um valor não se altera até o fim de sua vida, qual a necessidade de criarmos gerenciamentos complicados com semáforos, travas e outras analogias? O númerosempre será, não importando quantas pessoas o estejam usando ao mesmo tempo.")]),o("p",{staticClass:"text-justify"},[e._v("Se você acha isso pouco prático e difícil de imaginar, pense na classedo Java. Uma vez que você crie um valor do tipo, ele não pode mais ser modificado.")]),o("p",{staticClass:"text-justify"},[e._v("Os métodos deretornam um novo valor, mantendo o texto original inalterado. Isso significa que um valoré imutável e, por definição, um valor imutável pode ser compartilhado sem medo entre diferentes processos ou.")]),o("p",{staticClass:"text-justify"},[e._v("Quando um valor pode ser compartilhado entre diferentessem medo de fazermos lambança, dizemos que o valor é.")]),o("p",{staticClass:"text-justify"},[e._v("Como fazemos então para lidar com valores imutáveis se em algum momento vamos precisar que um valor seja modificado para outro?")]),o("p",{staticClass:"text-justify"},[e._v("A primeira coisa que podemos fazer é não modificar valores, e sim transformá-los. Isso significa que vamos gerar um novo valor ao invés de transformar o atual, exatamente como faz a classe.")]),o("p",{staticClass:"text-justify"},[e._v("Por mais que isso possa parecer pouco produtivo em termos de processamento e memória, caso você tenha se perguntado se a cada transformação será criado um objeto completamente novo, o Clojure faz uso depara otimizar essas transformações, compartilhando partes da estrutura entre valores diferentes.")]),o("p",{staticClass:"text-justify"},[e._v("Afinal de contas, se esses valores não serão alterados, qual o problema em os usarmos em diferentes lugares ao mesmo tempo?")]),o("p",{staticClass:"text-justify"},[e._v("A segunda coisa que podemos fazer é limitar as partes móveis da aplicação. Se você isolar as partes mutáveis do seu sistema em lugares que não serão acessados por diferentes threads ao mesmo tempo, ainda assim você consegue manter seu código. Vamos ver como isso funciona ao vermos.")]),o("p",{staticClass:"text-justify"},[e._v("Outro ponto importante de nos apoiarmos em valores imutáveis, mesmo fora do Clojure, é que você não pode confiar naquilo que muda sem que você perceba.")]),o("p",{staticClass:"text-justify"},[e._v("Quando você usa um, por exemplo, você tem cada item formado por uma chave e um valor.")]),o("p",{staticClass:"text-justify"},[e._v("Essa chave é pesquisada através de um valor numérico chamado, que é calculada de acordo com os atributos do objeto. Se os atributos mudam, otambém muda.")]),o("p",{staticClass:"text-justify"},[e._v("Se omuda, a chave dojá não é mais confiável, já que você não vai mais encontrar o objeto com oantigo. É como se você tivesse uma chave de casa para uma fechadura que pode mudar sem você saber. Não parece muito útil, certo?")]),o("p",{staticClass:"text-justify"},[e._v("Por mais que pareça bobeira, é um erro muito comum quando você usa uma linguagem que oferece a mutabilidade como padrão, como é o caso do Java.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos ver em detalhes estruturas persistentes e transientes neste capítulo, enquanto nos capítulos sobre integração com o Java e sobre concorrência vamos ver com calma como a imutabilidade faz toda a diferença.")]),o("p",{staticClass:"text-justify"},[e._v("Um tipo escalar é todo aquele formado por um único valor. Nessa classificação se encaixam;; valores lógicos, ou booleanos, representador pore; e, que representa a ausência de valor ou um valor nulo.")]),o("p",{staticClass:"text-justify"},[e._v("Existem outros dois tipos escalares específicos do Clojure,e.")]),o("p",{staticClass:"text-justify"},[e._v("Você deve se lembrar da formaque usamos para criar umlocal:")]),o("p",{staticClass:"text-justify"},[e._v("No nosso código atribuimos o valor numéricoao.")]),o("p",{staticClass:"text-justify"},[e._v("Odessa expressão é um símbolo Clojure, que internamente vai apontar para o valor. Esse símbolo é representado em Clojure por um tipo chamado.")]),o("p",{staticClass:"text-justify"},[e._v("Por mais que pareça natural ter um símbolo que aponta para um valor em qualquer linguagem, na forma deou, não paramos para pensar no que o símbolo em si representa até encontrarmos um tipo específico para isso, como acontece com o Clojure.")]),o("p",{staticClass:"text-justify"},[e._v("O ato do compilador olhar para um símbolo e utilizar o valor para o qual ele aponta é chamado de. Então, no nosso código, quando você manda imprimir, a linguagem olha para o valor que está sendo apontado e retorna.")]),o("p",{staticClass:"text-justify"},[e._v("Ainda olhando para o código que escrevemos, podemos entender quetambém é um símbolo, que internamente aponta para uma macro, eé ainda outro símbolo que aponta para uma função que imprime na tela.")]),o("p",{staticClass:"text-justify"},[e._v("Então você se pergunta onde é que isso vai ser usado. O tempo todo, eu respondo. Mas você dificilmente vai precisar saber se um valor é um símbolo ou não.")]),o("p",{staticClass:"text-justify"},[e._v("De qualquer maneira, é bom conhecer o que é e o que faz um símbolo.")]),o("p",{staticClass:"text-justify"},[e._v("Existem duas funções para lidar com símbolos:e. A primeira cria um símbolo sem atribuir qualquer valor:")]),o("p",{staticClass:"text-justify"},[e._v("Járetornacaso o parâmetro seja um símbolo. Porém, existe uma pegadinha aí.")]),o("p",{staticClass:"text-justify"},[e._v("Se passarmos o símbolo como parâmetro, a função vai receber o valor que foia ele (daí o nome), e não o símbolo propriamente dito:")]),o("p",{staticClass:"text-justify"},[e._v("Entra em cena o operador, ou simplesmente, que diz ao compilador que aquele símbolo ou expressão não deve ser resolvido ou avaliado.")]),o("p",{staticClass:"text-justify"},[e._v("Já o tipopode ser considerado um irmão mais famoso do, que aponta para si mesmo ao invés de apontar para outro valor. Seé o irmão dedo-duro, podemos dizer queé o irmão egoísta.")]),o("p",{staticClass:"text-justify"},[e._v("normalmente são utilizadas como chaves em um mapa, mas podem também ser utilizadas no lugar de um texto repetitivo que possa indicar uma configuração ou opção de uma função ou biblioteca, como uma constante ou uma enumeração.")]),o("p",{staticClass:"text-justify"},[e._v("Assim como acontece com, existem as funçõesepara, respectivamente, criar umou verificar se o parâmetro é um.")]),o("p",{staticClass:"text-justify"},[e._v("Finalmente, como umtem a si mesmo como valor, não é necessário declará-lo antes de usar.")]),o("p",{staticClass:"text-justify"},[e._v("Internamente, a classe Java responsável pela representação de umimplementa também a classe Javaque é a base de todas as funções do Clojure.")]),o("p",{staticClass:"text-justify"},[e._v("Isso significa que podemos usar umcomo um operador, o que acaba sendo uma boa prática.")]),o("p",{staticClass:"text-justify"},[e._v("Imagine que temos um mapa simples, contendo o código do Estado e seu respectivo nome:")]),o("p",{staticClass:"text-justify"},[e._v("Ambas as formas retornam o mesmo resultado. Mais para frente vamos ver essa característica em detalhes, e quais as suas vantagens.")]),o("p",{staticClass:"text-justify"},[e._v("Existe um tipo especial deque traz automaticamente ono qual ele foi criado junto do próprio nome. Por conta disso ele é chamado de, ou. Vou chamá-los apenas depara não gastar o dedo digitando.")]),o("p",{staticClass:"text-justify"},[e._v("Essede nome diferente funciona assim: ao invés de utilizarmos um sinal de dois-pontos antes do nome, usamos dois. Odo Clojure substitui o segundo sinal de dois-pontos peloatual.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos partir do pressuposto de que você acabou de entrar noe estamos no.")]),o("p",{staticClass:"text-justify"},[e._v("Onão pertence a nenhum. Como já foi dito aqui, ele é um egoísta que só olha para si mesmo. Uma das vantagens disso é que você pode utilizar umem qualquer lugar do sistema sem nem se preocupar onde foi o primeiro lugar em que ele foi criado.")]),o("p",{staticClass:"text-justify"},[e._v("Já opertence ao, não interessando o que aconteça com ele daqui para frente. Isso permite, por exemplo, que você tenha mais de umcom o mesmo nome, desde que cada um pertença a umdiferente.")]),o("p",{staticClass:"text-justify"},[e._v("Apesar do uso dequalificados ser bem menos comum que o seu irmão sem sobrenome, existem situações em que seu uso é bem vindo.")]),o("p",{staticClass:"text-justify"},[e._v("Imagine que você tenha um(ou dicionário, ou mapa - veremos em detalhes a seguir), que pode ser manipulado por funções em diferentes.")]),o("p",{staticClass:"text-justify"},[e._v("Seria uma forma de evitar conflitos caso você tenha doiscom o mesmo nome.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos criar umque será compartilhado por mais de um.")]),o("p",{staticClass:"text-justify"},[e._v("Agora vamos atribuir um valor aoutilizando a função.")]),o("p",{staticClass:"text-justify"},[e._v("Agora vamos criar outroe repetir a alteração.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos utilizarqualificados também para definir hierarquias de tipos de dados. Em linguagens orientadas a objeto nós temos hierarquia de dados na forma de herança. Aquela história de, só que sem herdar os comportamentos típicos de um objeto.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos usar o exemplo dos gatos e cachorros para exemplificar. É um tanto bobo e desconectado do mundo real, mas tem um grande valor didático.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos usar a funçãopara dizer que um tipo é derivado de outro, ou que um tipo é subtipo de outro.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos começar com o cachorro.")]),o("p",{staticClass:"text-justify"},[e._v("Agora vamos para o gato.")]),o("p",{staticClass:"text-justify"},[e._v("Então vamos verificar se um cachorro ou um gato são animais, e então termos certeza de que gatos não são cachorros. Para isso usamos a função.")]),o("p",{staticClass:"text-justify"},[e._v("Parece um tanto lógico também que todo cachorro é um animal, mas nem todo animal é um cachorro.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos dizer também que um poodle é um cachorro, e ainda assim continua sendo um animal.")]),o("p",{staticClass:"text-justify"},[e._v("Lembrando de, vamos integrar com o que acabamos de aprender sobre hierarquia.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos definir alguns mamíferos.")]),o("p",{staticClass:"text-justify"},[e._v("Agora vamos definir alguns animais que voam e outros que nadam.")]),o("p",{staticClass:"text-justify"},[e._v("Agora vamos criarque mostrem mensagens de acordo com tipo do animal. Vamos usar a função, que retorna o próprio parâmetro. Por exemplo,retorna.")]),o("p",{staticClass:"text-justify"},[e._v("Agora começa a diversão. Primeiro vamos testar um cachorro. Para a tranquilidade das entidades protetores de animais, nenhum cachorro será ferido, incomodado ou molestado na execução desses testes.")]),o("p",{staticClass:"text-justify"},[e._v("Legal. Vamos um gato e, em seguida, um morcego.")]),o("p",{staticClass:"text-justify"},[e._v("O Clojure ficou confuso, já que um morcego é mamífero e ao mesmo tempo voador. Tudo bem, é complicado explicar para uma criança que nem todo animal que voa é ave.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos utilizar a funçãopara dizer qual valor tem prioridade na hierarquia.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos dar um desconto ao nosso código por ele não saber que o correto éao invés de.")]),o("p",{staticClass:"text-justify"},[e._v("Fazendo o mesmo com os mamíferos que nadam, podemos testar a baleia e o salmão. Novamente nenhum ser aquático será incomodado na execução do código a seguir.")]),o("p",{staticClass:"text-justify"},[e._v("No capítulovamos descobrir outra aplicação paraqualificados ao trabalharmos com protocolos.")]),o("p",{staticClass:"text-justify"},[e._v("Um valor do tipoé um texto, sem nenhuma diferença especial em relação à sua linguagem preferida. Internamente é usada a classe, que é exatamente a mesma que você usa no Java padrão. Isso significa que todos os métodos que você já utiliza comno Java estão disponíveis no Clojure. Vamos usar a funçãopara poder ver isso na prática:")]),o("p",{staticClass:"text-justify"},[e._v("A biblioteca padrão vem também com um namespace chamadoque traz mais algumas funções para complementar os métodos da classedo Java.")]),o("p",{staticClass:"text-justify"},[e._v("Apesar de umaser um tipo escalar, e não uma coleção (que veremos em detalhes mais adiante), o Clojure dá um jeito para que seja tratado como se fosse. Isso acontece porque, sempre que uma função que lida com sequencias recebe uma, é retornada uma sequencia de verdade, ou parte dela, como resultado:")]),o("p",{staticClass:"text-justify"},[e._v("Quando o Clojure trata umacomo sequencia, cada item é representado por um caracter. Da mesma forma, qualquer método válido para tratar caracteres em Java pode ser usado para manipular caracteres em Clojure, uma vez que o tipo é o mesmo em ambas as linguagens.")]),o("p",{staticClass:"text-justify"},[e._v("A principal diferença aqui é visual. Enquanto em Java os caracteres são representados entre apóstrofos, em Clojure utilizamos uma barra invertida antes do caracter:")]),o("p",{staticClass:"text-justify"},[e._v("E para montar umaa partir de vários caracteres, podemos usar a conhecida função:")]),o("p",{staticClass:"text-justify"},[e._v("Expressões regulares são sequencias de caracteres que formam um padrão de busca. A ideia foi criada na década de 1950, por um matemático chamado Stephen Cole, mas as expressões passaram a ter um uso mais prático na década de 1960, quando Ken Thompson, desenvolveu um editor chamado, que fazia uso de expressões regulares para pesquisar textos dentro de um arquivo.")]),o("p",{staticClass:"text-justify"},[e._v("A título de curiosidade, Ken Thompson também foi o responsável ela linguagem, que deu origem à linguageme também é um dos criadores da linguagem Go.")]),o("p",{staticClass:"text-justify"},[e._v("Uma expressão regular em Clojure é escrita como uma, mas com um caracterna frente. Você também pode criar uma expressão regular a partir de umausando a função:")]),o("p",{staticClass:"text-justify"},[e._v("Para encontrarmos um valor dentro de outro, usamos a função, passando como parâmetros a expressão regular e o texto que pode conter o que precisamos:")]),o("p",{staticClass:"text-justify"},[e._v("Caso a expressão, ou, não seja encontrada na frase, a funçãoretorna. No nosso exemplo, não havia nenhum gato próximo à roupa do rei de Roma e deu no que deu.")]),o("p",{staticClass:"text-justify"},[e._v("Já a funçãonos retorna uma sequencia contendo todas as ocorrências daquele. Vamos criar uma sequencia contendo todas as palavras da frase que comecem com a letra:")]),o("p",{staticClass:"text-justify"},[e._v("E cadê a palavra?")]),o("p",{staticClass:"text-justify"},[e._v("Por padrão, uma expressão regular diferencia maiúsculas de minúsculas. Para alterar esse comportamento precisamos adicionar a opçãoantes do:")]),o("p",{staticClass:"text-justify"},[e._v("Existem várias outras opções além do")]),o("p",{staticClass:"text-justify"},[e._v("Existem guias de expressões regulares para todos os gostos na Internet, além de sites para que você possa testar suas expressões contra textos de diversos tamanhos. Os meus preferidos, e os que recomendo, são o(http://www.rubular.com) e o(http://www.regexr.com/).")]),o("p",{staticClass:"text-justify"},[e._v("A funçãoque está no namespacetambém utiliza expressões regulares para substituir ocorrências dentro de textos.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos usarparaa frase:")]),o("p",{staticClass:"text-justify"},[e._v("Agora que sabemos tudo sobreno Clojure, vamos aos números.")]),o("p",{staticClass:"text-justify"},[e._v("Não há muitos segredos quando se trata de números em Clojure. Números inteiros são, por padrão, representados com a classedo Java, que permite valores entree, o que dá e sobra para a maioria dos cálculos que quisermos fazer.")]),o("p",{staticClass:"text-justify"},[e._v("As constantesecontém, respectivamente, o menor e o maior valor possível que pode ser armazenado como. É bem mais fácil lembrar o nome da constante do que memorizar esses valores gigantescos.")]),o("p",{staticClass:"text-justify"},[e._v("Caso isso ainda não seja suficiente, o próprio Clojureo valor paracaso você utilize os operadores terminados em, como,,e assim por diante.")]),o("p",{staticClass:"text-justify"},[e._v("Para lidar com números decimais, é utilizada a classedo Java. Da mesma forma que acontece com os números inteiros, o Clojure pode promover o valor paracaso seja necessário.")]),o("p",{staticClass:"text-justify"},[e._v("Você pode trabalhar diretamente come, adicionando a letraao final do número inteiro ou a letraao final do número decimal.")]),o("p",{staticClass:"text-justify"},[e._v("Existem também as funçõese, caso você precise converter o valor em tempo de execução.")]),o("p",{staticClass:"text-justify"},[e._v("Resumidamente,é quando tentamos atribuir um valor muito grande a um tipo de dado que não comporta aquela quantidade de informação.")]),o("p",{staticClass:"text-justify"},[e._v("Imagine que você tem um copo de 300ml e queira colocar um litro d'água dentro dele. Obviamente o litro d'água não vai caber no copo, então podem acontecer duas coisas: ou você desiste assim que perceber que a água não vai caber no copo; ou continua assim mesmo, despejando o litro, perdendo tudo o que foi derramado para fora do copo. Aliás, a tradução literal depara o português é justamente.")]),o("p",{staticClass:"text-justify"},[e._v("O Clojure permite que você escolha qualquer uma dessas duas abordagens e ainda traz uma terceira que não seria possível apenas usando o copo.")]),o("p",{staticClass:"text-justify"},[e._v("Na primeira forma, que seria aquela em que desistimos no meio do caminho, vamos causar um erro, parando o processo para que nada de pior aconteça.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos utilizar a constanteque vimos acima, para já começarmos o exemplo no limite da capacidade de um tipo.")]),o("p",{staticClass:"text-justify"},[e._v("Sobre esse valor, vamos somar, que é suficiente para fazermos o copo transbordar, como podemos ver na figura.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos permitir também que o copo transborde usando explicitamente as operações iniciadas por. Com isso deixamos claro que não estamos checando se houve, ganhando um pouco de tempo, mas perdendo completamente a segurança das checagens.")]),o("p",{staticClass:"text-justify"},[e._v("Aqui não ocorre o erro, mas ao somarmosao valor de, que é, teremos um número negativo. Aqui dizemos que ocorreu o, como podemos ver na figura.")]),o("p",{staticClass:"text-justify"},[e._v("Apenas para que você entenda o que aconteceu, considere que um valor do tipoocupa 64 bits de memória. Como esse número pode ser positivo ou negativo, o bit mais significativo, que é aquele mais a esquerda, é usado para indicar o sinal do número:se for negativo,se for positivo.")]),o("p",{staticClass:"text-justify"},[e._v("Com isso, o maior número positivo possível é, enquanto o maior número negativo é. Odo número positivo se deve ao fato do zero ser considerado positivo.")]),o("p",{staticClass:"text-justify"},[e._v("O númeroem binário é uma sequencia de 63 bits. Ao somar o número, teremos um bitseguido de 63 bits. Como acabamos de dizer, o bit mais a esquerda é usado como indicador de sinal, retornando o maior número negativo possível, que é o gigantesco. Esse bit mais a esquerda, que erae viroucom a soma, transbordou na conta, vindo daí o termo.")]),o("p",{staticClass:"text-justify"},[e._v("Na figuratemos uma variável de oito bits contendo o valore ao somarmosrecebemos o valor. Perceba que a soma, ou, para o bit responsável pelo sinal.")]),o("p",{staticClass:"text-justify"},[e._v("Voltando à nossa analogia, imagine que você, percebendo que o copo não vai comportar um litro d'água, ao invés de desistir ou desperdiçar água, busque um recipiente maior. Uma jarra, por exemplo. Pois é exatamente isso que o Clojure faz quando você usa o terceiro tipo de operador.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos utilizar os operadores que já conhecemos seguidos do caracter, assim teremos as operações,e várias outras que automaticamente modificam o tipo do dado em que o valor vai ser guardado.")]),o("p",{staticClass:"text-justify"},[e._v("Perceba na figuraque o resultado está correto e que também aparece a letra, que indica que o número agora é um. Chamamos isso de, ou.")]),o("p",{staticClass:"text-justify"},[e._v("Então devemos usar sempre os operadores seguidos de? Não necessariamente.")]),o("p",{staticClass:"text-justify"},[e._v("Cada uma das formas tem suas vantagens e desvantagens. A formatende a ser mais rápida, sendo muito útil quando você está manipulando dados em conjunto com uma biblioteca do Java e a velocidade é algo crítico.")]),o("p",{staticClass:"text-justify"},[e._v("Já a forma seguida detende a ser mais lenta e ocupar mais memória, mas promove automaticamente os tipos de dados.")]),o("p",{staticClass:"text-justify"},[e._v("De qualquer forma, em pelo menos oitenta por cento dos casos, os operadores que você já conhecia servirão perfeitamente para o que você precisa.")]),o("p",{staticClass:"text-justify"},[e._v("É comum que as linguagens de programação forneçam formas de escrevermos números usando bases diferentes da que estamos habituados.")]),o("p",{staticClass:"text-justify"},[e._v("Nas linguagens inspiradas pelo C, podemos escrever números em baseeno meio do código, e o próprio compilador se vira para converter.")]),o("p",{staticClass:"text-justify"},[e._v("Já o Clojure nos oferece bem mais do que vamos precisar. Podemos escrever números em praticamente qualquer base que desejarmos, além das que as linguagens tradicionais já nos oferecem.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos colocar praticamente qualquer número inteiro antes do literal, e o compilador vai entender que queremos converter a partir daquela base.")]),o("p",{staticClass:"text-justify"},[e._v("Com tanta base disponível de forma transparente, dá para se divertir bastante com mensagens engraçadinhas.")]),o("p",{staticClass:"text-justify"},[e._v("Você pode expressar também números muito grandes ou muito pequenos usando.")]),o("p",{staticClass:"text-justify"},[e._v("Notação científica é uma forma de representar valores usando a notação. Podemos representar dois milhões comoou, em Clojure, como. Umpode ser representado como, ou seja, o dígito um seguido dezeros.")]),o("p",{staticClass:"text-justify"},[e._v("Da mesma forma, podemos representar um número menor queusando um expoente negativo.")]),o("p",{staticClass:"text-justify"},[e._v("Estima-se que um átomo de hidrogênio tenhametros. Isso dá onze zeros depois da vírgula e, em seguida, o número.")]),o("p",{staticClass:"text-justify"},[e._v("Obviamente a precisão e as casas decimais são ignoradas a partir de um certo tamanho porque, como já dissemos, a memória de um computador é limitada e temos estruturas bem reduzidas para armazenar números dentro dele.")]),o("p",{staticClass:"text-justify"},[e._v("Caso você tenha curiosidade de saber os limites dessa notação, as constanteseda classepodem te dizer.")]),o("p",{staticClass:"text-justify"},[e._v("Fique tranquilo. Com essa notação podemos trabalhar com números muito maiores que ume muito menores que o tamanho do menor átomo.")]),o("p",{staticClass:"text-justify"},[e._v("Quando dividimos um número por outro em Clojure podemos ter duas respostas diferentes: um número inteiro ou um número racional.")]),o("p",{staticClass:"text-justify"},[e._v("O resultado deé, um número que internamente é representado pelo tipo.")]),o("p",{staticClass:"text-justify"},[e._v("Quando executamos a mesma operação em Java, Ruby ou qualquer outra linguagem popular, recebemos um número inteiro ou um decimal como resultado. Por que em Clojure é diferente?")]),o("p",{staticClass:"text-justify"},[e._v("O mesmo comportamento, de receber um número racional ao invés de um decimal, é encontrado nas demais implementações de LISP, como o Common Lisp, Scheme e Racket para ficar nas mais conhecidas. Logo, é um comportamento esperado quando estamos usando um Lisp.")]),o("p",{staticClass:"text-justify"},[e._v("Mas não é simplesmente porque todo mundo faz que você deva fazer também. O tipofoi criado para que a perda de precisão com arredondamento seja reduzida ao mínimo possível.")]),o("p",{staticClass:"text-justify"},[e._v("Para convertermos um valor racional em um valor decimal, basta utilizar a função:")]),o("p",{staticClass:"text-justify"},[e._v("E para converter um tipo decimal para racional, usamos a função:")]),o("p",{staticClass:"text-justify"},[e._v("Quando você divide um por três, você tem como resultado o número 0.333... seguido de infinitos 3. Essa repetição infinita de números é chamado de dízima periódica.")]),o("p",{staticClass:"text-justify"},[e._v("O problema é que em um computador existe um espaço finito para armazenar números, o que faz com que apenas uma quantidade reduzida de casas decimais seja armazenada. Esse truncamento do número gera uma perda que, mesmo minúscula, vai se acumulando com outros arredondamentos num processo conhecido matematicamente por.")]),o("p",{staticClass:"text-justify"},[e._v("Em sistemas pequenos esse erro acumulado é irrelevante, mas em grandes sequencias de cálculos pode fazer com que o resultado seja distorcido e cause sérios problemas.")]),o("p",{staticClass:"text-justify"},[e._v("Nas listagensepodemos ver como uma operação matemática pode apresentar diferentes resultados se utilizarmos números decimais.")]),o("p",{staticClass:"text-justify"},[e._v("Para termos uma boa quantidade de números para trabalhar, vamos usar a função, que recebe dois parâmetros e nos retorna uma lista. O primeiro é a quantidade de vezes que o item vai ser repetido, e o segundo parâmetro é o item a ser repetido:")]),o("p",{staticClass:"text-justify"},[e._v("Usando o nosso já conhecido operador, vamos somar cem mil ocorrências do número, que é um dividido por três armazenado como um número decimal:")]),o("p",{staticClass:"text-justify"},[e._v("Agora vamos deixar para converter o valor para decimal apenas no final da operação:")]),o("p",{staticClass:"text-justify"},[e._v("Perceba que houve uma diferença perceptível nos resultados entre as duas formas de calcular. A conversão para decimal no final da operação adia até o último instante a perda de precisão do valor.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos criar uma lista com quatro elementos chamadae vamos adicionar a ela um quinto elemento, guardando o resultado com o nome:")]),o("p",{staticClass:"text-justify"},[e._v("A função, que adiciona um item ao final do vetor, retorna um novo valor e mantém o original inalterado, como já sabemos.")]),o("p",{staticClass:"text-justify"},[e._v("Aparentemente,esãodiferentes. Isso significa que, ainda aparentemente, estamos ocupando memória com duas estruturas distintas, mas com grande parte dos valores repetidos. Isso soa como um belode recursos.")]),o("p",{staticClass:"text-justify"},[e._v("Uma das vantagens de lidarmos com valores imutáveis é que, veja só, eles não mudam.")]),o("p",{staticClass:"text-justify"},[e._v("Isso significa que um valor imutável que está em umimutável permanece o mesmo, não importando o que aconteça. Com isso não precisamos nos preocupar com efeitos colaterais e modificações inesperadas caso esse valor seja compartilhado entre duas estruturas diferentes. E é aí que está o princípio do que em Clojure é chamada de.")]),o("p",{staticClass:"text-justify"},[e._v("Na figurapodemos ter uma idéia do que acontece internamente. Não estamos vendo aqui exatamente como funciona um vetor no Clojure, mas a ideia é a mesma: compartilhar valores iguais entre dois ou mais vetores, otimizando o consumo de memória e melhorando a velocidade das operações.")]),o("p",{staticClass:"text-justify"},[e._v("Mapas e, que veremos adiante, funcionam de forma parecida, sendo armazenados internamente em uma árvore e compartilhando partes conforme a necessidade.")]),o("p",{staticClass:"text-justify"},[e._v("Já uma lista é armazenada internamente como uma lista ligada, mas também compartilha parte de sua estrutura a cada operação.")]),o("p",{staticClass:"text-justify"},[e._v("Em Clojure, existe uma categoria de tipos de dados chamada genericamente de. Uma coleção nada mais é do que a.")]),o("p",{staticClass:"text-justify"},[e._v("O que esse palavreado todo quer dizer?")]),o("p",{staticClass:"text-justify"},[e._v("Quer dizer que uma coleção do Clojure, independente de qual seja, implementa internamente uma mesma interface Java. Essa interface declara operações comuns que permitem que você adicione, remova ou localize itens dentro de uma coleção usando as mesmas funções do Clojure.")]),o("p",{staticClass:"text-justify"},[e._v("Dessa forma você não precisa decorar dezenas de funções diferentes para conseguir trabalhar com cada tipo de coleção. Basta saber que uma função adiciona um item a uma coleção, e essa função vai adicionar itens em qualquer coleção que você esteja trabalhando.")]),o("p",{staticClass:"text-justify"},[e._v("Essas coleções podem ser classificadas, de uma maneira bem simplificada, de acordo com as interfaces Java que cada uma implementa internamente.")]),o("p",{staticClass:"text-justify"},[e._v("Apesar de cada tipo de dado em Clojure implementar uma avalanche de classes e interfaces Java, como podemos ver na figura, podemos utilizar três delas para descrever cada um dos tipos principais de coleção:,e. Na imagempodemos ver mais claramente essa classificação.")]),o("p",{staticClass:"text-justify"},[e._v("Uma coleção sequencial, ou simplesmente uma, é uma abstração que permite que você selecione tanto o primeiro item quanto o resto da sequencia sem o primeiro item, ou que você adicione um item na sequencia sem bagunçar a ordem que existe atualmente.")]),o("p",{staticClass:"text-justify"},[e._v("Uma coleção associativa permite que você acesse qualquer valor diretamente, bastando informar a sua posição ou a chave que faz referência àquela posição.")]),o("p",{staticClass:"text-justify"},[e._v("Finalmente, uma coleção pode serouse nos permite saber a quantidade de itens que ela contém.")]),o("p",{staticClass:"text-justify"},[e._v("Essa divisão é apenas uma forma de ajudar a entender quando e como você deve usar cada coleção do Clojure. Vamos entrar em mais detalhes em cada um dos tipos, deixando claro que você pode criar suas próprias coleções se for necessário.")]),o("p",{staticClass:"text-justify"},[e._v("Um código fonte escrito em Clojure é, basicamente, um conjunto de listas contendo operadores e operandos.")]),o("p",{staticClass:"text-justify"},[e._v("Por isso, a lista é a estrutura de dados mais comum, mas sua utilidade vai bem além das sequencias de instruções para o compilador.")]),o("p",{staticClass:"text-justify"},[e._v("Se você tentar trabalhar diretamente com uma lista, o compilador vai entender que estamos lidando com código fonte, e vai tentar executar o primeiro item como se fosse um operador.")]),o("p",{staticClass:"text-justify"},[e._v("Para que isso não aconteça, temos que informar ao compilador que o conteúdo da lista não deve ser avaliado. Para isso usamos o operador, conhecido como. A forma especialcausa o mesmo efeito.")]),o("p",{staticClass:"text-justify"},[e._v("Usarem uma lista faz com que ela seja transformada de código para dados.")]),o("p",{staticClass:"text-justify"},[e._v("É possível guardar código dentro de uma lista com. Para executar a lista, efetuamos a operação inversa através do operador. O operador, chamado devai ser muito útil quando aprendermos sobre macros.")]),o("p",{staticClass:"text-justify"},[e._v("Aqui nós criamos uma lista contendo uma instrução válida e fizemos o caminho oposto, transformando dados em código.")]),o("p",{staticClass:"text-justify"},[e._v("O operador, conhecido entre nós como acento grave, significa, e também será visto com mais atenção no capítulo sobre macros.")]),o("p",{staticClass:"text-justify"},[e._v("O Clojure oferece também um tipo chamado, que assim como uma lista, pode ter qualquer posição acessada através da função, começando por zero. Umé equivalente a umnas demais linguagens.")]),o("p",{staticClass:"text-justify"},[e._v("Um vetor também pode ser usado como função. Ao passar um valor numérico para um vetor, você obtém o valor contido naquela posição.")]),o("p",{staticClass:"text-justify"},[e._v("Assim você elimina a chamada aexplícita ao acessar alguma posição de um vetor. Internamente o vetor vai continuar usandopara acessar aquela posição, então usar ou não acaba sendo uma questão de estilo e legi bilidade.")]),o("p",{staticClass:"text-justify"},[e._v("Existem algumas diferenças importantes entre as listas e os vetores e que vale a pena conhecer.")]),o("p",{staticClass:"text-justify"},[e._v("A principal diferença é que vetores guardam apenas dados, diferente do que já aprendemos sobre listas e não é tão simples converter os itens de um vetor em uma expressão.")]),o("p",{staticClass:"text-justify"},[e._v("Vetores têm um tempo constante de acesso a qualquer posição, então uma lista leva mais tempo para acessar um item que está no meio do que um que está no começo.")]),o("p",{staticClass:"text-justify"},[e._v("Um vetor é alocado de uma única vez na memória, tornando impossível lidar com quantidades imensas de informação, enquanto com uma lista você pode alocar somente o que está sendo utilizado naquele momento. Veremos isso com detalhes ao tratar de.")]),o("p",{staticClass:"text-justify"},[e._v("Listas são úteis em situações em que é necessário processar itens em sequencia, e por isso são chamadas na documentação de. Já vetores são preferíveis quando é necessário acessar posições aleatórias.")]),o("p",{staticClass:"text-justify"},[e._v("Devido à forma como listas e vetores são armazenados internamente, você obtém resultados diferentes ao adicionar um item a uma lista existente. Em uma lista você adiciona um item na primeira posição, enquanto num vetor o item é adicionado sempre no final.")]),o("p",{staticClass:"text-justify"},[e._v("Isso acontece porque uma lista pode ser entendida como uma estrutura de dados chamada de, onde você armazena uma referência para o primeiro item, e cada item armazena a referência para o próximo.")]),o("p",{staticClass:"text-justify"},[e._v("Assim, é bem mais barato armazenar a referência para o item que está sendo adicionado e apontar o próximo item para a referência antiga, colocando o novo item como primeiro da lista.")]),o("p",{staticClass:"text-justify"},[e._v("Na figurapodemos ver a listacomo uma lista ligada, e empodemos entender melhor como um item é adicionado à lista.")]),o("p",{staticClass:"text-justify"},[e._v("Funções comoeaceitam tanto listas como vetores como parâmetros, mas retornam sempre uma sequencia como resultado. Caso você queira outro vetor como resposta, use as funçõese, respectivamente.")]),o("p",{staticClass:"text-justify"},[e._v("Uma fila é uma estrutura de dados onde o primeiro item inserido é o primeiro a ser retirado.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos imaginar a fila do supermercado, onde a pessoa que chegou primeiro é a primeira a ser atendida. Ao ser atendida, a pessoa sai da fila e assim por diante até que a fila fique vazia, ou o supermercado encerre as atividades.")]),o("p",{staticClass:"text-justify"},[e._v("Apesar do Clojure ter uma implementação de fila, até a versão 1.6.0 ainda não estava disponível um conjunto de funções que nos permita criar essa estrutura de forma idiomática.")]),o("p",{staticClass:"text-justify"},[e._v("Felizmente, como já pudemos ver, Clojure e Java se conversam bem, então podemos usar a própria classe Java que implementa a fila do Clojure dentro do nosso código.")]),o("p",{staticClass:"text-justify"},[e._v("Para criarmos uma fila vazia, basta usarmos a classe Java, que já nos oferece uma instância de uma fila vazia, chamada.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos guardar essa fila numchamado:")]),o("p",{staticClass:"text-justify"},[e._v("Usamos a funçãopara mostrar que a fila está vazia. Essa função retornasempre que uma coleção vazia qualquer for passada como parâmetro.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos adicionar o valorna fila, de acordo com a figura. Como estamos lidando com uma estrutura imutável, ao adicionarmos um item em uma fila teremos outra fila. Vamos salvar essa fila nova em. Vamos usar a função, que é a mesma que já utilizamos para adicionar itens em listas e vetores.")]),o("p",{staticClass:"text-justify"},[e._v("A função, nossa conhecida de outras coleções, nos retorna a quantidade de itens contidos na fila. Já a funçãonos mostra quem é o primeiro item da fila. Como a fila é imutável, é necessário termos uma função que pegue o primeiro item da fila e outra que nos retorne a fila sem esse primeiro elemento.")]),o("p",{staticClass:"text-justify"},[e._v("Sem muita pressa, vamos adicionar dois itens de uma vez na nossa fila. Vamos chamar a nova fila de.")]),o("p",{staticClass:"text-justify"},[e._v("Agora a pilha pode ser representada conforme a figura. Perceba que o valorainda é o primeiro da fila, já que foi o primeiro a entrar nela.")]),o("p",{staticClass:"text-justify"},[e._v("Agora vamos retirar o primeiro item da fila e guardar o resultado em.")]),o("p",{staticClass:"text-justify"},[e._v("Para pegarmos o primeiro item da fila, usamos a nossa conhecida função, mas para devolvermos a função sem esse item, devemos usar a função.")]),o("p",{staticClass:"text-justify"},[e._v("Agora temos a fila da figura, com dois elementos e o valorcomo o primeiro da fila.")]),o("p",{staticClass:"text-justify"},[e._v("No início da explicação foi comentado que. Uma forma idiomática é aquela que está de acordo com o.")]),o("p",{staticClass:"text-justify"},[e._v("A forma idiomática de se criar uma fila em Clojure seria, ao invés de usarmos diretamente uma classe Java para isso, utilizarmos uma função, que podemos escrever facilmente enquanto a biblioteca padrão não nos fornece esse recurso.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos criar uma funçãoque cria essa fila:")]),o("p",{staticClass:"text-justify"},[e._v("Nossa função retorna uma fila vazia. Mas, e se quisermos criar uma fila que já contenha quantos elementos quisermos? Basta adicionar mais uma assinatura à função e usar a funçãopara adicionar os valores passados por parâmetro.")]),o("p",{staticClass:"text-justify"},[e._v("Como podemos receber uma quantidade variável de parâmetros, os valores passados paraficam armazenados no vetor. Para convertermos esse vetor em uma lista de argumentos para a função, usamos a função, passando também uma lista vazia através da própria funçãosem parãmetros.")]),o("p",{staticClass:"text-justify"},[e._v("Para sabermos se um item é ou não uma fila, vamos criar uma função chamada, que simplesmente verifica se o valor informado é uma instância da classe. Para isso, vamos usar a função.")]),o("p",{staticClass:"text-justify"},[e._v("Mesmo quando o Clojure não te oferece algo por padrão, é fácil e rápido fazermos uma adaptação para que possamos trabalhar bem.")]),o("p",{staticClass:"text-justify"},[e._v("Isso acontece com a estrutura de dados conhecida como. O Clojure não nos fornece uma função nativa ou uma classe Java para lidarmos com pilhas, mas podemos adaptar uma lista para termos as mesmas funcionalidades.")]),o("p",{staticClass:"text-justify"},[e._v("Para entendermos uma pilha, podemos pensar em uma pilha de pratos para lavar. O primeiro prato que você colocar na pilha vai ser o último que você vai conseguir tirar. Da mesma forma, o último prato que você colocar, que é aquele que vai estar no topo, é o primeiro a ser retirado.")]),o("p",{staticClass:"text-justify"},[e._v("Para utilizarmos pilhas em Clojure, basta usarmos a nossa já conhecida. Como o último valor adicionado a uma lista fica sempre no começo, temos uma estrutura pronta para fazer o que queremos.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos criar uma lista vazia e chamá-la de, para então adicionar o valor, conforme a figura, armazenando o resultado em.")]),o("p",{staticClass:"text-justify"},[e._v("Usando as mesmas funçõespara adicionar, epara saber qual é o primeiro item, não conseguimos ver ainda nenhum comportamento de pilha.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos então adicionar os valorese, respectivamente, para termos a pilha da figurae entendermos melhor como ela funciona. Vamos chamar a nova pilha de.")]),o("p",{staticClass:"text-justify"},[e._v("Agora o primeiro item da pilha é o valor, que foi justamente o último a ser adicionado.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos agora remover o primeiro item da pilha usando a função, para termos a pilha representada na figura. Vamos armazenar a nova pilha em.")]),o("p",{staticClass:"text-justify"},[e._v("Usandoagora nós vemos que o próximo valor da pilha é. O valor, que foi o primeiro a entrar na pilha, vai ser o último a sair.")]),o("p",{staticClass:"text-justify"},[e._v("Um mapa é uma coleção que relaciona uma chave a um valor. Em outras linguagens você pode encontrar a mesma estrutura com os nomes de.")]),o("p",{staticClass:"text-justify"},[e._v("Clojure oferece duas formas principais de mapas: um, que é o tipo mais comum e por padrão não garante a ordem dos itens, e, que ordena os dados conforme eles são adicionados.")]),o("p",{staticClass:"text-justify"},[e._v("Para criarmos um mapa, podemos utilizar os caractereseentre os pares de valores, sendo que o primeiro item do par é a chave, e o segundo é o valor.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos voltar ao nosso mapa com os nomes dos estados:")]),o("p",{staticClass:"text-justify"},[e._v("Os,,esão as chaves e os nomes dos estados são os valores.")]),o("p",{staticClass:"text-justify"},[e._v("Para acessá-los, basta você informar o mapa e a respectiva chave.")]),o("p",{staticClass:"text-justify"},[e._v("Ou a chave e o respectivo mapa, nessa ordem, uma vez que umpode ser tratado como uma função. Lembra que comentamos isso lá no começo, ao apresentarmos o tipo?")]),o("p",{staticClass:"text-justify"},[e._v("Olhando assim, tanto faz uma forma como outra. Mas, e se ao invés de um mapa todo certinho e preenchido, como é o caso de, recebermos um valor nulo?")]),o("p",{staticClass:"text-justify"},[e._v("Ao tentar acessarcomo um mapa, nós vamos receber o famigerado, e provavelmente vamos derrubar nossa aplicação.")]),o("p",{staticClass:"text-justify"},[e._v("Para resolver isso, basta trocarmos a ordem, usando odo mapa. É aí que começa a fazer sentido umser tratado como função, e é por isso também que eu disse antes que é uma boa prática:")]),o("p",{staticClass:"text-justify"},[e._v("Essa segunda forma também auxilia muito ao acessarmos mapas dentro de mapas. Vamos imaginar que alguma função tenha convertido um arquivovindo de um sistema comercial em um mapa Clojure para podermos trabalhar melhor.")]),o("p",{staticClass:"text-justify"},[e._v("O nossooriginal teria essa estrutura:")]),o("p",{staticClass:"text-justify"},[e._v("Que convertido para um mapa Clojure ficaria com a seguinte estrutura:")]),o("p",{staticClass:"text-justify"},[e._v("Agora precisamos exibir um texto contendo a descrição do produto que foi comprado.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos usar a forma comum, com o mapa antes da chave:")]),o("p",{staticClass:"text-justify"},[e._v("Ou podemos usar a forma em que a chave vem antes do mapa:")]),o("p",{staticClass:"text-justify"},[e._v("Vamos usar o que aprendemos até agora sobre mapas,e funções e vamos deixar essa expressão ainda mais simples e legível:")]),o("p",{staticClass:"text-justify"},[e._v("Comotambém são reconhecidos pelo compilados como funções, podemos usá-los sem problema algum com os.")]),o("p",{staticClass:"text-justify"},[e._v("A chave de um mapa pode ser qualquer valor válido em Clojure, e não apenas um.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos usar um número como chave:")]),o("p",{staticClass:"text-justify"},[e._v("Podemos usar um texto, ou qualquer outro valor que quisermos:")]),o("p",{staticClass:"text-justify"},[e._v("Foi dito anteriormente que mapas, por padrão, não garantem a ordem dos itens. Isso acontece por conta da forma como os mapas são implementados internamente.")]),o("p",{staticClass:"text-justify"},[e._v("Ao criar um mapa vazio usando, estamos criando um. Essa forma de mapa é recomendada para pequenas quantidades de dados, já que mantem a ordem dos itens no momento de sua criação, mas aumenta o tempo de acesso a cada um deles conforme você vai avançando para o final da coleção.")]),o("p",{staticClass:"text-justify"},[e._v("A partir de um certo tamanho, que varia de acordo com a implementação, é recomendado trabalhar com, que já é otimizado para quantidades maiores de informação, mas não garante a ordem dos elementos.")]),o("p",{staticClass:"text-justify"},[e._v("As três formas,,ecriam um mapa. Internamente podemos perceber que as duas últimas formas armazenam os valores de formas diferentes.")]),o("p",{staticClass:"text-justify"},[e._v("Qual formas devemos utilizar então?")]),o("p",{staticClass:"text-justify"},[e._v("Quando você cria a formapara criar um mapa, o próprio Clojure seleciona a melhor estrutura de acordo com a quantidade de itens. O mesmo acontece com as funções que manipulam mapas, e é onde não podemos confiar que o mapa terá a ordem dos valores mantida.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos criar um mapa usando, que manteve a ordem dos itens no nosso exemplo. Em seguida vamos usar a funçãopara criar um novo mapa com dois novos itens que queremos adicionar.")]),o("p",{staticClass:"text-justify"},[e._v("Note que a ordem do novo mapa já começa a ficar bagunçada. O fato de termos escolhido a funçãonão significa que os novos mapas que criarmos vão manter a ordem.")]),o("p",{staticClass:"text-justify"},[e._v("Caso a ordem seja realmente importante, você deve criar o mapa usando a função.")]),o("p",{staticClass:"text-justify"},[e._v("Agora podemos adicionar quantos itens quisermos e o mapa estará sempre ordenado.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos bagunçar um pouco mais e criar um mapa que esteja ordenado de forma decrescente. Para isso vamos usar, que recebe uma função como primeiro parâmetros e os itens do mapa em seguida.")]),o("p",{staticClass:"text-justify"},[e._v("A nossa função vai comparar as chaves usando a função da biblioteca padrão chamada. Essa função retornase o segundo item for maior que o primeiro,se o primeiro for maior que o segundo ese os itens forem iguais.")]),o("p",{staticClass:"text-justify"},[e._v("Como queremos inverter o funcionamento da função, vamos multiplicar o resultado porem nossa função.")]),o("p",{staticClass:"text-justify"},[e._v("Agora passamoscomo parâmetro parae eis o nosso mapa ordenado decrescente.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos adicionar quantos itens quisermos no nosso novo mapa e a ordem será mantida.")]),o("p",{staticClass:"text-justify"},[e._v("Quando manipulamos mapas, tanto faz se são ordenados ou não. As funções que tratam de um tipo também tratam de outro, tornando mais fácil memorizar ou pesquisar aquela que precisamos.")]),o("p",{staticClass:"text-justify"},[e._v("O nosso já conhecidotambém tem utilidade aqui. Como acontece com as demais coleção, essa função junta um mapa com outro, retornando um terceiro.")]),o("p",{staticClass:"text-justify"},[e._v("A diferença para a função, que conhecemos há pouco, é quejunta um mapa com outro, enquantoassocia um mapa a um ou mais pares de chave e valor.")]),o("p",{staticClass:"text-justify"},[e._v("É mais comum usarmos a funçãodo que a funçãopara unirmos dois mapas. Internamente a funçãousa, o que acaba nos dando o mesmo resultado. Isso acontece porque o termoé normalmente usado quando combinamos um conjunto de coisas com outro para formarmos um terceiro conjunto.")]),o("p",{staticClass:"text-justify"},[e._v("Se os dois mapas tiverem algum item com a mesma chave, será escolhido o item do mapa da direita.")]),o("p",{staticClass:"text-justify"},[e._v("É comum em Clojure termos duas funções que fazem praticamente a mesma coisa. Enquanto isso pode parecer desperdício ou redundância, acaba sendo uma forma de tornar o código mais expressivo e fácil de ler. Vamos ter outro exemplo disso mais adiante, ao estudarmos.")]),o("p",{staticClass:"text-justify"},[e._v("A funçãotem ainda uma irmã, chamadaque, além do mapa original, recebe também uma função como parâmetro e finalmente os dados a serem combinados ao mapa original.")]),o("p",{staticClass:"text-justify"},[e._v("Ao invés de simplesmente substituir o valor atual pelo valor novo, a funçãoaplica a função para os valores que tiverem a mesma chave.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos aplicar os nossos mapas verduras e raizes, concatenando os textos contidos nas chaves repetidas.")]),o("p",{staticClass:"text-justify"},[e._v("Acho quenão fica legal. Podemos então escrever uma função que adicione vírgulas entre as palavras, para deixarmos o resultado mais legível.")]),o("p",{staticClass:"text-justify"},[e._v("Ficou bem melhor agora, certo?")]),o("p",{staticClass:"text-justify"},[e._v("Podemos também usarpara agregar resultados de inúmeros mapas em um único.")]),o("p",{staticClass:"text-justify"},[e._v("Considere que, passada a primeira fase de um campeonato de futebol você tenha a quantidade de gols que cada time marcou. Porém, como cada jogo acontece independente do outro, você terá um mapa para cada jogo, onde o time é a chave, e a quantidade de gols é o valor.")]),o("p",{staticClass:"text-justify"},[e._v("Como os jogos estão dentro de um vetor, vamos usar a nossa conhecida funçãopara transformá-lo em uma lista de parâmetros para. A funçãovai somar as quantidades de gols de cada time por jogo e pronto, temos o total de gols de cada um.")]),o("p",{staticClass:"text-justify"},[e._v("Agora sabemos que o Brasil marcou sete gols, enquanto Camarões marcou apenas um.")]),o("p",{staticClass:"text-justify"},[e._v("Se quisermos remover um item do mapa, usaremos o oposto de, que é a função. Enquanto uma, a outra.")]),o("p",{staticClass:"text-justify"},[e._v("Como já foi dito, um mapa é uma coleção que relaciona chaves com seus respectivos valores, sendo um valor para cada chave.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos retornar sequencias contendo todas as chaves e também contendo todos os valores.")]),o("p",{staticClass:"text-justify"},[e._v("Para extrairmos as chaves, vamos usar a função, informando o mapa como parâmetro.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos extrair a lista de times que participaram do campeonato que citamos, usando a funçãoe o nosso mapa, que contém a quantidade de gols marcados por cada time.")]),o("p",{staticClass:"text-justify"},[e._v("Agora vamos somar a quantidade de gols que tivemos naquela fase do campeonato extraindo os valores do mapaatravés da função.")]),o("p",{staticClass:"text-justify"},[e._v("Finalmente, vamos brincar um pouco com o que aprendemos, calculando a média de gols por partida. Para isso vamos somar a quantidade total de gols marcados e então dividir pela quantidade de jogos.")]),o("p",{staticClass:"text-justify"},[e._v("E eis que tivemos uma média de três gols por partida.")]),o("p",{staticClass:"text-justify"},[e._v("A operação oposta, de criarmos um mapa através de duas coleções, uma de chaves e outra de valores, também é possível se utilizarmos a função.")]),o("p",{staticClass:"text-justify"},[e._v("Como exemplo, vamos sortear uma cor para cada participante de um jogo de tabuleiros. Existem quatro cores e cinco amigos para jogar, mas um deles terá que ficar de fora.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos usar a funçãopara embaralhar as listas de cores e de amigos, fazendo com que o sorteio seja realmente imprevisível.")]),o("p",{staticClass:"text-justify"},[e._v("Agora vamos usarpara associarmos cada cor a um jogador. Como são quatro cores para cinco amigos, o último vai ficar só assistindo.")]),o("p",{staticClass:"text-justify"},[e._v("E José vai esperar a próxima rodada para poder jogar.")]),o("p",{staticClass:"text-justify"},[e._v("Umé uma coleção de valores únicos. Podemos visualizar melhor o que é umse lembrarmos das aulas de teorias dos conjuntos. Cadaseria um conjunto, e temos à nossa disposição boa parte das operações matemáticas que usamos com conjuntos.")]),o("p",{staticClass:"text-justify"},[e._v("Como este não é um livro de matemática ou de teoria dos conjuntos, não vamos cobrir todas essas operações, mas usaremos o assunto como analogia sempre que necessário.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos criar umusando a função, passando uma sequencia ou um vetor como argumento, ou delimitando os itens entre os caracteres.")]),o("p",{staticClass:"text-justify"},[e._v("Umé usado normalmente para verificar se um determinado item pertence a um conjunto. Aproveitando os exemplos acima, podemos usar a nossa já conhecida técnica de verificar se um caracter é uma vogal.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos fazer isso usando a função, que vai retornarou, ou usando umcomo se fosse uma função, que vai retornar o próprio valor pesquisado caso ele pertença ao conjunto oucaso ele não pertença.")]),o("p",{staticClass:"text-justify"},[e._v("As funçõesetambém funcionam com.")]),o("p",{staticClass:"text-justify"},[e._v("Para criarmos uma partir de uma lista de argumentos, podemos usar as funçõese.")]),o("p",{staticClass:"text-justify"},[e._v("Da mesma maneira que acontece com os mapas, umnão garante a ordem dos elementos, mas é otimizado para encontrar rapidamente qualquer elemento.")]),o("p",{staticClass:"text-justify"},[e._v("Também como já vimos com os mapas, é possível criar uma função para ordenar ode acordo com as nossas necessidades.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos criar uma função chamadapara podemos ordenar oem ordem descrescente e depois criar umordenado através da função.")]),o("p",{staticClass:"text-justify"},[e._v("Existe umapenas para lidar com. Com ele temos acesso a funções Clojure que reproduzem algumas operações da Teoria dos Conjuntos.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos criar dois conjuntos e vamos chamá-los dee. Através depodemos exibir graficamente os conjuntos e suas respectivas interações.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos declarar nossos conjuntos, conforme a figura, usandopara fazermos o paralelo com código Clojure.")]),o("p",{staticClass:"text-justify"},[e._v("A união de dois grupos acontece quando juntamos todos os elementos decom todos os elementos de, mantendo apenas uma ocorrência do elemento caso haja repetição, como ocorre na figura. Para isso podemos usar a função.")]),o("p",{staticClass:"text-justify"},[e._v("Já na intersecção só mantemos os elementos em comum entre os conjuntose, como podemos ver na figura. A funçãofaz esse trabalho.")]),o("p",{staticClass:"text-justify"},[e._v("Já na diferença entreevocê remove todos os itens deque pertençam a, como podemos ver na figura. Para isso usamos a função.")]),o("p",{staticClass:"text-justify"},[e._v("É importante perceber que a funçãonão é comutativa. Isso significa que a diferença entreeé diferente da diferença entree, como podemos ver na figura.")]),o("p",{staticClass:"text-justify"},[e._v("É possível também utilizar as operações dee, além de saber se um elemento pertence ou não ao. A diferença entre estar contido e pertencer, é que, enquanto.")]),o("p",{staticClass:"text-justify"},[e._v("Para saber se um elemento pertence a um grupo, usamos a função, como já vimos no início da explicação sobre. Já para ver se um conjunto está contido em outro, usamos a função.")]),o("p",{staticClass:"text-justify"},[e._v("Olhando a figura, podemos perceber que.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos representar isso usando Clojure da seguinte forma:")]),o("p",{staticClass:"text-justify"},[e._v("Pela mesma figura podemos ver que.")]),o("p",{staticClass:"text-justify"},[e._v("Já a funçãofaz o oposto, verificando se.")]),o("p",{staticClass:"text-justify"},[e._v("Sabendo que, podemos afirmar que, e podemos afirmar também quenão o contém.")]),o("p",{staticClass:"text-justify"},[e._v("As estruturas persistentes são excelentes para lidarmos com ambientes com várias threads e para manter a consistência das informações mas, em casos em que a velocidade é importante, podemos fazer uma concessão e utilizar estruturas mutáveis para tornar o processamento mais rápido.")]),o("p",{staticClass:"text-justify"},[e._v("É aí que entram as, que permite que você modifique valores dentro da própria estrutura, sem a necessidade de criar uma nova para cada modificação.")]),o("p",{staticClass:"text-justify"},[e._v("Para manter as coisas organizadas, uma estrutura transiente é obrigada a trabalhar em uma única thread, evitando todos os problemas relacionados a mutabilidade eque temos de sobra no Java e nas demais linguagens imperativas.")]),o("p",{staticClass:"text-justify"},[e._v("O uso é bem simples. Primeiro pegamos uma estrutura persistente qualquer e a convertemos em transiente através da função, manipulamos da maneira que bem entendermos e criamos uma estrutura persistente através da função. Perceba o ponto de exclamação no final do nome da função. Isso indica que a função ou macro causa algum tipo de efeito colateral e deve ser usada com atenção.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos apresentar um exemplo bem simples criando uma função que recebe um número e retorna um vetor contendo todos os valores inteiros entree o número informado.")]),o("p",{staticClass:"text-justify"},[e._v("Usando o que já sabemos sobree, vamos escrever a função desta maneira:")]),o("p",{staticClass:"text-justify"},[e._v("Os números de linha foram adicionados para facilitar a explicação e para entendermos melhor onde o código vai precisar ser alterado.")]),o("p",{staticClass:"text-justify"},[e._v("Criamos um vetor vazio chamado, e um contador que vai deaté. No meio do laço, verificamos seé maior que, retornandocom os números ou então adicionando o valor seguinte a um novo vetor, repetindo a operação.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos agora usar a função. Vamos roubar um pouco no resultado e usar a formapara que onão exiba os milhões de números contidos na lista.")]),o("p",{staticClass:"text-justify"},[e._v("A formapermite que executemos uma série de instruções, retornando o resultado da última. Vamos retornarcomo última expressão e assim resumimos em muito o que vai ser apresentado na tela.")]),o("p",{staticClass:"text-justify"},[e._v("Na máquina que estou usando enquanto escrevo o livro o processo levou quase nove segundos.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos ver agora o que podemos melhorar usando uma estrutura transiente.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos alterar um pouco o código para poder usar uma estrutura transiente. Perceba que a aparência do código é a mesma, não perdendo a clareza.")]),o("p",{staticClass:"text-justify"},[e._v("Na linha 2 nós vamos atribuir um vetor vazio transiente para, ao invés de um vetor persistente do código original. Na linha 6 nós vamos utilizar a função, que altera o próprio vetor ao invés de retornar um novo. Isso só é possível com estruturas transientes, que não são imutáveis.")]),o("p",{staticClass:"text-justify"},[e._v("Finalmente, para retornarmos o vetor, utilizamos a função, que cria uma estrutura persistente com o conteúdo de.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos executar agora o código usando, para medirmos o tempo gasto para retornar o vetor com os números. Note que externamente a função parece igual mas, usando mutabilidade de maneira controlada, tivemos um grande ganho de desempenho.")]),o("p",{staticClass:"text-justify"},[e._v("Agora tivemos o mesmo resultado em menos de um décimo do tempo.")]),o("p",{staticClass:"text-justify"},[e._v("Existem duas formas de evitar que informações sejam corrompidos ou alterados indevidamente em um ambiente com que várias.")]),o("p",{staticClass:"text-justify"},[e._v("A primeira forma é fazer com que a informação não possa ser alterada, e isso o Clojure já faz por padrão.")]),o("p",{staticClass:"text-justify"},[e._v("A segunda forma é permitir que a informação seja alterada, como acontece com as estruturas transientes, mas impedir que mais de umapossa modificá-la. E os criadores do Clojure tiveram o cuidado de fazer as duas coisas.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos criar uma função chamada, que simplesmente retorna o nome daatual.")]),o("p",{staticClass:"text-justify"},[e._v("Essa função executa o método estáticoda classe, que retorna um objeto. Então pegamos esse objeto e acessamos o método. Veremos nos próximos capítulos como acessar objetos Java dentro do Clojure em detalhes, mas por enquanto é suficiente saber que o código acima faz o mesmo queem Java.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos criar um vetor transiente chamadoe adicionar o nome daatual texto, para sabermos onde foi feita a alteração;")]),o("p",{staticClass:"text-justify"},[e._v("Agora vamos criar uma função chamada, que vai modificaradicionando ao vetor o nome daatual. Perceba o ponto de exclamação no nome da função, para deixarmos claro de que causaremos um efeito colateral em sua execução.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos executar a funçãopara ver se tudo corre bem.")]),o("p",{staticClass:"text-justify"},[e._v("Aqui usamos um pouco de magia negra para termos certeza do que aconteceu. Como uma estrutura transiente não oferece meios limpos de lermos o seu conteúdo, utilizamos o métodoque está dentro da classe, tratanto a estrutura como um objeto Java. É feio, mas serve ao nosso propósito educativo.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos ver que tanto a primeira posição quanto aatual retornam o texto. O nome pode variar de acordo com o momento em que você estiver utilizando oou a quantidade de sessões doque você já abriu.")]),o("p",{staticClass:"text-justify"},[e._v("Agora sabemos que nossa funçãofunciona, vamos à parte realmente interessante, que é ver como o Clojure se comporta ao tentarmos misturar mutabilidade e diferentes.")]),o("p",{staticClass:"text-justify"},[e._v("Você ainda não sabia, mas toda função Clojure pode ser passada para umapara que possa ser executada em paralelo. Relaxe, pois veremos isso em detalhes em um capítulo específico. O que você precisa saber agora é que pode jogar uma função numae fica tudo bem.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos criar umausando novamente a classe Java, e então invocaremos o métododo objeto que tivermos em mãos. Nosso código vai ficar com essa cara:")]),o("p",{staticClass:"text-justify"},[e._v("Esse código Clojure é equivalente ao código Java abaixo:")]),o("p",{staticClass:"text-justify"},[e._v("Em Clojure fica bem mais bonito, não?")]),o("p",{staticClass:"text-justify"},[e._v("Voltando ao nosso código, ao tentarmos executardentro de outra, o Clojure vai puxar nossa orelha.")]),o("p",{staticClass:"text-justify"},[e._v("Mesmo que você tente fazer algo errado, o Clojure toma os cuidados possíveis para que as coisas continuem na linha.")]),o("p",{staticClass:"text-justify"},[e._v(", ou metadados são. Clojure permite que você adicione informações adicionais a, símbolos, coleções,,,,ou qualquer classe Java que implemente a interface. Numa comparação bem rasa, uma anotação do Java ou do C# é uma forma de de utilizarmos metadados, visto que a classe, método ou membro anotado passa a levar uma informação que não afeta diretamente o uso daquele código.")]),o("p",{staticClass:"text-justify"},[e._v("Esses metadados são utilizados pelo compilador, por ferramentas que analizam o código ou por funções e macros que auxiliam a utilização do, como as nossas conhecidase.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos adicionar metadados a uma lista usando a função, que recebe como parâmetros o valor e um mapa contendo os metadados:")]),o("p",{staticClass:"text-justify"},[e._v("Para acessarmos os metadados que acabamos de adicionar a, usamos a função.")]),o("p",{staticClass:"text-justify"},[e._v("Os metadados ficam guardados em um mapa, e podemos acessá-los como um mapa qualquer. Vamos exibir apenas a descrição:")]),o("p",{staticClass:"text-justify"},[e._v("Agora sabemos que podemos adicionar qualquer informação que acharmos relevante a uma lista ou qualquer outra coleção do Clojure, e já sabíamos que a macrobusca o texto explicativo das funções em seus respectivos metadados.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos experimentar extrair por conta própria a documentação da função. Escolhemos essa função aleatóriamente. Você pode tentar com qualquer outra que pertença à biblioteca padrão do Clojure.")]),o("p",{staticClass:"text-justify"},[e._v("Primeiro vamos exibir a documentação, para termos uma noção do que esperamos encontrar. Em seguida vamos acessar os metadados usando a funçãopara começarmos a vasculhar as informações que queremos.")]),o("p",{staticClass:"text-justify"},[e._v("Enquantoretornou um texto explicativo, a funçãoretornou apenas. O que fizemos de errado?")]),o("p",{staticClass:"text-justify"},[e._v("Vamos olhar como a função foi declarada para entendermos exatamente o que acontece. Vou adicionar novamente números de linhas para poder explicar todo o processo.")]),o("p",{staticClass:"text-justify"},[e._v("As linhaseforam quebradas para poderem caber na página do livro, mas isso não vai afetar a explicação. O código fonte, que fica entre as linhase, foi removido para mantermos o foco no que é importante para explicação.")]),o("p",{staticClass:"text-justify"},[e._v("Podemos ver que entre as linhaseestão sendo declarados o texto da documentação e mais duas informações em forma de mapa. Internamente isso vai ser adicionado aos metadados da função, também usando a função.")]),o("p",{staticClass:"text-justify"},[e._v("Mas, se internamente o Clojure também usa, como fizemos no exemplo, por que ao usarmosnão encontramos nada?")]),o("p",{staticClass:"text-justify"},[e._v("Primeiro precisamos entender como a linguagem trabalha com o código por baixo dos panos.")]),o("p",{staticClass:"text-justify"},[e._v("Em Clojure, como na maioria das linguagens, temos dois momentos distintos na execução de um programa: um chamadoe outro chamado.")]),o("p",{staticClass:"text-justify"},[e._v("No chamado, o código Clojure é lido, interpretado e as macros são expandidas. Veremos esse passo com detalhes num capítulo todinho sobre macros.")]),o("p",{staticClass:"text-justify"},[e._v("Nesse período deosdeclarados pelo operadorsão criados e o código que está dentro das macros é executado.")]),o("p",{staticClass:"text-justify"},[e._v("Em seguida, em, o conteúdo das funções e expressões que serão atribuídas aosserão executados.")]),o("p",{staticClass:"text-justify"},[e._v("Para fixar melhor como funciona, pense que emé criada a panela, emé feita a comida. Escrever com fome causa essas coisas.")]),o("p",{staticClass:"text-justify"},[e._v("Quando executamosno, estamos criando metadados em tempo de execução, já que estamos avaliando uma expressão. Com isso associamos o metadado à lista que foi criada. Se você passar essa lista como parâmetro para alguma função, o metadado vai junto.")]),o("p",{staticClass:"text-justify"},[e._v("Para demonstrar isso, vamos criar uma função chamadaque vai procurar dentro dos metadados do valor a chaveque adicionamos no exemplo anterior.")]),o("p",{staticClass:"text-justify"},[e._v("Como relembrar é viver, e ficar voltando página no livro é muito chato, vamos criar novamente a lista com a respectiva descrição.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos juntar as partes.")]),o("p",{staticClass:"text-justify"},[e._v("Nesse caso,. Como o valor foi passado por parâmetro, o metadado foi junto.")]),o("p",{staticClass:"text-justify"},[e._v("Quando atribuimos o metadado em, o valor ainda não foi criado. Fica óbvio se você pensar que o valor só existirá quando a aplicação estiver sendo executada, ou seja, em.")]),o("p",{staticClass:"text-justify"},[e._v("Como o valor ainda não foi criado, o metadado é atribuido aoque vai armazená-lo. Lembre-se que oé criado em tempo de compilação.")]),o("p",{staticClass:"text-justify"},[e._v("Quando tentamos acessar os metadados de, estamos acessando o valor contido no, que é uma função. Esse valor, de fato, não tem metadado nenhum, e é onde recebemoscomo resposta.")]),o("p",{staticClass:"text-justify"},[e._v("Se quisermos acessar diretamente o, ao invés de acessarmos a função, precisamos utilizar a forma especial, que funciona de forma bem parecida com a funçãoque já conhecemos.")]),o("p",{staticClass:"text-justify"},[e._v("A formanos retornou o nome completo da função, incluindo oem que a função foi declarada.")]),o("p",{staticClass:"text-justify"},[e._v("Perceba que o retorno contém também os caracteresantes do nome completo da função. Esses dois caracteres são, ou atalhos da linguagem que são executados em tempo de compilação. Internamente avai ser substituido pore executado durante a compilação do código.")]),o("p",{staticClass:"text-justify"},[e._v("Usando a nossa recém apresentada forma, vamos tentar acessar novamente os metadados de.")]),o("p",{staticClass:"text-justify"},[e._v("Veja que agora conseguimos acessar os metadados de, que estão associados ao, e não ao corpo da função propriamente dita. Sendo assim, se passarmoscomo parâmetro para uma função, os metadados não irão junto.")]),o("p",{staticClass:"text-justify"},[e._v("Agora sim conseguimos extrair a documentação de.")]),o("p",{staticClass:"text-justify"},[e._v("Lembra quando foi dito quesão executadas eme funções são executadas em? Poissão tipos especias de macros e, como tal, são executadas durante a compilação.")]),o("p",{staticClass:"text-justify"},[e._v("Estou repetindo isso para poder deixar claro dois conceitos importantes aqui, antes de irmos para o próximo passo. Saber diferenciar quando seu código será executado em tempo de compilação ou de execução é importante. Saber que existemtambém vai tornar o conceito mais fácil de entender.")]),o("p",{staticClass:"text-justify"},[e._v("Assim como existe umque nos permite acessar diretamente um, também existe um que adiciona metadados em tempo de compilação.")]),o("p",{staticClass:"text-justify"},[e._v("O nossoda vez é o, que vai conter o mapa de metadados na declaração do.")]),o("p",{staticClass:"text-justify"},[e._v("Note que ao utilizar, os metadados foram informados antes do nome do.")]),o("p",{staticClass:"text-justify"},[e._v("Agora os metadados estão associados aoao invés do valor. Perceba que o próprio Clojure adiciona metadados que são utilizados para indicar onde ocorreu um erro ou por ferramentas de análise de código.")]),o("p",{staticClass:"text-justify"},[e._v("Se olharmos novamente os metadados de, veremos duas informações interessantes:e.")]),o("p",{staticClass:"text-justify"},[e._v("De acordo com os metadados, o código fonte da funçãoestá no arquivoe começa na linha.")]),o("p",{staticClass:"text-justify"},[e._v("Ao acessarmos http://git.io/rGpXXw, que vai nos direcionar para o código fonte da biblioteca padrão do Clojure, veremos que, a partir da linhado arquivotemos a função.")]),o("p",{staticClass:"text-justify"},[e._v("Note que é exatamente o mesmo conteúdo que teríamos ao usar, já que é assim que a macro faz para encontrar o código fonte.")]),o("p",{staticClass:"text-justify"},[e._v("Caso você esteja usando uma versão do Clojure diferente da versão do livro, o número da linha pode variar. Basta localizar os fontes da versão que você estiver usando e você vai ver o mesmo resultado.")]),o("p",{staticClass:"text-justify"},[e._v("E o que acontece se informarmos os metadados após o nome do?")]),o("p",{staticClass:"text-justify"},[e._v("Nada. Até a versão utilizada nesse livro, os metadados são simplesmente ignorados. Então, se você tentar adicionar metadados a ume nada acontecer, verifique se você não inverteu a ordem.")]),o("p",{staticClass:"text-justify"},[e._v("É possível também alterar os metadados já existentes. Isso pode ser útil caso você desenvolva alguma ferramenta de análise de código, por exemplo. Você poderia marcar os dados já observados com um metadado específico.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos alterar uma função da biblioteca padrão do Clojure, por exemplo.")]),o("p",{staticClass:"text-justify"},[e._v("Para usarmos a funçãoprecisamos informar oa ser alterado e uma função que vai alterar oque contém os metadados. Entãoretorna os metadados alterados.")]),o("p",{staticClass:"text-justify"},[e._v("Já para desfazer uma modificação nos metadados ou mesmo para limpar qualquer metadado existe, devemos usar a função, que recebe como argumentos oa ser modificado e umcontendo os valores pelos quais você vai substituir o mapa de metadados atual.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos alterar os metadados deno nosso exemplo.")]),o("p",{staticClass:"text-justify"},[e._v("Nenhuma função ou estrutura de dados fica solta no Clojure. Toda vez que você cria um, uma função ou uma estrutura de dados global, ou referencia uma biblioteca ou pacote externo, você tem que lidar com. E é isso que veremos em detalhes no próximo capítulo.")])],1)},Ra=[],ka={name:"CHANGEME"},Ta=ka,Ia=Object(l["a"])(Ta,La,Ra,!1,null,null,null),Ua=Ia.exports,Da=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("page",[o("div",{staticClass:"col-sm text-clojure-dark-blue"},[o("h1",[e._v("Dedicatória")]),o("chapter-quote",{attrs:{author:"Plínio Balduino"}},[e._v('\n        "Aos meus filhos: Gu, Duda e Mari.'),o("br"),e._v('\n        Meu esforço é sempre por vocês."\n    ')])],1)])},Ma=[],Ba={name:"Dedication"},Fa=Ba,$a=Object(l["a"])(Fa,Da,Ma,!1,null,null,null),Qa=$a.exports,Ga=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("page",[o("h1",[e._v("Prefácio")]),o("p",{staticClass:"text-justify"},[e._v("\n  Plínio vem em boa hora trazer luz ao mundo LISP no Brasil. Ele queria\n  ter encontrado tamanha sutileza na introdução a Clojure como esta que\n  você tem em suas mãos. Confesso que eu também.\n  ")]),o("p",{staticClass:"text-justify"},[e._v("\n  Tempos difíceis lá em 2009, quando os forasteiros da programação funcional\n  e do LISP na JVM contavam apenas com o site oficial da linguagem para\n  o aprendizado. E depois de muita, mas muita luta para aprender, aquele\n  mesmo site era tudo o que se tinha para tentar convencer chefes e colegas\n  de que Clojure era uma boa chave de fenda para a sua caixa de ferramentas.\n  Na verdade mesmo depois de anos estudando, escrevendo e evangelizando\n  Clojure, eu mesmo enfrentava dificuldade de mostrar às pessoas o quão\n  valorosa ela é.\n  ")]),o("p",{staticClass:"text-justify"},[e._v("\n  Pois bem. Ao saber que Plínio, figura barbuda e conhecida na comunidade,\n  iria escrever sobre Clojure, muito me animei. Primeiro por que era um\n  livro brasileiro de Clojure, por si só isto é excepcional! Segundo por\n  que ele poderia facilmente repetir o sucesso de outras publicações suas.\n  E este cidadão me supera as expectativas com um conteúdo na quantidade,\n  profundidade e disposição que parece ter sido precisamente calculado para\n  capturar o seu e o meu cérebro com as mãos e colocá-los no mesmo patamar\n  de conhecimento a respeito da linguagem.\n  ")]),o("p",{staticClass:"text-justify"},[e._v("\n  Aqui está o "),o("i",[e._v("baseline")]),e._v(", o "),o("i",[e._v("must have")]),e._v(", o "),o("i",[e._v("mindset")]),e._v(" Clojure.\n  Uma espécie de atmosfera que agora você pode circular tranquilamente.\n  É como se tudo começasse agora, muito mais claro e fluido. Esse Plínio\n  fez, sem tornar a comparação Clojure vs. Java a sua bandeira, o que com\n  muita frequencia só se consegue erguendo-a bem lá no alto: Ensinar\n  Clojure e trazer todos para um mesmo ponto de partida. E alcançar a\n  linha de chegada só depende de mim e de você, quando teremos Clojure\n  sendo usada no dia-a-dia de muitos projetos, da concepção à entrega.\n  ")]),o("p",{staticClass:"text-justify"},[o("i",[o("b",[e._v("Paulo Suzart")]),e._v(", Engineering Manager na Omio Berlin e pioneiro do Clojure no Brasil")]),e._v(".\n  ")])])},Ha=[],Wa={name:"Foreword"},Xa=Wa,Ka=Object(l["a"])(Xa,Ga,Ha,!1,null,null,null),Ya=Ka.exports,Za=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("page",[o("wip"),o("h1",[e._v("4. Descobrindo o poder das funções")]),o("label",{attrs:{entry:"capitulo-funcoes"}}),o("chapter-quote",{attrs:{author:"Alan Perlis",work:", primeiro ganhador do Turing Award"}},[e._v("É melhor termos 100 funções operando em uma estrutura de dados do que 10 funções operando em dez estruturas")]),o("h2",[e._v("4.1. O que são funções")]),o("p",{staticClass:"text-justify"},[e._v("Na Matemática, "),o("i",[e._v("uma função é uma relação entre dois conjuntos, onde há uma relação entre cada um de seus elementos")]),o("bib",{attrs:{entry:"conceito-funcao"}}),e._v(". Traduzindo isso para programadores, significa que uma função é uma caixa preta que devolve resultados de acordo com os argumentos, ou parâmetros, passados a ela.")],1),o("index",{attrs:{entry:"programação orientada a objetos"}}),o("p",{staticClass:"text-justify"},[e._v("Para quem está chegando de uma linguagem orientada a objetos, temos classes e objetos como as construções fundamentais. Você pode passar objetos como parâmetros para outros objetos, pode ter objetos que criam objetos, e pode tratar objetos como valores comuns, guardando-os em variáveis se for necessário. Nesse caso, dizemos que objetos são "),o("i",[e._v("cidadãos de primeira classe")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Uma aplicação criada utilizando Programação Orientada a Objetos é, basicamente, uma rede de pequenos objetos especializados trabalhando juntos para que dados de entrada sejam "),o("i",[e._v("modificados")]),e._v(" até que tenhamos a informação esperada no final.")]),o("index",{attrs:{entry:"programação funcional"}}),o("p",{staticClass:"text-justify"},[e._v("Em uma linguagem funcional, como é o caso do Clojure, as funções são as construções fundamentais. Você pode passar funções por parâmetros para outras funções, escrever funções que retornam funções e também pode tratá-las como valores comuns. Por isso dizemos que funções são cidadãs de primeira classe.")]),o("p",{staticClass:"text-justify"},[e._v("Em uma aplicação desenvolvida de maneira funcional, temos uma série de funções que "),o("i",[e._v("transformam")]),e._v(" os dados de entrada até que tenhamos a informação que queremos.")]),o("box",{attrs:{title:"O coração do Clojure"}},[o("p",{staticClass:"text-justify"},[e._v("Usando um pouco de licença poética, podemos dizer que funções são o coração da linguagem, e esse capítulo é fundamental para que você consiga aproveitar todo o restante do livro.")]),o("p",{staticClass:"text-justify"},[e._v("O conteúdo está recheado de códigos em Clojure e em JavaScript, com um pouquinho de Ruby e Java, e comprovadamente você vai conseguir absorver melhor o conhecimento se tentar digitar os exemplos ao mesmo tempo em que for lendo.")])]),o("h2",[e._v("4.2. Transformando dados")]),o("p",{staticClass:"text-justify"},[e._v("Em Clojure você não modifica dados, mas os transforma. Essa diferença sutil nos força a pensar de uma forma diferente à que estamos acostumados ao resolvermos problemas de forma funcional.")]),o("index",{attrs:{entry:"JavaScript"}}),o("p",{staticClass:"text-justify"},[e._v("Para calcularmos a soma de 1 a 10 em JavaScript, precisamos criar uma iteração usando a instrução "),o("code",[e._v("for")]),e._v(", uma variável de controle que vai guardar o número a ser somado em cada iteração e uma variável contadora, que vai guardar o resultado da soma.")]),o("box",{attrs:{title:"Executando os exemplos"}},[o("p",{staticClass:"text-justify"},[e._v("Para executar os exemplos deste capítulo, utilize o console do Chrome ou do Firebug para os códigos escritos em JavaScript, e o REPL para as instruções escritas em Clojure.")]),o("p",{staticClass:"text-justify"},[e._v("Tanto JavaScript quanto Clojure tem um antepassado em comum, chamado Scheme, o que nos permite usar uma linguagem conhecida para ilustrar os exemplos da linguagem que estamos aprendendo.")])]),o("p",{staticClass:"text-justify"},[e._v("Vamos demonstrar isso usando JavaScript no código a seguir:")]),o("snippet",{attrs:{language:"javascript"}},[e._v('\nvar soma = 0;\n\nfor(var numero = 1; numero < 11; numero++) {\n  soma = soma + numero;\n}\n\nconsole.log("Resultado: ", soma);\n// Resultado:  55\n')]),o("p",{staticClass:"text-justify"},[e._v("Perceba que os valores de "),o("code",[e._v("numero")]),e._v(" e "),o("code",[e._v("soma")]),e._v(" foram modificados pelo menos dez vezes até que tivessemos um resultado final. Pelo fato de seus valores "),o("i",[e._v("variarem")]),e._v(" durante a execução do programa, chamamos essas estruturas de "),o("i",[e._v("variáveis")]),e._v(".")]),o("index",{attrs:{entry:"imutabilidade"}}),o("p",{staticClass:"text-justify"},[e._v("Em Clojure não temos o conceito de "),o("i",[e._v("variável")]),e._v(". Como regra, uma vez que um valor seja atribuido, ele não pode mais ser alterado. Essa característica é chamada de "),o("i",[e._v("imutabilidade")]),e._v(". No decorrer do livro vamos entender as vantagens de fazermos com que as estruturas de dados sejam imutáveis por padrão.")]),o("p",{staticClass:"text-justify"},[e._v("Para que possamos calcular a soma dos números inteiros de 1 a 10 em Clojure, vamos precisar de uma lista com os números de 1 a 10, que vamos "),o("i",[e._v("transformar")]),e._v(" em um número, que será a soma que precisamos.")]),o("index",{attrs:{entry:"range"}}),o("p",{staticClass:"text-justify"},[e._v("Vamos usar a função "),o("code",[e._v("range")]),e._v(", que vem na biblioteca padrão do Clojure, que recebe dois parâmetros e retorna uma lista de números inteiros contidos entre o primeiro parâmetro, inclusive, e o menor inteiro anterior ao segundo parâmetro.")]),o("box",{attrs:{title:"Imutabilidade"}},[o("p",{staticClass:"text-justify"},[e._v("Basicamente, um valor imutável é aquele que não pode ser alterado depois de criado.")]),o("p",{staticClass:"text-justify"},[e._v("Uma estrutura imutável é "),o("i",[e._v("thread-safe")]),e._v(", o que significa que pode ser compartilhada entre diferentes processos sem a necessidade de "),o("i",[e._v("locks")]),e._v(" e outros recursos que rapidamente se tornam complicados de gerenciar.")]),o("p",{staticClass:"text-justify"},[e._v("A imutabilidade também torna a aplicação menos sujeita a erros, já que sabemos exatamente onde o valor é criado e qual seu ciclo de vida, reduzindo efeitos colaterais causado por modificações indesejadas ou inesperadas.")]),o("p",{staticClass:"text-justify"},[e._v("Por fim, você pode usar um valor imutável como chave em um "),o("i",[e._v("hashmap")]),e._v(" sem medo de ver o "),o("i",[e._v("hashcode")]),e._v(" ser alterado durante a execução da aplicação, o que acaba sendo um erro muito comum nas demais linguagens.")])]),o("index",{attrs:{entry:"var"}}),o("index",{attrs:{entry:"def"}}),o("p",{staticClass:"text-justify"},[e._v("Vamos "),o("i",[e._v("atribuir")]),e._v(" essa lista a uma construção chamada "),o("code",[e._v("var")]),e._v(", que é criada com a forma especial "),o("code",[e._v("def")]),e._v(", que podemos entender por enquanto como uma variável global. Em seguida vamos exibir o valor do "),o("i",[e._v("var")]),e._v(" chamado "),o("code",[e._v("numeros")]),e._v(" para que você possa ver que cara tem uma lista em Clojure.")]),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def numeros (range 1 11))\n\nnumeros\n; (1 2 3 4 5 6 7 8 9 10)\n")]),o("index",{attrs:{entry:"reduce"}}),o("p",{staticClass:"text-justify"},[e._v("Agora vamos utilizar a função "),o("code",[e._v("reduce")]),e._v(" para calcularmos a somatória dos itens da lista. Essa função recebe dois parâmetros, sendo o primeiro a função que será aplicada e a segunda a lista que será transformada.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos utilizar a função "),o("code",[e._v("+")]),e._v(" para efetuarmos essa soma e nosso código ficará assim:")]),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(reduce + numeros)\n; 55\n")]),o("index",{attrs:{entry:"+"}}),o("p",{staticClass:"text-justify"},[e._v("O sinal de "),o("code",[e._v("+")]),e._v(" é um nome válido de função, simplificando muito a forma como a linguagem é construída. Imagine que, ao invés de tratarmos os sinais aritméticos como se fosse operadores especiais, podemos tratá-los como se fossem funções comuns. Sendo uma função comum, podemos passá-la por parâmetro para outra função, que no nosso caso é "),o("code",[e._v("reduce")]),e._v(".")]),o("index",{attrs:{entry:"reduce"}}),o("p",{staticClass:"text-justify"},[e._v("A função "),o("code",[e._v("reduce")]),e._v(" pega o primeiro item da lista, "),o("i",[e._v("1")]),e._v(", aplica a função "),o("code",[e._v("+")]),e._v(" com o próximo, "),o("i",[e._v("2")]),e._v(". O resultado, "),o("i",[e._v("3")]),e._v(" é somado ao próximo item da lista, também o número "),o("i",[e._v("3")]),e._v(". O resultado, "),o("i",[e._v("6")]),e._v(" é somado ao próximo item, e assim por diante, até que a lista termine.")]),o("box",{attrs:{title:"Se você conhece Ruby..."}},[o("p",{staticClass:"text-justify"},[e._v("Em Ruby existem os métodos "),o("code",[e._v("inject")]),e._v(" e "),o("code",[e._v("reduce")]),e._v(" para objetos "),o("code",[e._v("Enumerable")]),e._v(" que fazem a mesma coisa que o "),o("code",[e._v("reduce")]),e._v(" do Clojure.")]),o("p",{staticClass:"text-justify"},[e._v("O código em Clojure que apresentamos é o equivalente a "),o("code",[e._v("(1..10).reduce(:+)")]),e._v(" em Ruby.")])]),o("index",{attrs:{entry:"apply"}}),o("p",{staticClass:"text-justify"},[e._v("Você pode usar também a função "),o("code",[e._v("apply")]),e._v(", que também recebe uma função e uma lista como parâmetros, mas transforma todos os itens da lista em argumentos para a função.")]),o("p",{staticClass:"text-justify"},[e._v("Nesse caso, escreveríamos "),o("code",[e._v("(apply + numeros)")]),e._v(", que internamente será transformado em "),o("code",[e._v("(+ 1 2 3 4 5 6 7 8 9 10)")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Apesar de "),o("code",[e._v("reduce")]),e._v(" e "),o("code",[e._v("apply")]),e._v(" serem funções que fazem coisas diferentes, o nosso resultado será o mesmo.")]),o("p",{staticClass:"text-justify"},[e._v("Compare o código completo, exibido a seguir, com o equivalente em JavaScript que exibimos anteriormente:")]),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def numeros (range 1 11))\n\n(println (reduce + numeros))\n; 55\n")]),o("index",{attrs:{entry:"high order function"}}),o("p",{staticClass:"text-justify"},[e._v("Quando uma função recebe outra como parâmetro, a chamamos de "),o("i",[e._v("High Order Function")]),e._v(" e, apesar do nome pomposo, você vai ver que é algo muito comum quando você utiliza programação funcional.")]),o("p",{staticClass:"text-justify"},[e._v("Caso você queira somar apenas os números pares entre 1 e 10, teríamos que utilizar um "),o("code",[e._v("if")]),e._v(" no nosso código JavaScript:")]),o("snippet",{attrs:{language:"javascript"}},[e._v('\nvar soma = 0;\n\nfor(var numero = 1; numero < 11; numero++) {\n  if(numero % 2 == 0) {\n    soma = soma + numero;\n  }\n}\n\nconsole.log("Resultado: ", soma);\n// Resultado:  30\n')]),o("index",{attrs:{entry:"filter"}}),o("index",{attrs:{entry:"predicado"}}),e._v("\nEm Clojure existe uma função chamada "),o("code",[e._v("filter")]),e._v(", que recebe como parâmetros um "),o("i",[e._v("predicado")]),e._v(" e uma lista. Um predicado é uma função que retorna "),o("code",[e._v("true")]),e._v(" ou "),o("code",[e._v("false")]),e._v(" de acordo com o parâmetro utilizado. A função "),o("code",[e._v("filter")]),e._v(" retorna uma nova lista contendo apenas os itens que fizerem o predicado retornar "),o("code",[e._v("true")]),e._v(".\n\n"),o("index",{attrs:{entry:"even?"}}),e._v("\n\nComo queremos somar apenas os números pares, vamos utilizar uma função chamada "),o("code",[e._v("even?")]),e._v(", que retorna "),o("code",[e._v("true")]),e._v(" caso o parâmetro passado seja um número par.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def numeros (range 1 11))\n\n(filter even? numeros)\n; (2 4 6 8 10)\n\nnumeros\n; (1 2 3 4 5 6 7 8 9 10)\n")]),o("index",{attrs:{entry:"filter"}}),e._v("\n\nPerceba que, mesmo que "),o("code",[e._v("filter")]),e._v(" retorne uma lista de números pares, o valor de "),o("code",[e._v("numeros")]),e._v(" continua inalterado. Quando lidamos com imutabilidade, as funções retornam um novo valor, deixando o valor original intacto.\n\n"),o("index",{attrs:{entry:"reduce"}}),e._v("\n\nAgora que temos nossa lista de números pares, vamos usar o já conhecido "),o("code",[e._v("reduce")]),e._v(" para calcular a somatória dos itens:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def numeros (range 1 11))\n\n(println\n  (reduce +\n    (filter even? numeros)))\n; 30\n")]),e._v("\n\nNovamente, compare com o código escrito em JavaScript e note a simplicidade da versão em Clojure.\n\n"),o("h2",[e._v("4.3. Funções anônimas")]),e._v("\n\nTanto a função "),o("code",[e._v("+")]),e._v(" quanto a função "),o("code",[e._v("even?")]),e._v(" fazem parte da biblioteca padrão do Clojure, que nos ajuda a resolver boa parte dos problemas. Mas, e se precisarmos de algo específico, que não existe na biblioteca padrão e em nenhuma biblioteca de terceiros? Nesse caso precisaremos criar nossas próprias funções.\n\nVamos supor que, ao invés de calcularmos a soma dos números pares entre 1 e 10, precisássemos calcular os múltiplos de 3 dentro dessa faixa de números.\n\nSe for o caso de usarmos essa lógica apenas uma vez, podemos criar uma função anônima para usarmos como predicado e selecionar apenas os múltiplos de 3:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def numeros (range 1 11))\n\n(filter\n  (fn [num] (= 0 (mod num 3)))\n  numeros)\n")]),o("index",{attrs:{entry:"fn"}}),e._v("\n\nUma função anônima é definida através da macro "),o("code",[e._v("fn")]),e._v(", recebendo em seguida um vetor com os parâmetros, delimitador por colchetes e, finalmente, a sequência de instruções a serem executadas. Funções anônimas também são chamadas de "),o("i",[e._v("lambdas")]),e._v(" ou "),o("i",[e._v("funções lambda")]),e._v(" em outras linguagens.\n\nEm Clojure não existe a palavra chave "),o("code",[e._v("return")]),e._v(", como acontece no JavaScript, e a função retorna o valor da última expressão avaliada, como acontece em Ruby.\n\n"),o("box",{attrs:{title:"Formas especiais"}},[e._v("\nNos dialetos LISP, uma "),o("i",[e._v("forma especial")]),e._v(" é uma construção primitiva da linguagem, avaliada de forma diferente das demais pelo compilador. A partir das formas especiais é possível construir macros e funções que formam a biblioteca padrão da linguagem.\n\n"),o("index",{attrs:{entry:"source"}}),e._v("\n\nEm Clojure é possível ver o código fonte de funções e macros através da macro "),o("code",[e._v("source")]),e._v(", disponível no namespace "),o("code",[e._v("clojure.repl")]),e._v(", mas você não consegue ver o código fonte das formas especiais a menos que olhe o código fonte do compilador.\n")],1),e._v("\n\nQuando utilizamos funções anônimas, é importante que façam o mínimo necessário, para que o nosso código não fique amontoado e difícil de entender.\n\n"),o("index",{attrs:{entry:"#( )"}}),e._v("\nExiste uma forma mais concisa de escrevemos funções anônimas, onde usamos "),o("code",[e._v("#( )")]),e._v(" ao invés de "),o("code",[e._v("fn")]),e._v(".\n\nReescrevendo nosso código, teríamos:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def numeros (range 1 11))\n\n(filter\n  #(= 0 (mod % 3))\n  numeros)\n")]),e._v("\n\nPerceba que não precisamos definir a lista de parâmetros para a função e podemos utilizá-los através do símbolo "),o("code",[e._v("%")]),e._v(" quando temos apenas um parâmetro, ou "),o("code",[e._v("%1")]),e._v(", "),o("code",[e._v("%2")]),e._v(" e assim por diante quando tivermos mais de um argumento.\n\n"),o("index",{attrs:{entry:"="}}),o("index",{attrs:{entry:"mod"}}),e._v("\n\nPerceba também que tanto "),o("code",[e._v("=")]),e._v(", que compara a igualdade de dois ou mais valores, e "),o("code",[e._v("mod")]),e._v(", que retorna o resto de divisão entre dois números, também são funções.\n\n"),o("h2",[e._v("4.4. Dando nomes às funções")]),e._v("\n\nNormalmente precisamos usar uma função mais de uma vez, e para isso ela precisa de um nome. Para isso basta criarmos um "),o("i",[e._v("var")]),e._v(" e atribuir uma função anônima a ele.\n\nPara demonstrar isso, vamos criar um código que calcule a soma dos dobros dos números entre 1 e 10.\n\nPodemos criar um "),o("i",[e._v("var")]),e._v(" chamado "),o("code",[e._v("dobro")]),e._v(" e atribuir uma função anônima que multiplica o valor recebido por dois:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def dobro (fn [x] (* x 2)))\n")]),o("index",{attrs:{entry:"defn"}}),e._v("\n\nEssa forma acaba deixando o código longo demais desnecessariamente. Então foi criada uma forma reduzida "),o("code",[e._v("defn")]),e._v(", que deixa a declaração de função mais parecida com o que já estamos habituados:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defn dobro [x] (* x 2))\n")]),o("index",{attrs:{entry:"map"}}),e._v("\nPara transformarmos nossa lista de números de 1 a 10 em uma lista de dobros, vamos utilizar a função "),o("code",[e._v("map")]),e._v(", que aplica a função que você informar a cada um dos itens da lista, retornando uma nova lista modificada. Vamos passar a função "),o("code",[e._v("dobro")]),e._v(" e nossa já conhecida lista de números como parâmetro.\n\nNosso código completo ficaria assim:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def numeros (range 1 11))\n\n(defn dobro [x] (* x 2))\n\n(reduce + (map dobro numeros))\n")]),o("box",{attrs:{title:"Transformando valores"}},[e._v("\nAs funções "),o("code",[e._v("map")]),e._v(", "),o("code",[e._v("reduce")]),e._v(", "),o("code",[e._v("filter")]),e._v(" e "),o("code",[e._v("apply")]),e._v(" são, sem dúvida, as mais importantes quando precisamos transformar ou calcular informações em uma linguagem funcional.\n\nBoa parte das funções utilizadas em Clojure usam alguma dessas funções internamente para chegar ao resultado esperado.\n")]),o("h2",[e._v("4.5. Sobrecarga de função e parâmetros opcionais")]),e._v("\n\nNo nosso exemplo anterior, criamos uma função chamada "),o("code",[e._v("dobro")]),e._v(" que recebe um número e retorna seu dobro. Se você tentar executar "),o("code",[e._v("dobro")]),e._v(" sem passar parâmetro nenhum, ou se passar mais de um parâmetro, receberemos um erro do compilador.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Chamando dobro sem parâmetros",label:"cap04-dobro-0"}},[e._v("\n(dobro)\n\n; ArityException Wrong number of args (0) passed to: user$dobro\n")]),e._v("\n\nE se quisermos escrever uma função que receba vários nomes e nos retorne o que tiver mais letras?\n\n"),o("index",{attrs:{entry:"sobrecarga de funções"}}),e._v("\nPodemos escrever a nossa primeira versão usando "),o("i",[e._v("sobrecarga de funções")]),e._v(". A sobrecarga ocorre quando você tem um mesmo nome de função com diferentes "),o("i",[e._v("assinaturas")]),e._v(".\n\n"),o("index",{attrs:{entry:"Java"}}),e._v("\nA assinatura de uma função, em Clojure, é a quantidade de parâmetros que a função recebe. Em Java, a assinatura depende da quantidade de parâmetros e de seus respectivos tipos.\n\nPor exemplo, nesse código em Java:\n\n"),o("snippet",{attrs:{language:"java"}},[e._v('\npublic class Sobrecarga {\n  public void metodo( ) {\n    System.out.println("Não tenho parâmetros");\n  }\n\n  public void metodo(String texto) {\n    System.out.println("Eu recebi uma String");\n  }\n\n  public void metodo(int numero) {\n    System.out.println("Eu recebi um numero");\n  }\n\n  public void metodo(String texto, int numero) {\n    System.out.println("Eu recebi uma String e um numero");\n  }\n}\n')]),e._v("\n\nAgora vamos usar a própria função "),o("code",[e._v("main")]),e._v(" para exibir o resultado:\n\n"),o("snippet",{attrs:{language:"java"}},[e._v('\npublic void static main(String[] args) {\n  Sobrecarga objeto = new Sobrecarga();\n\n  objeto.metodo();\n  // imprime: Não tenho parãmetros\n\n  objeto.metodo("Plínio");\n  // imprime: Eu recebi uma String\n\n  objeto.metodo(42);\n  // imprime: Eu recebi um numero\n\n  objeto.metodo("Douglas Adams", 42);\n  // imprime: Eu recebi uma String e um numero\n}\n')]),e._v("\n\nPerceba que foram executados blocos diferentes de código de acordo com o tipo e a quantidade de argumentos.\n\n"),o("index",{attrs:{entry:"aridade"}}),e._v("\n\nComo não declaramos o tipo do parâmetro de uma função em Clojure, a única coisa que diferencia um bloco de outro é sua "),o("i",[e._v("aridade")]),e._v(". Aridade nada mais é do que a quantidade de parâmetros que uma função recebe.\n\nPara utilizar sobrecarga de funções em Clojure, declaramos a função uma única vez, separando os blocos de acordo com suas respectivas aridades.\n\nColocando a mão na massa, nossa função teria essa cara:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defn maior-nome\n  ([a]\n    a)\n  ([a b]\n    (if (> (count a) (count b)) a b)))\n")]),e._v("\n\nNão é bonito, mas funcionou bem com um ou dois nomes. E se quisermos colocar três nomes? E com oito nomes?\n\n"),o("index",{attrs:{entry:"função variádica"}}),o("index",{attrs:{entry:"&"}}),e._v("\n\nAí entra em cena o conceito de "),o("i",[e._v("função variádica")]),e._v(", ou "),o("i",[e._v("função de aridade variável")]),e._v(". Esses nomes bonitões querem dizer que a função aceita um número variável de argumentos.\n\nPara isso, basta utilizar o símbolo "),o("code",[e._v("&")]),e._v(" antes do argumento na declaração da função:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn funcao\n  ([]\n    (println "Não tenho parâmetros"))\n  ([& b]\n    (println "Tenho um ou mais parâmetros" b)))\n')]),e._v("\n\nE, em seguida, vamos testar a função:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(funcao)\n\n(funcao 1 2 3 4)\n")]),e._v("\n\nNo nosso exemplo, quando você usa um ou mais argumentos, "),o("code",[e._v("b")]),e._v(" guarda um array contendo os itens que foram passados por parâmetro. A partir daí você pode transformá-los ou "),o("i",[e._v("consumí-los")]),e._v(", conforme a sua necessidade.\n\n"),o("box",{attrs:{title:"Consumindo itens"}},[o("i",[e._v("Consumir")]),e._v(" uma lista significa que você vai processar o primeiro item e passar o resto da lista por parâmetro para que seja processada novamente, de maneira recursiva.\n\nMais para frente vamos aprender recursão e você vai perceber que essa é uma estratégia muito comum quando lidamos com estruturas imutáveis.\n")]),e._v("\n\nVoltando à nossa função "),o("code",[e._v("maior-nome")]),e._v(", vamos escrever uma segunda versão de forma mais simples e elegante:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defn maior-nome [& nomes]\n  ; aqui vem o código\n  )\n")]),e._v("\n\nSabemos que "),o("code",[e._v("nomes")]),e._v(" contém uma lista de "),o("i",[e._v("strings")]),e._v(", contendo os nomes que passarmos para a função.\n\n"),o("index",{attrs:{entry:"sort"}}),o("index",{attrs:{entry:"sort-by"}}),e._v("\n\nExistem duas funções para ordenar listas em Clojure: "),o("code",[e._v("sort")]),e._v(" e "),o("code",[e._v("sort-by")]),e._v(". Vamos criar uma lista chamada "),o("code",[e._v("lista-nomes")]),e._v(" para simularmos o conteúdo de "),o("code",[e._v("nomes")]),e._v(" enquanto não escrevemos o código da função.\n\nPrimeiro vamos tentar ordenar usando "),o("code",[e._v("sort")]),e._v(":\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def lista-nomes ["Plínio" "Paulo" "Igor" "Gustavo"])\n\n(sort lista-nomes)\n; ("Gustavo" "Igor" "Paulo" "Plínio")\n')]),e._v("\n\nA lista foi ordenada alfabeticamente, e não pelo tamanho dos nomes. Fica claro que a função "),o("code",[e._v("sort")]),e._v(" não serve para o que queremos.\n\n"),o("index",{attrs:{entry:"count"}}),e._v("\n\nJá a função "),o("code",[e._v("sort-by")]),e._v(" permite que você informe a função que será usada para ordenar a lista. Vamos usar a função "),o("code",[e._v("count")]),e._v(", que retorna a quantidade de caracteres em um texto.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(count "Um texto qualquer")\n; 17\n\n(sort-by count lista-nomes)\n; ("Igor" "Paulo" "Plínio" "Gustavo")\n')]),e._v("\n\nAgora temos a nossa lista ordenada do menor nome, Igor, para o maior nome, Gustavo.\n\nPara extrairmos o último item da lista, podemos escolher qual estratégia utilizar.\n\n"),o("index",{attrs:{entry:">"}}),e._v("\n\nPodemos informar à função "),o("code",[e._v("sort-by")]),e._v(" que devemos ordenar a lista de forma decrescente, passando a função "),o("code",[e._v(">")]),e._v(" como parâmetro, ao invés do padrão crescente e então selecionar apenas o primeiro item através da função "),o("code",[e._v("first")]),e._v(".\n\nA função "),o("code",[e._v(">")]),e._v(" indica que "),o("i",[e._v("a palavra maior vem antes")]),e._v(", e que a menor vem depois:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(first (sort-by count > lista-nomes))\n")]),o("index",{attrs:{entry:"last"}}),o("index",{attrs:{entry:"reverse"}}),e._v("\n\nPodemos também manter a ordenação crescente e selecionar apenas o último item através da função "),o("code",[e._v("last")]),e._v(". Ou também podemos manter a ordenação crescente, utilizar a função "),o("code",[e._v("reverse")]),e._v(" para inverter a lista e então utilizar "),o("code",[e._v("first")]),e._v(" para selecionar o primeiro item.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(last (sort-by count lista-nomes))\n\n(first (reverse (sort-by count lista-nomes)))\n")]),e._v("\n\nEscolhendo a primeira estratégia para montar nossa função, nosso código completo ficaria assim:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn maior-nome [& nomes]\n  (first (sort-by count > nomes)))\n\n(maior-nome)\n; nil\n\n(maior-nome "João")\n; "João"\n\n(maior-nome "João" "Pedro")\n; "Pedro"\n\n(maior-nome "Plínio" "Paulo" "Igor" "Gustavo")\n; "Gustavo"\n')]),e._v("\n\nAgora podemos usar quantos nomes quisermos e a função continuará nos trazendo o maior nome.\n\n"),o("h2",[e._v("4.6. Documentação")]),o("index",{attrs:{entry:"doc"}}),e._v("\n\nO Clojure fornece uma macro "),o("code",[e._v("doc")]),e._v(" que apresenta a documentação da função informada.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defn maior-nome [& nomes]\n  (first (sort-by count > nomes)))\n\n(doc maior-nome)\n; -------------------------\n; user/maior-nome\n; ([& nomes])\n;   nil\n\n(doc +)\n; -------------------------\n; clojure.core/+\n; ([] [x] [x y] [x y & more])\n;   Returns the sum of nums. (+) returns 0. Does not auto-promote\n;   longs, will throw on overflow. See also: +'\n")]),e._v("\n\nNa função que acabamos de criar não existe documentação nenhuma, enquanto a função "),o("code",[e._v("+")]),e._v(" tem um breve texto explicativo que, se não ensina a linguagem para quem está tendo o primeiro contato, pelo menos auxilia aquele que tem alguma pequena noção de como utilizar.\n\nVamos adicionar um pequeno texto explicativo à nossa função e vamos testar novamente. Note que a documentação nada mais é do que uma "),o("i",[e._v("string")]),e._v(" na declaração da função.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn maior-nome\n  "Recebe vários nomes e retorna o que tiver a maior\n   quantidade de letras. Caso dois nomes tenham o mesmo\n   tamanho e sejam os maiores, será retornando apenas\n   um. Caso não seja informado nenhum nome, retorna nil."\n  [& nomes]\n  (first (sort-by count > nomes)))\n')]),e._v("\n\nO texto não ficou tão curto assim, mas é suficiente para que qualquer pessoa que entenda português consiga saber para que ela serve e como usar. Ao utilizarmos "),o("code",[e._v("doc")]),e._v(" novamente, teremos:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(doc maior-nome)\n-------------------------\n; user/maior-nome\n; ([& nomes])\n;   Recebe vários nomes e retorna o que tiver a maior\n;   quantidade de letras. Caso dois nomes tenham o mesmo\n;   tamanho e sejam os maiores, será retornando apenas\n;   um. Caso não seja informado nenhum nome, retorna nil.\n")]),e._v("\n\nApesar de não ser obrigatório, o uso do texto de documentação sempre deve ser considerado ao desenvolver bibliotecas para terceiros. Existem ferramentas que automatizam a geração de documentação em diversos formatos usando esses textos como base.\n\n"),o("h2",[e._v("4.7. Criando escopos locais")]),e._v("\n\nQuando escrevemos código em JavaScript, usamos a palavra chave "),o("code",[e._v("var")]),e._v(" para declarar tanto variáveis locais quando globais. Vamos declarar uma variável chamada "),o("code",[e._v("valor")]),e._v(", exibir seu valor antes e depois da função "),o("code",[e._v("calculaPreco")]),e._v(". Dentro da função "),o("code",[e._v("calculaPreco")]),e._v(" vamos criar outra variável que também vamos chamar de "),o("code",[e._v("valor")]),e._v(".\n\nO comportamento esperado é que o valor dentro da função não afete o valor que está do lado de fora. Na listagem "),o("label",{attrs:{entry:"cap04-escopo-0"}}),e._v(" vamos ver isso na prática:\n\n"),o("snippet",{attrs:{language:"javascript",title:"Diferentes escopos com JavaScript",label:"cap04-escopo-0"}},[e._v('\nvar valor = 10;\n\nfunction calculaPreco (quantidade) {\n  var valor = quantidade * 2;\n\n  console.log("O valor dentro da função é", valor);\n}\n\nconsole.log("O valor antes de calculaPreco é", valor);\n\ncalculaPreco(30);\n\nconsole.log("O valor depois de calculaPreco é", valor);\n')]),e._v("\n\nNa imagem "),o("label",{attrs:{entry:"escopo-javascript"}}),e._v(" podemos ver o resultado:\n\n"),o("image",{attrs:{src:"images/capitulo_04/escopo_javascript.png",description:"Diferentes escopos com JavaScript",label:"escopo-javascript",width:"80%"}}),o("index",{attrs:{entry:"shadowing"}}),e._v("\nA mesma coisa acontece quando escrevemos código em Java ou Ruby. Quando declaramos uma variável em uma função com o mesmo nome de uma variável global, ocorre algo chamado "),o("i",[e._v("shadowing")]),e._v(", onde a variável do menor escopo "),o("i",[e._v("esconde")]),e._v(" a variável do escopo maior.\n\nSeguindo essa lógica, podemos pensar que basta usarmos "),o("code",[e._v("def")]),e._v(" dentro da função para que possamos utilizar valores locais, certo?\n\nErrado. Vamos descobrir logo que não é bem assim que a coisa funciona em Clojure.\n\nNa listagem "),o("label",{attrs:{entry:"cap04-escopo-1"}}),e._v(" vamos usar "),o("code",[e._v("def")]),e._v(" para escrever o mesmo código que fizemos anteriormente com JavaScript.\n\n"),o("snippet",{attrs:{language:"Atribuindo valores com def",label:"cap04-escopo-1"}},[e._v('\n(def valor 10)\n\n(defn calcula-preco [quantidade]\n  (def valor (* quantidade 2))\n  (println "O valor dentro da função é" valor))\n\n(println "O valor antes de calcula-preco é" valor)\n; O valor antes de calcula-preco é 10\n\n(calcula-preco 30)\n; O valor dentro da função é 60\n\n(println "O valor depois de calcula-preco é" valor)\n; O valor depois de calcula-preco é 60\n')]),e._v("\n\nO valor contido em "),o("code",[e._v("valor")]),e._v(" foi alterado globalmente, e não era isso que estávamos esperando.\n\n"),o("index",{attrs:{entry:"def"}}),o("index",{attrs:{entry:"Var"}}),e._v("\nAo utilizarmos a forma "),o("code",[e._v("def")]),e._v(" para atribuir um valor a um símbolo, estamos criando uma estrutura chamada "),o("i",[e._v("var")]),e._v(" para armazenar esse valor. Esse "),o("i",[e._v("var")]),e._v(" é visível em toda a aplicação e, alguns casos que veremos nos capítulos seguintes, pode ter seu valor modificado.\n\nUma boa regra para o desenvolvimento de software é manter o valor dentro do menor escopo possível, e isso não é possível utilizando "),o("i",[e._v("var")]),e._v(".\n\n"),o("index",{attrs:{entry:"let"}}),o("index",{attrs:{entry:"escopo local"}}),o("index",{attrs:{entry:"contexto léxico"}}),o("index",{attrs:{entry:"escopo léxico"}}),o("index",{attrs:{entry:"escopo estático"}}),o("index",{attrs:{entry:"local binding"}}),e._v("\nEm Clojure temos uma forma chamada "),o("code",[e._v("let")]),e._v(" que cria um escopo local, chamado também de "),o("i",[e._v("contexto léxico")]),e._v(", "),o("i",[e._v("escopo léxico")]),e._v(" ou "),o("i",[e._v("escopo estático")]),e._v(", e ainda "),o("i",[e._v("atribui valores a símbolos de maneira imutável")]),e._v(". Isso significa que, uma vez que um símbolo receba um valor, algo chamado de atribuição ou "),o("i",[e._v("binding")]),e._v(", não podemos mais alterá-lo enquanto estivermos dentro daquele escopo.\n\n"),o("box",{attrs:{title:"O let no JavaScript"}},[e._v("\nA partir de sua versão 1.7"),o("bib",{attrs:{entry:"let-javascript"}}),e._v(", o JavaScript também passou a ter uma palavra chave "),o("code",[e._v("let")]),e._v(", que também serve para atribuir valores em escopos locais. Porém, como JavaScript não faz uso de imutabilidade, essa versão de "),o("code",[e._v("let")]),e._v(" permite que os valores sejam alterados após a atribuição.\n")],1),e._v("\n\nO "),o("code",[e._v("let")]),e._v(", em sua forma mais simples, recebe como parâmetro um vetor contendo um par de itens para cada atribuição. O primeiro item desse par é o símbolo que vai receber o valor, e o segundo é o valor propriamente dito. Esse símbolo é chamado de "),o("i",[e._v("local binding")]),e._v(", algo como "),o("i",[e._v("atribuição local")]),e._v(":\n\n"),o("snippet",{attrs:{language:"clojure",title:"let em sua forma mais simples",label:"cap04-escopo-2"}},[e._v('\n(let [x 5]\n  (println "O valor de x é" x))\n; O valor de x é 5\n\n(println "Tentando acessar x fora do escopo" x)\n; CompilerException java.lang.RuntimeException:\n;  Unable to resolve symbol: x in this context\n')]),e._v("\n\nNa listagem "),o("label",{attrs:{entry:"cap04-escopo-2"}}),e._v(" podemos ver que "),o("code",[e._v("x")]),e._v(" só existe dentro do escopo criado pelo "),o("code",[e._v("let")]),e._v(". Ao tentarmos acessar "),o("code",[e._v("x")]),e._v(" fora do escopo, recebemos um erro.\n\nVamos reescrever em Clojure o código da listagem "),o("label",{attrs:{entry:"cap04-escopo-0"}}),e._v(", que fizemos em JavaScript, mas usando escopo local:\n\n"),o("snippet",{attrs:{language:"clojure",title:"Atribuindo valores com escopo local",label:"cap04-escopo-3"}},[e._v('\n(def valor 10)\n\n(defn calcula-preco [quantidade]\n  (let [valor (* quantidade 2)]\n    (println "O valor dentro da função é" valor)))\n\n(println "O valor antes de calcula-preco é" valor)\n; O valor antes de calcula-preco é 10\n\n(calcula-preco 30)\n; O valor dentro da função é 60\n\n(println "O valor depois de calcula-preco é" valor)\n; O valor depois de calcula-preco é 10\n')]),e._v("\n\nVeja que agora a função não alterou o valor do "),o("i",[e._v("var")]),e._v(" que criamos no início do código. Aqui também ocorre "),o("i",[e._v("shadowing")]),e._v(", permitindo que você crie "),o("i",[e._v("local bindings")]),e._v(" com o mesmo nome dos "),o("i",[e._v("vars")]),e._v(" já existentes na aplicação, como vimos ao criar o "),o("i",[e._v("local binding")]),o("code",[e._v("valor")]),e._v(" dentro da função "),o("code",[e._v("calcula-preco")]),e._v(".\n\nO mesmo pode ser feito ao criarmos um "),o("i",[e._v("local binding")]),e._v(", ou simplesmente "),o("i",[e._v("local")]),e._v(", com o mesmo nome de um dos parâmetros da função. O tal do "),o("i",[e._v("shadowing")]),e._v(" torna isso possível:\n\n"),o("snippet",{attrs:{language:"clojure",title:"Demonstrando shadowing",label:"cap04-escopo-4"}},[e._v('\n(def numero 42)\n\n(defn demonstra-shadowing [numero]\n  (println "No inicio da funcao numero vale" numero)\n  (let [numero 1]\n    (println "Dentro do let numero vale" numero))\n  (println "No fim da funcao numero vale" numero))\n\n(println "O var numero vale" numero)\n; O var numero vale 42\n\n(demonstra-shadowing 35)\n; No inicio da funcao numero vale 35\n; Dentro do let numero vale 1\n; No fim da funcao numero vale 35\n')]),o("index",{attrs:{entry:"var"}}),o("index",{attrs:{entry:"#'"}}),e._v("\nCaso você queira ver o valor do "),o("i",[e._v("var")]),e._v(" mesmo quando ocorre "),o("i",[e._v("shadowing")]),e._v(", você deve utilizar a "),o("i",[e._v("forma qualificada")]),e._v(", informando o "),o("i",[e._v("namespace")]),e._v(" e o nome do "),o("i",[e._v("var")]),e._v(" separados pelo caracter "),o("code",[e._v("/")]),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def numero 42)\n\n(println "numero vale" numero)\n; numero vale 42\n\n(let [numero 35]\n  (println "Valor com shadowing" numero)\n  (println "Valor sem shadowing" user/numero))\n; Valor com shadowing 35\n; Valor sem shadowing 42\n')]),e._v("\n\nOutra característica do "),o("code",[e._v("let")]),e._v(" é que, pelo fato das atribuições ocorrerem sequencialmente, você pode quebrar seu código em pequenos passos lógicos, tornando-o mais fácil de entender.\n\n"),o("h3",[e._v("Usando let para melhorar o código")]),o("index",{attrs:{entry:"Bhaskara"}}),o("index",{attrs:{entry:"equação quadrática"}}),e._v("\nA maneira mais conhecida de se resolver equações de segundo grau é através do que chamamos no Brasil de "),o("i",[e._v("fórmula de Bhaskara")]),e._v(", que podemos ver na figura "),o("label",{attrs:{entry:"bhaskara"}}),e._v(". Nos demais países ela é conhecida apenas por "),o("i",[e._v("equação quadrática"),o("i",[e._v(" ou ")]),e._v("fórmula geral para resolução da equação polinomial do segundo grau")]),o("bib",{attrs:{entry:"equacao-quadratica"}}),e._v(". Para fins de concisão, vamos chamar apenas de "),o("i",[e._v("Bhaskara")]),e._v(".\n\n"),o("image",{attrs:{src:"images/capitulo_04/bhaskara.jpg",description:"Equação quadrática",label:"bhaskara",width:"30%"}}),e._v("\n\nUma equação de segundo grau se apresenta na forma "),o("code",[e._v("ax² + bx + c = 0")]),e._v(", sendo "),o("code",[e._v("a")]),e._v(", "),o("code",[e._v("b")]),e._v(" e "),o("code",[e._v("c")]),e._v(" valores numéricos sem nada de especial. Esse tipo de equação apresenta dois valores válidos para "),o("code",[e._v("x")]),e._v(", que são chamados de "),o("i",[e._v("raízes")]),e._v(".\n\nPara encontrar os valores dessas raízes, vamos criar uma função chamada "),o("i",[e._v("bhaskara")]),e._v(", que recebe três parâmetros referentes aos valores de "),o("code",[e._v("a")]),e._v(", "),o("code",[e._v("b")]),e._v(" e "),o("code",[e._v("c")]),e._v(" e retorna um vetor de duas posições, contendo as raízes da equação.\n\nNa listagem "),o("label",{attrs:{entry:"cap04-escopo-5"}}),e._v(", vamos implementar essa função com um código compacto, mas difícil de ler.\n\n"),o("index",{attrs:{entry:"Math/sqrt"}}),o("snippet",{attrs:{language:"clojure",title:"Equação quadrática pelo jeito curto e difícil de ler",label:"cap04-escopo-5"}},[e._v("\n(defn bhaskara [a b c]\n  [(/ (+ (- b) (Math/sqrt (- (* b b) (* 4 a c)))) (* 2 a))\n   (/ (- (- b) (Math/sqrt (- (* b b) (* 4 a c)))) (* 2 a))])\n\n(bhaskara 1 -1 -2)\n; [2.0, -1.0]\n")]),e._v("\n\nVamos começar quebrando a equação, calculando o discriminante, ou delta, separadamente. Apesar do delta se referir apenas a "),o("code",[e._v("b² - 4ac")]),e._v(", conforme exibido na figura "),o("label",{attrs:{entry:"bhaskara-delta"}}),e._v(", vamos incluir também o cálculo de raiz quadrada, para que nosso código fique mais organizado.\n\n"),o("image",{attrs:{src:"images/capitulo_04/bhaskara_delta.png",description:"Discriminante, ou delta",width:"30%",label:"bhaskara-delta"}}),e._v("\n\nVamos separar o discriminante num "),o("i",[e._v("local binding")]),e._v(" chamado "),o("code",[e._v("delta")]),e._v(", e vamos usar o corpo da função para calcular o restante da equação, de acordo com a figura "),o("label",{attrs:{entry:"bhaskara-simplificado"}}),e._v(".\n\n"),o("image",{attrs:{src:"images/capitulo_04/bhaskara_simplificado.png",description:"Equação com o delta separado",width:"30%",label:"bhaskara-simplificado"}}),e._v("\n\nSeparando o delta do restante da equação, nosso código ficaria assim:\n\n"),o("snippet",{attrs:{language:"clojure",title:"Equação quadrática com o delta isolado",label:"cap04-escopo-6"}},[e._v("\n(defn bhaskara [a b c]\n  (let [delta (Math/sqrt (- (* b b) (* 4 a c)))]\n    [(/ (+ (- b) delta) (* 2 a))\n     (/ (- (- b) delta) (* 2 a))]))\n\n(bhaskara 1 -1 -2)\n; [2.0, -1.0]\n")]),e._v("\n\nPodemos separar também "),o("code",[e._v("b²")]),e._v(" como uma parte separada, para deixar o cálculo de "),o("code",[e._v("delta")]),e._v(" mais limpo. Podemos fazer o mesmo com "),o("code",[e._v("-b")]),e._v(", e até mesmo separar as duas raízes em "),o("code",[e._v("x1")]),e._v(" e "),o("code",[e._v("x2")]),e._v(".\n\nNosso código vai ficar mais extenso, mas os passos lógicos ficam mais claros. A partir deste ponto, fique à vontade para continuar quebrando o código em quantos passos você achar necessário. O tempo e a experiência vão te ensinar a decidir quando escrever código mais detalhado e quando escrever código mais conciso.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Equação quadrática com as partes separadas",label:"cap04-escopo-7"}},[e._v("\n(defn bhaskara [a b c]\n  (let [b-quadrado (* b b)\n        menos-b (- b)\n        delta (Math/sqrt (- b-quadrado (* 4 a c)))\n        x1 (/ (+ menos-b delta) (* 2 a))\n        x2 (/ (- menos-b delta) (* 2 a))]\n    [x1 x2]))\n\n(bhaskara 1 -1 -2)\n; [2.0, -1.0]\n")]),o("h3",[e._v("Um pequeno truque com let")]),e._v("\n\nEnquanto escrevia este capítulo, digitei o código abaixo para demonstrar como um "),o("i",[e._v("local binding")]),e._v(" não pode ser alterado depois de criado:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(let [valor 3\n      valor 42]\n  (println valor))\n; 42\n")]),e._v("\n\nEra esperado que um erro de execução ocorresse, mas acabou sendo exibido o último valor atribuido.\n\nAo pesquisar mais um pouco"),o("bib",{attrs:{entry:"change-let"}}),e._v(" descobri que, internamente, a linguagem cria um novo escopo léxico para atribuir "),o("i",[e._v("42")]),e._v(" ao "),o("i",[e._v("binding")]),o("code",[e._v("valor")]),e._v(".\n\nEntão, na prática, esse código vai ser transformado em:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(let [valor 3]\n  (let [valor 42]\n    (println 42)))\n; 42\n")]),e._v("\n\nA segunda declaração de "),o("code",[e._v("valor")]),e._v(" vai fazer shadowing na primeira, fazendo com que o "),o("i",[e._v("3")]),e._v(" não possa ser acessado.\n\nEntão você se pergunta onde é que isso seria usado.\n\nExiste um macete bem interessante para podermos depurar os valores do "),o("i",[e._v("binding")]),e._v(" passo a passo.\n\nO símbolo "),o("code",[e._v("_")]),e._v(" é um identificador válido em Clojure, mas normalmente é utilizado para indicar que aquele valor não vai ser aproveitado.\n\nVamos utilizar esse símbolo apenas para ocupar espaço enquanto usamos a função "),o("code",[e._v("println")]),e._v(" para exibir os valores conforme os "),o("i",[e._v("binding")]),e._v(" vão sendo executados. Vamos aproveitar a listagem "),o("label",{attrs:{entry:"cap04-escopo-7"}}),e._v(" para exibir passo a passo o que está acontecendo no nosso cálculo.\n\nQuando usamos um símbolo ou um valor apenas para ocupar espaço, dizemos que ele é um "),o("i",[e._v("placeholder")]),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure",title:"Depurando o binding",label:"cap04-escopo-8"}},[e._v('\n(defn bhaskara [a b c]\n  (let [b-quadrado (* b b)\n        _ (println "b² =" b-quadrado)\n        menos-b (- b)\n        _ (println "-b =" menos-b)\n        delta (Math/sqrt (- b-quadrado (* 4 a c)))\n        _ (println "delta =" delta)\n        x1 (/ (+ menos-b delta) (* 2 a))\n        _ (println "x1 =" x1)\n        x2 (/ (- menos-b delta) (* 2 a))\n        _ (println "x2 =" x2)]\n    [x1 x2]))\n\n(bhaskara 1 -1 -2)\n; b² = 1\n; -b = 1\n; delta = 3.0\n; x1 = 2.0\n; x2 = -1.0\n; [2.0 -1.0]\n')]),o("h3",[e._v("Declarando funções locais")]),e._v("\n\nEm alguns casos é necessário criar funções que serão usadas apenas dentro daquele escopo local.\n\nVamos usar novamente o código da listagem "),o("label",{attrs:{entry:"cap04-escopo-7"}}),e._v(" para demonstrar como podemos fazer isso.\n\nPara calcular "),o("code",[e._v("delta")]),e._v(", estamos usando "),o("code",[e._v("Math/sqrt")]),e._v(", que é o método estático "),o("code",[e._v("sqrt")]),e._v(" da classe Java "),o("code",[e._v("Math")]),e._v(". Apesar de funcionar muito bem, podemos argumentar que a chamada dessa forma não está com cara de Clojure e bagunça a leitura do código.\n\nVamos criar um "),o("i",[e._v("binding")]),e._v(" com o nome de "),o("code",[e._v("raiz")]),e._v(", que contém uma função que recebe um parâmetro e calcula a respectiva raiz quadrada usando o método do Java.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Declarando uma função local com binding",label:"cap04-escopo-8"}},[e._v("\n(defn bhaskara [a b c]\n  (let [raiz (fn [x] (Math/sqrt x))\n        b-quadrado (* b b)\n        menos-b (- b)\n        delta (raiz (- b-quadrado (* 4 a c)))\n        x1 (/ (+ menos-b delta) (* 2 a))\n        x2 (/ (- menos-b delta) (* 2 a))]\n    [x1 x2]))\n\n(bhaskara 1 -1 -2)\n; [2.0, -1.0]\n")]),e._v("\n\nO nosso cálculo de "),o("code",[e._v("delta")]),e._v(" ficou um pouco mais limpo a partir do momento em que escondemos a chamada ao Java dentro de uma função. Uma função que esconde, ou "),o("i",[e._v("empacota")]),e._v(", uma chamada ao Java é chamada de "),o("i",[e._v("wrapper")]),e._v(".\n\nÉ comum na biblioteca padrão do Clojure que se juntem dois operadores para formar um. Vimos isso com a forma "),o("code",[e._v("defn")]),e._v(", que é a junção de "),o("code",[e._v("def")]),e._v(" com "),o("code",[e._v("fn")]),e._v(".\n\n"),o("index",{attrs:{entry:"letfn"}}),e._v("\n\nAo invés de usarmos um "),o("code",[e._v("fn")]),e._v(" dentro de um "),o("code",[e._v("let")]),e._v(", podemos usar a forma "),o("code",[e._v("letfn")]),e._v(", que internamente opera de modo similar.\n\nNa listagem "),o("label",{attrs:{entry:"cap04-escopo-9"}}),e._v(", reescrevemos o nosso código usando "),o("code",[e._v("letfn")]),e._v(" para separar a declaração de função local dos passos lógicos do nosso código.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Declarando uma função local com letfn",label:"cap04-escopo-9"}},[e._v("\n(defn bhaskara [a b c]\n  (letfn [(raiz [x] (Math/sqrt x))]\n    (let [b-quadrado (* b b)\n          menos-b (- b)\n          delta (raiz (- b-quadrado (* 4 a c)))\n          x1 (/ (+ menos-b delta) (* 2 a))\n          x2 (/ (- menos-b delta) (* 2 a))]\n      [x1 x2])))\n\n(bhaskara 1 -1 -2)\n; [2.0, -1.0]\n")]),e._v("\n\nPerceba que a sintaxe de "),o("code",[e._v("letfn")]),e._v(" é uma mistura de "),o("code",[e._v("defn")]),e._v(" com "),o("code",[e._v("let")]),e._v(", onde você precisa informar o nome, a lista de argumentos e o corpo da função dentro de um vetor.\n\n"),o("index",{attrs:{entry:"escopo global"}}),o("index",{attrs:{entry:"escopo léxico"}}),o("index",{attrs:{entry:"escopo dinâmico"}}),o("h2",[e._v("4.8. Escopos global, léxico e dinâmico")]),e._v("\n\nO escopo que conhecemos de linguagens como C, Java, Ruby e várias outras e usamos praticamente o tempo todo com "),o("code",[e._v("let")]),e._v(" ou dentro de funções é o "),o("i",[e._v("escopo léxico")]),e._v(", como vimos há pouco.\n\nNesse tipo de escopo uma informação existe apenas num intervalo específico de código.\n\nEm Clojure, ao criarmos um escopo dentro de outro e atribuirmos valores a um mesmo símbolo declarado em cada um desses escopos, o símbolo do escopo mais interno vai esconder o valor referenciado pelo símbolo do escopo imediatamente menos interno. Isso é chamado "),o("i",[e._v("shadowing")]),e._v(", como também vimos neste capítulo.\n\nDica: quando executar os códigos a seguir, não precisa digitar os números de linha. Coloquei-os aqui apenas para facilitar a explicação na sequencia.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def lexico :batata)                                ;  1\n\n(println "Antes do let:" lexico)                    ;  2\n; Antes do let: :batata\n\n(let [lexico :abobora]                              ;  3\n  (println "Dentro do escopo local" lexico)         ;  4\n  (let [lexico :feijao]                             ;  5\n    (println "Escopo local mais interno" lexico))   ;  6\n  (println "Escopo local menos interno" lexico))    ;  7\n; Dentro do escopo local :abobora\n; Escopo local mais interno :feijao\n; Escopo local menos interno :abobora\n\n(println "Fora do escopo local"  lexico)            ;  8\n; Fora do escopo local :batata\n')]),e._v("\n\nNa linha "),o("i",[e._v("1")]),e._v(" definimos um "),o("i",[e._v("var")]),e._v(" chamado "),o("code",[e._v("lexico")]),e._v(" e exibimos seu valor na linha "),o("i",[e._v("2")]),e._v(".\n\nJá na linha "),o("i",[e._v("3")]),e._v(" criamos um "),o("i",[e._v("local binding")]),e._v(" com o mesmo nome do "),o("i",[e._v("var")]),e._v(" e atribuimos outro valor, exibido na linha "),o("i",[e._v("4")]),e._v(". Na linha "),o("i",[e._v("5")]),e._v(" criamos outro escopo dentro do escopo existente e atribuimos ainda outro valor. Esse valor do escopo mais interno esconde o valor do escopo imediatamente acima, que já estava escondendo o valor do escopo mais amplo.\n\nJá o "),o("i",[e._v("escopo global")]),e._v(" é uma aplicação do escopo léxico que pode nos trazer incontáveis dores de cabeça. É quando temos um valor pode ser acessado de qualquer parte do sistema.\n\nSe o valor puder apenas ser acessado, não há tanto problema. A coisa fica feia quando qualquer parte do sistema pode "),o("i",[e._v("acessar e modificar")]),e._v(" o valor. Isso pode nos levar a inconsistências e comportamentos inesperados.\n\nVamos ver um dos problemas em utilizar dados no escopo global.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def global :carvao)                                ;  1\n\n(println "Estado global:" global)                   ;  2\n; Estado global: :carvao\n\n(let [lexico :carne]                                ;  3\n  (println "Dentro do escopo local" lexico)         ;  4\n  (def global :cerveja)                             ;  5\n  (println "Dentro do escopo local" lexico))        ;  6\n; Dentro do escopo local :carne\n; Dentro do escopo local :carne\n\n(println "Depois do escopo local:"  global)         ; 7\n; Depois do escopo local: :cerveja\n')]),e._v("\n\nNa linha "),o("i",[e._v("1")]),e._v(" nós criamos o "),o("i",[e._v("var")]),o("code",[e._v("global")]),e._v(" e atribuimos um valor, exibindo-o na linha "),o("i",[e._v("2")]),e._v(".\n\nJá na linha "),o("i",[e._v("3")]),e._v(" criamos um "),o("i",[e._v("local binding")]),e._v(" com o mesmo nome, demonstrando na linha "),o("i",[e._v("4")]),e._v(" que o valor do "),o("i",[e._v("var")]),e._v(" foi escondido pelo "),o("i",[e._v("binding")]),e._v(". Porém, na linha "),o("i",[e._v("5")]),e._v(" criamos um novo "),o("i",[e._v("var")]),e._v(", atribuindo o valor "),o("code",[e._v(":cerveja")]),e._v(". Note que na linha "),o("i",[e._v("6")]),e._v(" não vemos nenhuma mudança no valor por conta do "),o("i",[e._v("shadowing")]),e._v(".\n\nJá na linha "),o("i",[e._v("7")]),e._v(" o valor aparece modificado. Como o valor exibido dentro do "),o("code",[e._v("let")]),e._v(" não apresenta diferença, a tentdência é que passemos direto ao tentarmos encontrar a causa do problema.\n\nA situação fica ainda pior quando trabalhamos com várias "),o("i",[e._v("threads")]),e._v(", por uma "),o("i",[e._v("thread")]),e._v(" pode alterar o valor do "),o("i",[e._v("var")]),e._v(" e isso acaba se refletindo nas outras "),o("i",[e._v("threads")]),e._v(". Para piorar ainda mais, o problema pode ou não ocorrer quando você tentar reproduzí-lo, já que não existe garantias de que "),o("i",[e._v("threads")]),e._v(" diferentes serão sempre executadas na mesma ordem e exatamente no mesmo intervalo de tempo.\n\n"),o("h3",[e._v("Escopo dinâmico")]),o("index",{attrs:{entry:"binding (macro)"}}),e._v("\nJá o "),o("i",[e._v("escopo dinâmico"),o("i",[e._v(" funciona como o ")]),e._v("escopo global")]),e._v(", mas o valor fica restrito às chamadas delimitadas pela macro "),o("code",[e._v("binding")]),e._v(" e pela "),o("i",[e._v("thread")]),e._v(" em que a chamada a "),o("code",[e._v("binding")]),e._v(" ocorre.\n\n"),o("index",{attrs:{entry:"^:dynamic"}}),e._v("\nPara usarmos escopo dinâmico, precisamos adicionar a anotação "),o("code",[e._v("^:dynamic")]),e._v(" no "),o("i",[e._v("var")]),e._v(" que vamos criar.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def ^:dynamic *parte* "cabeça")\n')]),o("box",{attrs:{title:"Cuidado com textos desatualizados"}},[e._v("\nAté a versão "),o("code",[e._v("1.2")]),e._v(" do Clojure todo "),o("i",[e._v("var")]),e._v(" era dinâmico por padrão. Da versão "),o("code",[e._v("1.3")]),e._v(" em diante passou a ser obrigatório anotar o "),o("i",[e._v("var")]),e._v(" com "),o("code",[e._v("^:dynamic")]),e._v(". Sabendo disso, tome cuidado com textos e documentação desatualizada que ainda pode ser encontrada facilmente na Internet.\n")]),o("index",{attrs:{entry:"earmuffins"}}),e._v("\nNote os asteriscos ao redor do nome do "),o("i",[e._v("var")]),e._v(". Eles são chamados "),o("i",[e._v("earmuffins")]),e._v(" e servem para sinalizar a quem lê o código que estamos lidando com "),o("i",[e._v("vars")]),e._v(" dinâmicos. Para o Clojure não faz diferença se você não utilizar os "),o("i",[e._v("earmuffins")]),e._v(", mas é uma boa prática adotada pela comunidade.\n\nVamos criar agora uma função que exibe o nome do nosso "),o("i",[e._v("var")]),e._v(" dinâmico.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn mostra-binding [onde]\n  (println onde "-" *parte*))\n\n(mostra-binding "antes do binding")\n; antes do binding - cabeça\n')]),o("index",{attrs:{entry:"root binding"}}),e._v("\nAté aqui não há diferença alguma. A função exibiria o valor que demos na definição do "),o("i",[e._v("var")]),e._v(" sendo dinâmica ou não. Aliás, essa atribuição de valor na criação do "),o("i",[e._v("var")]),e._v(" chama-se "),o("i",[e._v("root binding")]),e._v(".\n\nVamos agora definir um novo valor para "),o("code",[e._v("*parte*")]),e._v(" através da macro "),o("code",[e._v("binding")]),e._v(" e ver o que se passa dentro da função "),o("code",[e._v("mostra-binding")]),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(binding [*parte* "perna"]\n  (mostra-binding "dentro do binding"))\n; dentro do binding - perna\n\n(mostra-binding "depois do binding")\n; depois do binding - cabeca\n')]),e._v("\n\nPerceba que o valor de "),o("code",[e._v("*parte*")]),e._v(" mudou apenas no escopo de "),o("code",[e._v("binding")]),e._v(", inclusive dentro da função.\n\nO escopo dinâmico funciona como um escopo global controlado, em que podemos delimitar quem vai visualizar o valor do "),o("i",[e._v("var")]),e._v(".\n\nUma característica importante do escopo dinâmico é que o valor que definirmos na macro "),o("code",[e._v("binding")]),e._v(" fica restrito apenas à "),o("i",[e._v("thread")]),e._v(" em que ele foi definido. Qualquer "),o("i",[e._v("thread")]),e._v(" diferente vai enxergar apenas o valor do "),o("i",[e._v("root binding")]),e._v(".\n\nPara demonstrar isso, vamos criar uma função chamada "),o("code",[e._v("start-thread")]),e._v(", que recebe uma função como parâmetro e a executa em uma "),o("i",[e._v("thread")]),e._v(" diferente da atual.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defn start-thread [fun]\n  (.start (Thread. fun)))\n")]),e._v("\n\nAgora vamos executar novamente nossa função "),o("code",[e._v("mostra-binding")]),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def ^:dynamic *parte* "cabeça")\n\n(mostra-binding "antes do binding")\n; antes do binding - cabeça\n\n(binding [*parte* "perna"]\n  (println "dentro do binding -" *parte*)\n  (start-thread #(mostra-binding "dentro da thread")))\n; dentro do binding - perna\n; dentro da thread - cabeça\n\n(mostra-binding "depois do binding")\n; depois do binding - cabeça\n')]),e._v("\n\nMesmo dentro do "),o("code",[e._v("binding")]),e._v(", o código que foi executado em outra "),o("i",[e._v("thread")]),e._v(" não utilizou o valor "),o("i",[e._v("perna")]),e._v(", e sim o valor definido lá no "),o("i",[e._v("root binding")]),e._v(". Isso nos ajuda a escrever código isolado por "),o("i",[e._v("thread")]),e._v(", ou seja, cada "),o("i",[e._v("thread")]),e._v(" enxerga seus próprios dados sem atrapalhar alguma "),o("i",[e._v("thread")]),e._v(" que esteja sendo executada ao mesmo tempo.\n\nEsse tipo de escopo é muito utilizado para trabalharmos com recursos externos separados por "),o("i",[e._v("thread")]),e._v(", como por exemplo conexões de rede.\n\nPodemos utilizar também para testarmos recursos utilizando "),o("i",[e._v("mock")]),e._v(", ou seja, passamos uma função ou um objeto falso e nosso código o trata como se fosse verdadeiro. Isso ajuda a testar nosso código sem a necessidade de ter um banco de dados ou uma estrutura de rede disponível.\n\n"),o("index",{attrs:{entry:"println"}}),o("index",{attrs:{entry:"*out*"}}),e._v("\nUma função que usamos o tempo todo e faz uso de escopo local é "),o("code",[e._v("println")]),e._v(", que faz uso do "),o("i",[e._v("var")]),e._v(" dinâmico "),o("code",[e._v("*out*")]),e._v(". Isso significa que podemos fazer com que "),o("code",[e._v("println")]),e._v(" direcione o que deveria ser impresso na tela para um arquivo em disco ou para uma conexão de rede.\n\nVamos brincar com isso.\n\nPrimeiro vamos precisar daquela nossa função "),o("code",[e._v("start-thread")]),e._v(". Uma "),o("i",[e._v("thread")]),e._v(" vai imprimir na tela enquanto a outra vai gravar em disco.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defn start-thread [fun]\n  (.start (Thread. fun)))\n")]),e._v("\n\nVamos agora criar uma função que tanto grava em disco as informações que mandarmos imprimir, quanto imprime na tela, dependendo do que definirmos como "),o("code",[e._v("*out*")]),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn imprime []\n  (Thread/sleep 500)\n  (println "Linha 1")\n  (Thread/sleep 500)\n  (println "Linha 2")\n  (Thread/sleep 500)\n  (println "Ultima linha"))\n')]),e._v("\n\nAgora vamos executar a mesma função em duas "),o("i",[e._v("threads")]),e._v(" diferentes, ao mesmo tempo.\n\n"),o("index",{attrs:{entry:"java.io.Writer"}}),e._v("\nO "),o("i",[e._v("var")]),o("code",[e._v("*out*")]),e._v(" aponta para um objeto Java que implementa "),o("code",[e._v("java.io.Writer")]),e._v(".\n\n"),o("index",{attrs:{entry:"type"}}),o("index",{attrs:{entry:"java.io.PrintWriter"}}),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(type *out*)\n; java.io.PrintWriter\n")]),o("index",{attrs:{entry:"java.io.FileWriter"}}),e._v("\nA classe "),o("code",[e._v("java.io.PrintWriter")]),e._v(" é a responsável pela exibição dos dados na tela. Vamos implementar um objeto do tipo "),o("code",[e._v("java.io.FileWriter")]),e._v(" para que possamos gravar em disco.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(start-thread (fn []\n                (println "Esse vai na tela")\n                (imprime)))\n\n(start-thread (fn []\n                (binding [*out* (java.io.FileWriter. "print.txt")]\n                  (println "Esse vai no arquivo")\n                  (imprime))))\n\n;; pausa\n; Linha 1\n;; pausa\n; Linha 2\n;; pausa\n; Ultima linha\n')]),o("index",{attrs:{entry:"slurp"}}),e._v("\nAgora vamos exibir o que gravamos em disco usando a função "),o("code",[e._v("slurp")]),e._v(", que lê o conteúdo de um arquivo texto e o retorna.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(println (slurp "print.txt"))\n; Esse vai no arquivo\n; Linha 1\n; Linha 2\n; Ultima linha\n')]),e._v("\n\nDessa forma podemos mudar o comportamento de funções que não podemos alterar, como é o caso de "),o("code",[e._v("println")]),e._v(", tornando o código mais flexível e dinâmico.\n\n"),o("h2",[e._v("4.9. Contratos e condições")]),o("i",[e._v("Contratos")]),e._v(", do original em inglês "),o("i",[e._v("Design by Contract")]),e._v(", é uma forma de verificação dos argumentos recebidos pela função, chamada de "),o("i",[e._v("pré-condição")]),e._v(", e também do resultado da mesma função, que chamamos de "),o("i",[e._v("pós-condições")]),e._v(".\n\n"),o("index",{attrs:{entry:"Invariantes"}}),o("box",{attrs:{title:"Invariantes"}},[e._v("\nQuando uma condição é verdadeira do momento em que a função começa até o momento em que termina, dizemos que é uma "),o("i",[e._v("invariante")]),e._v(".\n\nO uso de contratos, através de pré-condições e pós-condições, é uma forma de garantir que as invariantes não assumam valores inesperados que podem causar erros de execução.\n")]),e._v("\n\nUma pré-condição permite que você verifique se os parâmetros atendem a uma ou mais condições antes mesmo que a função comece a ser executada.\n\nUm exemplo de pré-condição pode ser encontrado na forma "),o("code",[e._v("let")]),e._v(". Se você tentar usar "),o("code",[e._v("let")]),e._v(" sem que o primeiro argumento seja um vetor, e sem que esse vetor contenha um número par de argumentos, será lançada uma exceção antes que qualquer atribuição seja feita.\n\nUm caso em que podemos utilizar pré-condições é do cálculo do fatorial de um número. Sabemos que o parâmetro deve ser positivo e inteiro.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Cálculo de fatorial",label:"cap04-contrato-0"}},[e._v("\n(defn fatorial [n]\n  (if (< n 2)\n      1\n      (* n (fatorial (dec n)))))\n\n(fatorial 3)\n; 6\n\n(fatorial -2)\n1\n\n(fatorial 3.5)\n; 8.75\n")]),e._v("\n\nNo código da listagem "),o("label",{attrs:{entry:"cap04-contrato-0"}}),e._v(", a função retorna 1 para qualquer valor abaixo de 2, incluindo números negativos.\n\n"),o("h3",[e._v("Fazendo do jeito feio")]),o("index",{attrs:{entry:"cond"}}),e._v("\nPara limitarmos os valores, podemos adicionar uma verificação antes do nosso código atual para, em seguida, lançarmos uma exceção. Vamos usar a forma "),o("code",[e._v("cond")]),e._v(" que, de certa forma, é o equivalente ao "),o("code",[e._v("else if")]),e._v(" que já estamos acostumados. Com isso teríamos:\n\n"),o("snippet",{attrs:{language:"clojure",title:"Fatorial com checagem de número positivo",label:"cap04-contrato-1"}},[e._v("\n(import '(java.lang AssertionError))\n\n(defn fatorial [n]\n  (cond (< n 0) (throw (AssertionError.))\n        (< n 2)  1\n        :else (* n (fatorial (dec n)))))\n\n(fatorial 3)\n; 6\n\n(fatorial -2)\n; AssertionError\n")]),o("index",{attrs:{entry:"import"}}),o("index",{attrs:{entry:"java.lang.AssertionError"}}),o("index",{attrs:{entry:"throw"}}),e._v("\nNa primeira linha tivemos que importar a classe "),o("code",[e._v("java.lang.AssertionError")]),e._v(", para poder lançar uma exceção desse tipo através da forma "),o("code",[e._v("throw")]),e._v(". O ponto final após o nome da classe é a forma do Clojure criar um novo objeto utilizando uma classe Java. Veremos mais detalhes sobre a integração com Java mais para frente, no capítulo "),o("label",{attrs:{entry:"capitulo-integracao-java"}}),e._v(".\n\n"),o("index",{attrs:{entry:"or"}}),o("index",{attrs:{entry:"integer?"}}),e._v("\nEm seguida precisaremos verificar se o número é inteiro. Para isso vamos adicionar um "),o("code",[e._v("or")]),e._v(" na primeira condição e verificar o valor através da função "),o("code",[e._v("integer?")]),e._v(", que retorna "),o("code",[e._v("true")]),e._v(" caso o número seja inteiro.\n\nAgora, se o parâmetro "),o("code",[e._v("n")]),e._v(" for menor que zero "),o("i",[e._v("ou")]),e._v(" não for um valor inteiro, lançaremos uma exceção.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Checagens de número inteiro e positivo",label:"cap04-contrato-2"}},[e._v("\n(import '(java.lang AssertionError))\n\n(defn fatorial [n]\n  (cond (or (< n 0)\n            (not (integer? n))) (throw (AssertionError.))\n        (< n 2)  1\n        :else (* n (fatorial (dec n)))))\n\n(fatorial 3)\n; 6\n\n(fatorial -2)\n; AssertionError\n\n(fatorial 3.5)\n; AssertionError\n")]),e._v("\n\nNosso código funciona, mas está misturando o cálculo do número fatorial com a verificação dos dados. Deveria ter uma forma de deixarmos o código limpo como na listagem "),o("label",{attrs:{entry:"cap04-contrato-0"}}),e._v(", mas verificando se o parâmetro obedece às pré-condições necessárias.\n\n"),o("h3",[e._v("Fazendo do jeito Clojure")]),e._v("\n\nEstamos misturando também classes Java com Clojure, o que poder tornar o código mais verboso e difícil de ler. Além disso, imagine ter que adicionar uma condição extra dentro do seu código toda vez que precisar usar uma pré-condição.\n\nÉ aí que entram as pré-condições, separando as checagens em um espaço só para elas, e o código em outro, como sempre foi.\n\nNo nosso código, vamos adicionar um mapa contendo a chave "),o("code",[e._v(":pre")]),e._v(" antes de começarmos a escrever o código da função. Dentro de "),o("code",[e._v(":pre")]),e._v(" vamos adicionar um vetor contendo as condições a serem verificadas antes mesmo da função ser executada.\n\nO corpo da função só será executado se todas as condições desse vetor forem verdadeiras.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Checagens com pré-condições",label:"cap04-contrato-3"}},[e._v("\n(defn fatorial [n]\n  {:pre [(> n 0) (integer? n)]}\n  (if (< n 2)\n      1\n      (* n (fatorial (dec n)))))\n\n(fatorial 3)\n; 6\n\n(fatorial -2)\n; AssertionError Assert failed: (> n 0)\n\n(fatorial 3.5)\n; AssertionError Assert failed: (integer? n)\n")]),e._v("\n\nAlém de não precisamos importar nenhuma classe do Java para fazer as checagens, nosso código ficou mais limpo e simples de entender.\n\n"),o("h3",[e._v("E as pós-condições?")]),e._v('\n\nJá as pós-condições verificam se o resultado da função está de acordo com as condições informadas. Elas são bem menos utilizadas do que as pré-condições, uma vez que a invariante deve garantir que nosso resultado está de acordo com o esperado. Porém, se nossa função depende de outra para fazer o que precisamos, não podemos garantir que o resultado sairá sempre dentro do esperado.\n\nVamos imaginar que estamos escrevendo uma aplicação para um site de jogos de cartas online.\n\nNessa aplicação vamos precisar de um função responsável por embaralhar as cartas de um maço de cartas qualquer.\n\nVamos escrever uma função que receba um vetor contendo as cartas do baralho e uma outra função que contém o algoritmo de embaralhamento das cartas.\n\nOs responsáveis pelo site levam tão a sério a tarefa de se ter cartas bem embaralhadas que deixaram esse algoritmo a cargo de uma outra empresa formada por diversos ganhadores de prêmios internacionais de matemática.\n\nVamos apenas nos preocupar apenas com a função que recebe o baralho e a função criada por terceiros, e vamos garantir que essa função externa não faça nenhuma besteira, como por exemplo repetir cartas ou sumir com elas.\n\nAí você pergunta: "mas não seria mais fácil a própria função de terceiros verificar se o baralho que entra é o mesmo que sai, só que embaralhado?". Sim, seria. Mas aí eu não conseguiria explicar pós-condições de uma forma interessante.\n\nPrimeiro vamos declarar os quatro naipes do baralho e os treze valores para as cartas:\n\n'),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def naipes [:ouros :copas :paus :espadas])\n\n(def valores [:A :2 :3 :4 :5 :6 :7 :8 :9 :10 :J :Q :K])\n")]),o("index",{attrs:{entry:"for"}}),e._v("\nEm seguida vamos usar a forma  "),o("code",[e._v("for")]),e._v(" para gerar todas as combinações possíveis entre "),o("code",[e._v("naipes")]),e._v(" e "),o("code",[e._v("valores")]),e._v(". Vamos discutir o "),o("code",[e._v("for")]),e._v(" com mais detalhes no capítulo sobre "),o("i",[e._v("lazy evaluation")]),e._v(".\n\nO que precisamos saber aqui é que "),o("code",[e._v("for")]),e._v(" vai receber cada item de "),o("code",[e._v("naipes")]),e._v(" a atribuir a "),o("code",[e._v("n")]),e._v(", fazendo o mesmo com "),o("code",[e._v("valores")]),e._v(" e atribuindo cada um dos itens a "),o("code",[e._v("v")]),e._v(". Com "),o("code",[e._v("n")]),e._v(" e "),o("code",[e._v("v")]),e._v(" em mãos, vamos devolver um vetor contendo os dois valores. No final do processo teremos uma lista contendo todas as combinações possíveis para cartas de baralho. Vamos usar também a função "),o("code",[e._v("sort")]),e._v(" para fornecermos um maço ordenado alfabeticamente para a função.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def baralho (sort (for [n naipes\n                         v valores]\n                     [n v])))\n")]),e._v("\n\nVamos exibir o conteúdo de "),o("code",[e._v("baralho")]),e._v(" para vermos o que o "),o("code",[e._v("for")]),e._v(" retornou:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\nbaralho\n\n; ([:copas :10] [:copas :2] [:copas :3] [:copas :4] [:copas :5]\n; [:copas :6] [:copas :7] [:copas :8] [:copas :9] [:copas :A]\n; [:copas :J] [:copas :K] [:copas :Q] [:espadas :10] [:espadas :2]\n; [:espadas :3] [:espadas :4] [:espadas :5] [:espadas :6]\n; [:espadas :7] [:espadas :8] [:espadas :9] [:espadas :A]\n; [:espadas :J] [:espadas :K] [:espadas :Q] [:ouros :10]\n; [:ouros :2] [:ouros :3] [:ouros :4] [:ouros :5] [:ouros :6]\n; [:ouros :7]  [:ouros :8] [:ouros :9][:ouros :A] [:ouros :J]\n; [:ouros :K] [:ouros :Q] [:paus :10] [:paus :2] [:paus :3]\n; [:paus :4] [:paus :5] [:paus :6] [:paus :7] [:paus :8] [:paus :9]\n; [:paus :A] [:paus :J] [:paus :K] [:paus :Q])\n")]),e._v("\n\nAgora vamos criar uma função chamada "),o("code",[e._v("embaralha")]),e._v(", que recebe como parâmetros a função criada por qualquer outra pessoa e a lista contendo as cartas .\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defn embaralha [fun baralho]\n  (fun baralho))\n")]),e._v("\n\nVemos que a função "),o("code",[e._v("embaralha")]),e._v(" não faz nada de especial. Apenas executa a função contida em "),o("code",[e._v("fun")]),e._v(" usando "),o("code",[e._v("baralho")]),e._v(" como argumento.\n\nExistem duas regras que devemos verificar antes de entregar o resultado da função: o maço embaralhado deve conter exatamente as mesmas cartas que o maço inicial, e após o processo de embaralhamento o maço não pode estar ordenado.\n\nAo usarmos pós-condições, o resultado da função é atribuído ao símbolo "),o("code",[e._v(" % ")]),e._v(".\n\nPara sabermos se o maço inicial contém as mesmas cartas do maço final, basta retirarmos todos os itens repetidos usando a função "),o("code",[e._v("distinct")]),e._v(" e depois ordenar usando "),o("code",[e._v("sort")]),e._v(". No maço de entrada temos certeza de que não existem itens repetidos, mas não podemos ter a mesma certeza a respeito do retorno da função contida em "),o("code",[e._v("fun")]),e._v(".\n\nNossa primeira condição então pode ser escrita como "),o("code",[e._v("(= baralho (sort (distinct %)))")]),e._v(".\n\n"),o("index",{attrs:{entry:"not="}}),e._v("\nSeguindo a segunda condição, o baralho devolvido pela função não pode estar ordenado. Para isso basta verificarmos se "),o("code",[e._v("baralho")]),e._v(" não é igual ao retorno da função, escrevendo a condição "),o("code",[e._v("(not= baralho %)")]),e._v(".\n\nAdicionando essas duas pós-condições na função, teremos nosso código completo na listagem "),o("label",{attrs:{entry:"cap04-contrato-4"}}),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure",title:"Função embaralha com pós-condições",label:"cap04-contrato-4"}},[e._v("\n(def naipes [:ouros :copas :paus :espadas])\n\n(def valores [:A :2 :3 :4 :5 :6 :7 :8 :9 :10 :J :Q :K])\n\n(def baralho (sort (for [n naipes\n                         v valores]\n                     [n v])))\n\n(defn embaralha [fun baralho]\n  {:post [(= baralho (sort (distinct %)))\n          (not= baralho %)]}\n  (fun baralho))\n")]),e._v("\n\nVamos testar se nossa função está fazendo as verificações corretamente e, para isso, vamos criar duas funções. A primeira, que vamos chamar de "),o("code",[e._v("mesma-carta")]),e._v(" recebe um maço e devolve outro com o mesmo tamanho, mas com apenas uma carta repetidamente. Vamos usar a função "),o("code",[e._v("map")]),e._v(" para substituir todas as cartas por um ás de espadas.\n\nA segunda função, que vamos chamar de "),o("code",[e._v("faz-nada")]),e._v(", também recebe um maço e o devolve sem alterações. Com isso poderemos testar se as duas condições estão sendo verificadas corretamente.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Testando as pós-condições",label:"cap04-contrato-5"}},[e._v("\n(defn mesma-carta [baralho]\n  (map (fn [carta] [:as :espadas]) baralho))\n\n(defn faz-nada [baralho]\n  baralho)\n\n(embaralha mesma-carta baralho)\n; AssertionError Assert failed: (= baralho (sort (distinct %)))\n\n(embaralha faz-nada baralho)\n; AssertionError Assert failed: (not= baralho %)\n")]),o("index",{attrs:{entry:"shuffle"}}),e._v("\nNossas pós-condições estão funcionando corretamente. Mas e como fazemos para testar se a função está fazendo o que queremos? Para isso vamos usar a função "),o("code",[e._v("shuffle")]),e._v(", do próprio Clojure, que recebe uma sequência como parâmetro e a devolve embaralhada. Exatamente o que queríamos lá no início do exemplo.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(embaralha shuffle baralho)\n\n; [[:espadas :A] [:paus :J] [:copas :4] [:espadas :4] [:ouros :6]\n; ...mais cartas...\n; [:copas :K] [:espadas :5] [:espadas :2]]\n")]),e._v("\n\nComo vimos, contratos são úteis para verificarmos se as condições necessárias para a execução do nosso código estão sendo atendidas e se o retorno está dentro do que esperamos.\n\n"),o("h2",[e._v("4.9. Destructuring")]),o("index",{attrs:{entry:"destructuring"}}),o("i",[e._v("Destructuring")]),e._v(" é uma forma de decompor uma estrutura em uma atribuição, permitindo que você utilize somente as informações que forem relevantes.\n\nVocê pode usar "),o("i",[e._v("destructuring")]),e._v(" ao declarar a lista de argumentos de uma função ou durante as atribuições de um escopo local. É possível usar "),o("i",[e._v("destructuring")]),e._v(" também em macros que se baseiem em "),o("code",[e._v("fn")]),e._v(" ou "),o("code",[e._v("let")]),e._v(".\n\n"),o("box",{attrs:{title:"Qual a tradução de destructuring?"}},[e._v("\n\nO termo "),o("i",[e._v("destructuring")]),e._v(' não tem uma boa tradução para o nosso contexto. Ao pé da letra, pode ser traduzido por "'),o("i",[e._v("desestruturação")]),e._v('", mas o termo em português pode levar a uma compreensão errada. Podemos entender '),o("i",[e._v("destructuring")]),e._v(" como uma "),o("i",[e._v("desmontagem")]),e._v(" da coleção que foi usada como argumento.\n\nComo atualmente quase toda a literatura sobre Clojure está em inglês, vamos nos ater ao termo original e evitar uma tradução forçada e incorreta.\n")]),e._v("\n\nExistem duas formas de trabalhar com "),o("i",[e._v("destructuring")]),e._v(": "),o("i",[e._v("vector destructuring")]),e._v(" e "),o("i",[e._v("map destructuring")]),e._v(". As duas formas cobrem boa parte das estruturas de dados mais comuns na linguagem: listas, arrays e mapas.\n\nNão se preocupe em entender as diferenças entre listas e arrays nesse momento. Entraremos em detalhes sobre essas estruturas no próximo capítulo.\n\n"),o("h3",[e._v("Vector destructuring")]),o("index",{attrs:{entry:"destructuring, vector"}}),e._v("\n\nO caso mais simples de "),o("i",[e._v("destructuring")]),e._v(" envolve o uso de "),o("i",[e._v("vector")]),e._v(", que é o nome em Clojure para arrays ou vetores.\n\nVamos imaginar que temos um ponto num plano cartesiano e que precisamos imprimir na tela as coordenadas, dizendo qual o valor de "),o("i",[e._v("x")]),e._v(" e qual o valor de "),o("i",[e._v("y")]),e._v(".\n\nPelo que aprendemos até agora, sabendo que um ponto pode ser representado como um array de duas posições, nosso código ficaria assim:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def ponto [10 20])\n\n(defn mostre-coordenadas [p]\n  (let [x (first p)\n        y (nth p 1)]\n    (println "Coordenadas x:" x "y:" y)))\n\n(mostre-coordenadas ponto)\n; Coordenadas x: 10 y: 20\n')]),e._v("\n\nUsando "),o("i",[e._v("destructuring")]),e._v(", vamos substituir o "),o("code",[e._v("p")]),e._v(" da lista de argumentos por um array de duas posições, que vamos chamar de "),o("code",[e._v("x")]),e._v(" e "),o("code",[e._v("y")]),e._v(", respectivamente:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def ponto [10 20])\n\n(defn mostre-coordenadas [[x y]]\n  (println "Coordenadas x:" x "y:" y))\n\n(mostre-coordenadas ponto)\n; Coordenadas x: 10 y: 20\n')]),o("box",{attrs:{title:"Atenção aos colchetes duplos"}},[e._v("\nPreste atenção nos dois colchetes para abrir e nos dois para fechar. Estamos dizendo para o compilador pegar um array, jogar o primeiro item em "),o("code",[e._v("x")]),e._v(" e o segundo em "),o("code",[e._v("y")]),e._v(". Se você esquecer dos colchetes extras, o compilador vai entender que você precisa passar dois parâmetros para a função e vai dar erro ao tentar executá-la passando apenas "),o("code",[e._v("ponto")]),e._v(".\n\nNo exemplo abaixo mostramos um código errado, para que você saiba o que acontece quando a lista de parâmetros é declarada de modo errado e que mensagem aparece. Note que no exemplo errado nós estamos usando apenas um par de colchetes, indicando que a função espera receber dois parâmetros:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def ponto [10 20])\n\n(defn mostre-erro [x y]\n  (println "Coordenadas x:" x "y:" y))\n\n(mostre-erro ponto)\n; clojure.lang.ArityException: Wrong number of args (1)\n; passed to: user$mostre-erro\n')]),e._v("\n\nAgora você já sabe. Se estiver tentando usar "),o("i",[e._v("destructuring")]),e._v(" e esse erro aparecer, verifique se você não esqueceu dos colchetes extras.\n")],1),e._v("\n\nVocê pode utilizar também o recurso de aridade variável com "),o("i",[e._v("destructuring")]),e._v(". Vamos criar uma função que receba uma lista de atletas que participaram de uma corrida, em ordem de chegada, mas só dê importância aos três primeiros, que são os que receberão as medalhas. Os nomes dos outros atletas ficarão em uma lista chamada "),o("code",[e._v("outros")]),e._v(".\n\nPerceba que o tempo todo estamos usando dois colchetes para abrir e dois para fechar:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def resultado-100m ["Usain Bolt" "Yohan Blake"\n                     "Justin Gatlin" "Tyson Gay"\n                     "Ryan Bailey" "Churandy Martina"\n                     "Richard Thompson" "Asafa Powell"])\n\n(defn podio [[primeiro segundo terceiro & outros]]\n  (println "100m rasos - Londres 2012")\n  (println "Ouro: " primeiro)\n  (println "Prata: " segundo)\n  (println "Bronze: " terceiro)\n  (println "E mais" (count outros) "atletas"))\n\n(podio resultado-100m)\n; 100m rasos - Londres 2012\n; Ouro:  Usain Bolt\n; Prata:  Yohan Blake\n; Bronze:  Justin Gatlin\n; E mais 5 atletas\n')]),o("index",{attrs:{entry:":as"}}),e._v("\nImagine agora que você queira ter acesso à lista completa de atletas que foi passada como argumento para a função "),o("code",[e._v("podio")]),e._v(". Para isso existe um símbolo especial "),o("code",[e._v(":as")]),e._v(". Vamos criar uma função "),o("code",[e._v("vencedor")]),e._v(" que nos mostra quem ganhou e quantos atletas participaram.\n\nA lista completa de atletas ficará armazenada em "),o("code",[e._v("todos")]),e._v(", enquanto "),o("code",[e._v("primeiro")]),e._v(" guarda apenas o primeiro item, como já vimos. A vírgula entre "),o("code",[e._v("primeiro")]),e._v(" e "),o("code",[e._v(":as todos")]),e._v(" é opcional, como sempre acontece em Clojure. Eu preferi colocar simplesmente para deixar claro que são coisas diferentes. Você decide se prefere usar ou não.\n\nVamos ao código:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn vencedor [[primeiro, :as todos]]\n  (println "Vencedor:" primeiro)\n  (println "participaram" (count todos) "atletas"))\n\n(vencedor resultado-100m)\n')]),e._v("\n\nComo já dissemos, o uso de "),o("i",[e._v("destructuring")]),e._v(" pode ser usado com "),o("code",[e._v("let")]),e._v(" também, de forma similar à que usamos na criação de funções.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def ponto [10 20])\n\n(defn mostre-coordenadas [ponto]\n  (let [[x y] ponto]\n    (println "Coordenadas x:" x "y:" y)))\n; Coordenadas x: 10 y: 20\n\n(mostre-coordenadas ponto)\n')]),e._v("\n\nComo você deve imaginar, é possível também utilizar aridade variável com "),o("i",[e._v("destructuring")]),e._v(" no let, da mesma forma que utilizamos anteriormente na declaração da função "),o("code",[e._v("podio")]),e._v(".\n\nVamos criar uma função chamada "),o("code",[e._v("vencedor")]),e._v(" para exemplificar o uso:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def resultado-100m ["Usain Bolt" "Yohan Blake"\n                     "Justin Gatlin" "Tyson Gay"\n                     "Ryan Bailey" "Churandy Martina"\n                     "Richard Thompson" "Asafa Powell"])\n\n(defn vencedor [atletas]\n  (let [[primeiro & outros] atletas]\n    (println "100m rasos - Londres 2012")\n    (println "Vencedor: " primeiro)\n    (println "E mais" (count outros) "atletas")))\n\n(vencedor resultado-100m)\n; 100m rasos - Londres 2012\n; Vencedor:  Usain Bolt\n; E mais 7 atletas\n')]),e._v("\n\nO uso explícito de destructuring com "),o("code",[e._v("let")]),e._v(" é bem menos comum, mas é uma ferramenta poderosa quando usada dentro de macros. Internamente a macro "),o("code",[e._v("fn")]),e._v(" faz uso de destructuring com "),o("code",[e._v("let")]),e._v(" para poder tratar os argumentos da função que está sendo criada.\n\nComo "),o("i",[e._v("strings")]),e._v(" são tratadas como sequências de caracteres em Clojure, também podemos usar "),o("i",[e._v("destructuring")]),e._v(" com textos:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn tres-letras [[a b c]]\n  (println a b c))\n\n(tres-letras "cavalo")\n; c a v\n')]),o("h3",[e._v("Map destructuring")]),o("index",{attrs:{entry:"destructuring, map"}}),e._v("\n\nA segunda forma de "),o("i",[e._v("destructuring")]),e._v(" é através de "),o("i",[e._v("mapas")]),e._v(", "),o("i",[e._v("hashes")]),e._v(" ou "),o("i",[e._v("tuplas")]),e._v(".\n\nUm mapa em Clojure segue a convenção "),o("code",[e._v("{:chave valor}")]),e._v(" e se parece muito com um "),o("i",[e._v("Hash")]),e._v(" encontrado em Ruby ou JavaScript.\n\nPara acessarmos um item de um mapa, informamos o nome do mapa como se fosse uma função e, sem seguida, a chave que queremos como se fosse um parâmetro da função.\n\nPara exemplificar, vamos criar um mapa chamado "),o("code",[e._v("info-livro")]),e._v(", que contém os dados de um livro. Esse mapa será usado nos nossos próximos exemplos, então vou evitar de repetí-lo:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def info-livro\n  {:titulo "Livro de Clojure"\n   :autor "Plínio Balduino"\n   :capitulos {:capitulo01 "Apresentação"\n               :capitulo02 "Uma introdução gentil ao Clojure"}})\n')]),o("index",{attrs:{entry:"str"}}),e._v("\n\nVamos criar uma função chamada "),o("code",[e._v("descricao")]),e._v(", que recebe esse mapa e exibe o autor e o título do livro. Aqui vamos usar a função "),o("code",[e._v("str")]),e._v(" para concatenar "),o("i",[e._v("strings")]),e._v(":\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn descricao [livro]\n  (str "O autor de " (livro :titulo) " é " (livro :autor)))\n\n(descricao info-livro)\n; "O autor de Livro de Clojure é Plínio Balduino"\n')]),e._v("\n\nPerceba que "),o("code",[e._v("livro")]),e._v(" é repetido duas vezes em uma mesma linha. Se quiséssemos exibir três ou quatro informações, teríamos que repetí-lo tantas vezes quantas forem necessárias.\n\nUsando "),o("i",[e._v("destructuring")]),e._v(", nosso código pode ficar um pouco mais limpo. Novamente, estou usando a vírgula apenas para deixar claro que "),o("code",[e._v("titulo")]),e._v(" e "),o("code",[e._v("autor")]),e._v(" são coisas distintas e fica a seu crítério usá-la ou não.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn descricao [{titulo :titulo, autor :autor}]\n  (str "O autor de " titulo " é " autor))\n\n(descricao info-livro)\n; "O autor de Livro de Clojure é Plínio Balduino"\n')]),o("box",{attrs:{title:"To vírgula or not to vírgula"}},[e._v("\nOutra forma de deixar o código mais legível, sem apelar para o uso de vírgulas, é quebrando a linha e mantendo os símbolos alinhados.\n\nDessa forma, nossa função ficaria assim:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn descricao [{titulo :titulo\n                  autor  :autor}]\n  (str "O autor de " titulo " é " autor))\n')]),e._v("\n\nFica a seu critério, ou da sua equipe, decidir qual forma é melhor.\n")],1),e._v("\n\nNo nosso mapa "),o("code",[e._v("info-livro")]),e._v(" existe um mapa contendo os nomes dos capítulos.\n\nSe quisermos exibir o nome do segundo capítulo da forma convencional, teríamos que acessar o valor da chave "),o("code",[e._v(":capitulos")]),e._v(" para retornar um mapa e, a partir desse valor, acessar a chave "),o("code",[e._v(":capitulo02")]),e._v(" para finalmente termos o texto que queremos:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn segundo-capitulo [livro]\n  (str "O segundo capítulo chama-se "\n       ((livro :capitulos) :capitulo02)))\n; "O segundo capítulo chama-se Uma introdução gentil ao Clojure"\n')]),o("index",{attrs:{entry:":keys"}}),e._v("\nExiste uma forma de se utilizar "),o("i",[e._v("destructuring")]),e._v(" com mapas aninhados. Para isso vamos fazer uso do símbolo "),o("code",[e._v(":keys")]),e._v(":\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn segundo-capitulo [{{:keys [capitulo02]} :capitulos}]\n  (str "O segundo capítulo chama-se " capitulo02))\n\n(segundo-capitulo info-livro)\n; "O segundo capítulo chama-se Uma introdução gentil ao Clojure"\n')]),e._v("\n\nExplicando esse código, fizemos com que o valor contido na chave "),o("code",[e._v(":capitulo02")]),e._v(", que está dentro do valor contido na chave "),o("code",[e._v(":capitulos")]),e._v(", seja retornado em "),o("code",[e._v("capitulo02")]),e._v(".\n\n"),o("index",{attrs:{entry:":strs"}}),o("index",{attrs:{entry:":syms"}}),e._v("\nCaso as chaves do mapa forem do tipo "),o("i",[e._v("String")]),e._v(" ao invés de um "),o("i",[e._v("keyword")]),e._v(", podemos usar "),o("code",[e._v(":strs")]),e._v(" no lugar de "),o("code",[e._v(":keys")]),e._v(". Da mesma forma, caso sejam símbolos, usaremos "),o("code",[e._v(":syms")]),e._v(" ao invés de "),o("code",[e._v(":keys")]),e._v(".\n\n"),o("index",{attrs:{entry:":as"}}),e._v("\nAssim como já acontece quando usamos "),o("i",[e._v("destructuring")]),e._v(" com sequências, podemos usar também o recurso "),o("code",[e._v(":as")]),e._v(" para armazenarmos o mapa inteiro.\n\nVamos criar uma função chamada "),o("code",[e._v("detalhes")]),e._v(", que exibe o título e todas as informações disponíveis sobre o livro:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn detalhes [{titulo :titulo\n                 :as livro}]\n  (str "Dados do livro " titulo ": " livro))\n\n(detalhes info-livro)\n; "Dados do livro Livro de Clojure: {:titulo \\"Livro de Clojure\\\n; ", :autor \\"Plínio Balduino\\", :capitulos {:capitulo01 \\"Apres\n; entação\\",  :capitulo02 \\"Uma introdução gentil ao Clojure\\"}"\n')]),o("index",{attrs:{entry:":or"}}),e._v("\nUm recurso muito interessante, especialmente quando formos tratar de configurações, é o símbolo "),o("code",[e._v(":or")]),e._v(", que é usado para definir valores padrão.\n\nVamos imaginar que nossa aplicação receba um mapa contendo a configuração, mas todos os itens são opcionais. A aplicação trabalharia de uma forma conhecida por padrão, mas você pode alterar apenas o que for relevante, evitando ter que repetir todas as configurações o tempo todo. Essa abordagem é chamada de "),o("i",[e._v("convention over configuration")]),e._v(".\n\nContinuando o exercício de imaginação, vamos considerar que nossa aplicação roda em um browser, que por padrão vai ficar disponível apenas localmente, e que usa a porta 3000. Vamos dizer também que a aplicação usa um banco de dados MySQL como padrão.\n\nVamos criar uma função chamada "),o("code",[e._v("iniciar")]),e._v(", que recebe um mapa contendo as configurações que você quiser alterar, ou um mapa vazio se você quiser usar as configurações padrão.\n\nPara mantermos o foco, essa função "),o("code",[e._v("iniciar")]),e._v(" vai apenas exibir as configurações com as quais a aplicação seria iniciada.\n\n"),o("index",{attrs:{entry:":keys"}}),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn iniciar [{:keys [ip porta db]\n                :or {ip "127.0.0.1"\n                     porta 3000\n                     db "mysql"}}]\n  (println "ip:" ip "porta:" porta "db:" db))\n\n(iniciar {})\n; ip: 127.0.0.1 porta: 3000 db: mysql\n\n(iniciar {:ip "0.0.0.0"})\n; ip: 0.0.0.0 porta: 3000 db: mysql\n\n(iniciar {:porta 80})\n; ip: 127.0.0.1 porta: 80 db: mysql\n\n(iniciar {:db "oracle"})\n; ip: 127.0.0.1 porta: 3000 db: oracle\n\n(iniciar {:db "mssql" :porta 8080})\n; ip: 127.0.0.1 porta: 8080 db: mssql\n')]),e._v("\n\nFinalmente, existe uma forma de usarmos "),o("i",[e._v("destructuring")]),e._v(" que mistura o que vimos na manipulação de sequências com o que vimos na manipulação de mapas.\n\nCom essa forma podemos acessar diretamente um elemento de uma sequência sem que precisemos declarar todos os itens anteriores.\n\nPor exemplo, se quisermos apenas os terceiro e quinto atletas da nossa lista, podemos utilizar a forma associativa, informando a posição dos itens que queremos, lembrando que o primeiro item de uma sequência fica na posição "),o("i",[e._v("0")]),e._v(":\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn terceiro-quinto [{terceiro 2, quinto 4}]\n  (println terceiro "chegou em terceiro")\n  (println quinto "chegou em quinto"))\n\n(terceiro-quinto resultado-100m)\n; Justin Gatlin chegou em terceiro\n; Ryan Bailey chegou em quinto\n')]),e._v("\n\nA forma associativa também pode ser aplicado a "),o("i",[e._v("strings")]),e._v(", selecionando diretamente a letra que queremos. Vamos pegar a terceira letra de uma palavra qualquer:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(let [{terceira-letra 2} "cavalo"]\n  (println terceira-letra))\n; v\n')]),e._v("\n\nVimos que "),o("i",[e._v("destructuring")]),e._v(" é um recurso muito interessante para simplificar nosso código. Alguns autores"),o("bib",{attrs:{entry:"joy-of-clojure"}}),e._v(" inclusive dizem que "),o("i",[e._v("destructuring é uma mini linguagem embutida no Clojure")]),e._v(". Pratique bastante, escreva exemplos e aprenda quando seu uso pode ajudar e quando ele pode trazer apenas complicação.\n\n"),o("h2",[e._v("4.10. Usando recursão")]),e._v("\n\nRecursão acontece quando uma determinada função invoca ela própria para conseguir chegar a um resultado.\n\nEm linguagens funcionais, que fazem uso constante de imutabilidade, como é o caso do Clojure, a recursão se torna a forma encontrada para iterar uma sequência ou simular um "),o("i",[e._v("loop")]),e._v(".\n\n"),o("box",{attrs:{title:"Iterar"}},[o("i",[e._v("Iterar")]),e._v(" é o mesmo que repetir uma ação. Quando usamos um "),o("code",[e._v("for")]),e._v(" ou um "),o("code",[e._v("while")]),e._v(", no JavaScript e linguagens similares, estamos iterando, repetindo, algum processamento até que cheguemos a um resultado.\n")]),e._v("\n\nUma função recursiva deve ter, sempre que possível, uma condição de saída, para que você não entre em um "),o("i",[e._v("loop infinito")]),e._v(" acidentalmente ou estoure a pilha de chamadas rapidamente.\n\nUma condição de saída é um desvio que faz com que a recursão seja finalizada.\n\nPor exemplo, na listagem "),o("label",{attrs:{entry:"cap04-recur-1"}}),e._v(" vamos escrever uma função simples, que conte de qualquer número inteiro positivo até zero sem informar uma condição de saída.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Recursão desastrosa",label:"cap04-recur-1"}},[e._v("\n(defn conta-ate-zero [num]\n  (println num)\n  (conta-ate-zero (dec num)))\n\n(conta-ate-zero 3)\n; 3\n; 2\n; 1\n; 0\n; -1\n; ...\n; -5964\n; -5965\n; StackOverflowError   clojure.walk/stringify-keys/fn--6998\n")]),o("index",{attrs:{entry:"dec"}}),e._v("\n\nA função "),o("code",[e._v("dec")]),e._v(" retorna o "),o("i",[e._v("decremento")]),e._v(" de um número. "),o("code",[e._v("(dec 10)")]),e._v(" é equivalente a escrever "),o("code",[e._v("(- 10 1)")]),e._v(".\n\nAlém da função não ter parado no zero, ela ainda estourou a pilha de chamadas da JVM. Na listagem "),o("label",{attrs:{entry:"cap04-recur-2"}}),e._v(" Vamos então adicionar uma condição de parada usando "),o("code",[e._v("when")]),e._v(", que é uma forma idiomática de usarmos um "),o("code",[e._v("if")]),e._v(" que não faz nada caso a condição não seja satisfeita.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Recusão com condição de parada",label:"cap04-recur-2"}},[e._v("\n(defn conta-ate-zero [num]\n  (println num)\n  (when (> num 0)\n        (conta-ate-zero (dec num))))\n\n(conta-ate-zero 3)\n; 3\n; 2\n; 1\n; 0\n")]),e._v("\n\nAo iterarmos uma sequência, dizemos que estamos consumindo-a, pois ela vai ficando menor a cada recursão, até que finalmente termine de ser processada.\n\nNa listagem "),o("label",{attrs:{entry:"cap04-recur-3"}}),e._v(" vamos demonstrar uma função que recebe um texto qualquer e imprime uma letra por vez. Para isso essa função deve "),o("i",[e._v("consumir a sequência de letras")]),e._v(", e parar quando não houverem mais letras para imprimir.\n\nPara consumir corretamente o texto, que é tratado como uma sequência de caracteres, vamos usar a função "),o("code",[e._v("first")]),e._v(" para pegar a primeira letra, que é a que vamos imprimir, e a função "),o("code",[e._v("rest")]),e._v(", que retorna uma cópia da sequência sem o primeiro item, ou uma lista vazia se não houver mais o que consumir. Ao usarmos isso com a palavra "),o("i",[e._v("recursão")]),e._v(", por exemplo, teremos "),o("i",[e._v("r")]),e._v(" como a primeira letra e "),o("i",[e._v("ecursão")]),e._v(" como o resto da sequência.\n\nA função "),o("code",[e._v("rest")]),e._v(" retorna uma sequência vazia caso não existam mais letras para retornar.\n\nJá a função "),o("code",[e._v("seq")]),e._v(" retorna "),o("code",[e._v("nil")]),e._v(" caso o parâmetro passado seja uma sequência vazia. Como "),o("code",[e._v("when nil")]),e._v(" é equivalente a "),o("code",[e._v("when false")]),e._v(", a nossa condição de parada acontecerá quando não tivermos mais letra para imprimir. Essa técnica é chamada de "),o("i",[e._v("nil punning")]),e._v(", sem nenhuma tradução decente para o português.\n\nAlém de imprimir a primeira letra de cada iteração, vamos mostrar também o resto da sequência, que será passado como parâmetro para a próxima iteração, e o resultado do "),o("i",[e._v("nil punning")]),e._v(" na última iteração. Isso vai ajudar a demonstrar passo a passo o que acontece, para que você não fique perdido e jogue o livro na parede.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Consumindo uma sequência",label:"cap04-recur-3"}},[e._v('\n(defn imprime-letra [texto]\n  (let [letra (first texto)\n        resto (rest texto)]\n    (println "letra =" letra\n             "- resto =" resto\n             "- (seq resto) =" (seq resto))\n    (when (seq resto)\n      (imprime-letra resto))))\n\n(imprime-letra "recursão")\n; letra = r - resto = (e c u r s ã o) - (seq resto) = (e c u r s ã o)\n; letra = e - resto = (c u r s ã o) - (seq resto) = (c u r s ã o)\n; letra = c - resto = (u r s ã o) - (seq resto) = (u r s ã o)\n; letra = u - resto = (r s ã o) - (seq resto) = (r s ã o)\n; letra = r - resto = (s ã o) - (seq resto) = (s ã o)\n; letra = s - resto = (ã o) - (seq resto) = (ã o)\n; letra = ã - resto = (o) - (seq resto) = (o)\n; letra = o - resto = () - (seq resto) = nil\n')]),e._v("\n\nTemos nossa função recursiva funcionando, mas e se recebermos um texto muito grande?\n\nA cada iteração, consumimos uma posição na pilha de chamadas da JVM. Como sabemos, essa pilha tem um tamanho limitado e, mesmo existindo formas de configurar a JVM para que esse tamanho seja ampliado, a pilha continuará tendo um tamanho finito.\n\n"),o("h3",[e._v("Tail call optimization, ou quase")]),e._v("\n\nFelizmente, o cientista Guy Steele Jr, que participou da criação do Java e da linguagem Scheme, publicou um artigo"),o("bib",{attrs:{entry:"ultimate-goto"}}),e._v(" descrevendo uma técnica que se tornou conhecida por "),o("i",[e._v("tail call optimization")]),e._v(".\n\n"),o("i",[e._v("Tail call")]),e._v(" é o nome dado à última chamada dentro de uma função (listagem "),o("label",{attrs:{entry:"cap04-recur-4"}}),e._v("). Quando essa última chamada invoca a própria função (listagem "),o("label",{attrs:{entry:"cap04-recur-5"}}),e._v("), e não há mais nada a ser processado após isso, ela é chamada de "),o("i",[e._v("tail call recursion")]),e._v(".\n\n"),o("snippet",{attrs:{language:"javascript",title:"A chamada à função limpar é o tail call",label:"cap04-recur-4"}},[e._v("\nfunction processaDados( ) {\n  // código da função\n  limpar();\n}\n")]),o("snippet",{attrs:{language:"javascript",title:"Exemplo de tail call recursion",label:"cap04-recur-5"}},[e._v("\nfunction imprimeLetra(texto) {\n  // código da função\n  imprimeLetra(resto);\n}\n")]),e._v("\n\nEm algumas linguagens, como é o caso do Scheme, o compilador verifica se a "),o("i",[e._v("tail call")]),e._v(" faz uma chamada recursiva e otimiza o código compilado, fazendo com que a chamada não consuma espaço na pilha e permitindo assim que o código utilize recursão indefinidamente, sem o risco de causar um estouro de pilha. Essa otimização é chamada de "),o("i",[e._v("tail call optimization")]),e._v(".\n\n"),o("index",{attrs:{entry:"recur"}}),e._v("\n\nInfelizmente, a JVM não dá suporte a esse tipo de otimização. Felizmente, os desenvolvedores do Clojure deram um jeito de imitar "),o("i",[e._v("tail call optimization")]),e._v(" através da forma especial "),o("code",[e._v("recur")]),e._v(".\n\nPara reescrevermos nossa função "),o("code",[e._v("imprime-letra")]),e._v(' usando a "quase '),o("i",[e._v("tail call optimization")]),e._v('", basta fazer com que, ao invés de executarmos '),o("code",[e._v("(imprime-letra resto)")]),e._v(" no final da função, executemos "),o("code",[e._v("(recur resto)")]),e._v(", e o compilador vai se encarregar de gerar um bytecode parecido com o que seria gerado caso a JVM suportasse esse tipo de otimização.\n\nPerceba que na listagem "),o("label",{attrs:{entry:"cap04-recur-6"}}),e._v(", o código fica praticamente igual ao original, mas agora não corremos mais o risco de estourar a pilha de chamadas.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Usando tail call optimization com recur",label:"cap04-recur-6"}},[e._v('\n(defn imprime-letra [texto]\n  (let [letra (first texto)\n        resto (rest texto)]\n    (println "letra =" letra\n             "- resto =" resto\n             "- (seq resto) =" (seq resto))\n    (when (seq resto)\n      (recur resto))))\n\n(imprime-letra "recursão")\n; letra = r - resto = (e c u r s ã o) - (seq resto) = (e c u r s ã o)\n; letra = e - resto = (c u r s ã o) - (seq resto) = (c u r s ã o)\n; letra = c - resto = (u r s ã o) - (seq resto) = (u r s ã o)\n; letra = u - resto = (r s ã o) - (seq resto) = (r s ã o)\n; letra = r - resto = (s ã o) - (seq resto) = (s ã o)\n; letra = s - resto = (ã o) - (seq resto) = (ã o)\n; letra = ã - resto = (o) - (seq resto) = (o)\n; letra = o - resto = () - (seq resto) = nil\n')]),e._v("\n\nInternamente, a forma "),o("code",[e._v("recur")]),e._v(" transforma a chamada recursiva de função em um "),o("i",[e._v("loop")]),e._v(", equivalente ao "),o("code",[e._v("while")]),e._v(" do Java, fazendo com que o seu código itere sem consumir a pilha de chamadas. É uma malandragem criticada pelos usuários de dialetos mais antigos de LISP, mas que não atrapalha em nada a forma como o seu código vai funcionar. Levando em conta as limitações da JVM, podemos considerar que foi uma solução bem elegante.\n\nAgora que sabemos como escrever funções recursivas que não estourem a pilha de chamadas, vamos avançar mais um pouco.\n\nVamos escrever uma função que receba um texto e nos retorne a quantidade de vogais que ele contém.\n\n"),o("h3",[e._v("Entendendo loop passo a passo")]),e._v("\n\nPrimeiro vamos precisar diferenciar o que é uma vogal e o que é qualquer outro caracter. Vamos usar as propriedades de uma estrutura de dados chamada "),o("i",[e._v("set")]),e._v(" para facilitar a nossa vida. Vamos ver essa estrutura com mais detalhes no próximo capítulo.\n\nNa listagem "),o("label",{attrs:{entry:"cap04-recur-7"}}),e._v(", vamos criar um "),o("i",[e._v("set")]),e._v(" chamado "),o("code",[e._v("vogal?")]),e._v(", contendo as vogais do nosso alfabeto. Esse "),o("i",[e._v("set")]),e._v(" recebe um caracter e retorna "),o("code",[e._v("nil")]),e._v(" caso não seja uma vogal, ou a própria vogal, caso seja.\n\nLembrando do que vimos sobre "),o("i",[e._v("nil punning")]),e._v(", sabemos que "),o("code",[e._v("nil")]),e._v(" é equivalente a "),o("code",[e._v("false")]),e._v(" quando estamos avaliando uma condição.\n\nIsso significa que, se você passar uma vogal para "),o("code",[e._v("vogal?")]),e._v(", receberá um resultado "),o("i",[e._v("equivalente a "),o("code",[e._v("true")])]),e._v(" e, se passar qualquer outro valor, receberá um resultado "),o("i",[e._v("equivalente a "),o("code",[e._v("false")])]),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure",title:"Código que nos diz se é vogal ou não",label:"cap04-recur-7"}},[e._v('\n(def vogal? (set "aeiouAEIOU"))\n\n(vogal? \\a)\n; \\a\n\n(vogal? \\c)\n; nil\n')]),e._v("\n\nUm caracter em Clojure é escrito com o caracter "),o("code",[e._v("\\")]),e._v(" seguido do caracter propriamente dito. A letra "),o("i",[e._v("a")]),e._v(", por exemplo, é escrita como "),o("code",[e._v("\\a")]),e._v(".\n\nUsando o que já sabemos, vamos criar uma função chamada "),o("code",[e._v("conta-vogais")]),e._v(". Nessa função vamos consumir o texto que recebermos por parâmetro e também acumular a quantidade de variáveis conforme elas forem encontradas em cada iteração.\n\nVocê já deve ter percebido que, no exemplo anterior, a forma "),o("code",[e._v("recur")]),e._v(" recebeu exatamente a mesma quantidade de parâmetros da função. Isso acontece porque, basicamente, "),o("code",[e._v("recur")]),e._v(" faz uma chamada à função atual, só que sem consumir a pilha de chamadas.\n\nPara contar a quantidade de vogais de um texto, precisaremos usar dois "),o("i",[e._v("bindings")]),e._v(", sendo um para a quantidade de vogais propriamente dita e outro contendo a sequência de caracteres que está sendo consumida.\n\nEntão podemos pensar em começar a nossa função "),o("code",[e._v("conta-vogais")]),e._v(" usando dois parâmetros: "),o("code",[e._v("vogais")]),e._v(" e "),o("code",[e._v("texto")]),e._v(":\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defn conta-vogais [vogais texto]\n  (if (seq texto)\n      (recur\n    ; continua\n")]),e._v("\n\nNote que usamos "),o("i",[e._v("nil punning")]),e._v(" no "),o("code",[e._v("if")]),e._v(". É uma técnica tão comum que poderíamos dizer até que "),o("i",[e._v("nil punning")]),e._v(" é um "),o("i",[e._v("design pattern")]),e._v(" funcional. Note também que abrimos os parênteses, mas não fechamos. Fizemos assim porque os códigos a seguir vão se encaixando até formarmos o código todo.\n\nAgora vamos verificar se o primeiro caracter que estamos recebendo é uma vogal. Se for, incrementaremos o valor de "),o("code",[e._v("vogais")]),e._v(". Caso contrário, ele continuará igual. Se nosso texto não tiver nenhuma vogal, passaremos "),o("i",[e._v("0")]),e._v(" em cada uma das iterações e, no final, teremos zero vogais encontradas no texto.\n\nVamos usar o "),o("code",[e._v("if")]),e._v(", que recebe três parâmetros. O primeiro é uma condição, o segundo contém a expressão a ser avaliada caso a expressão seja verdadeira, e a terceira contém a expressão a ser avaliada caso a expressão seja falsa. Pense que em Clojure até o "),o("code",[e._v("if")]),e._v(" tem jeitão de função.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n      (if (vogal? (first texto))\n                  (inc vogais)\n                  vogais)\n")]),e._v("\n\nO segundo parâmetro a ser usado pelo "),o("code",[e._v("recur")]),e._v(" é o resto da sequência, sem o primeiro caracter. Como já verificamos se o primeiro caracter é ou não uma vogal, não vamos mais precisar dele.\n\nFinalmente, caso não tenhamos mais letras para verificar, vamos fazer a função retornar apenas o número de vogais que encontramos, que é o nosso objetivo desde o início.\n\nO código completo da função ficaria assim:\n\n"),o("snippet",{attrs:{language:"clojure",title:"Primeira versão do contador de vogais",label:"cap04-recur-8"}},[e._v('\n(defn conta-vogais [vogais texto]\n  (if (seq texto)\n      (recur (if (vogal? (first texto))\n                 (inc vogais)\n                 vogais)\n             (rest texto))\n       vogais))\n\n(conta-vogais 0 "Livro de Clojure")\n; 6\n')]),e._v("\n\nNossa função está funcionando e contando as vogais corretamente, mas temos um grande problema aqui: somos obrigados a informar esse "),o("i",[e._v("0")]),e._v(" como parâmetro toda vez que quisermos usar a função. Para piorar a situação, se o usuário usar qualquer outro número, a função vai devolver um valor incorreto.\n\nTemos aqui um caso clássico de design horrível.\n\nVamos então renomear a função "),o("code",[e._v("conta-vogais")]),e._v(" para "),o("code",[e._v("contador-auxiliar")]),e._v(" e criar uma nova função chamada "),o("code",[e._v("conta-vogais")]),e._v(" que chama a nossa função original com o "),o("i",[e._v("0")]),e._v(" problemático:\n\n"),o("snippet",{attrs:{language:"clojure",title:"Segunda versão do contador de vogais",label:"cap04-recur-9"}},[e._v('\n(defn acumulador-auxiliar [vogais texto]\n  (if (seq texto)\n      (recur (if (vogal? (first texto))\n                 (inc vogais)\n                 vogais)\n             (rest texto))\n       vogais))\n\n(defn conta-vogais [texto]\n  (acumulador-auxiliar 0 texto))\n\n(conta-vogais "Livro de Clojure")\n; 6\n')]),e._v("\n\nO código da listagem "),o("label",{attrs:{entry:"cap04-recur-9"}}),e._v(" já está melhor, evitando que o usuário tenha que informar o valor "),o("i",[e._v("0")]),e._v(" como parâmetro toda vez, mas ainda tem que melhorar.\n\nAgora temos duas funções, sendo "),o("code",[e._v("conta-vogais")]),e._v(" que recebe apenas um texto e nos retorna a quantidade de vogais, exatamente como queremos, e uma função chamada "),o("code",[e._v("acumulador-auxiliar")]),e._v(", que tem um nome que não ajuda muito e que não vai ser utilizada em nenhum outro lugar. Chamar a função de "),o("code",[e._v("acumulador-auxiliar-para-contar-vogais")]),e._v(" não ajuda em nada.\n\nLá no começo do capítulo dissemos que funções anônimas são úteis para quando não precisamos utilizá-las em outra parte da aplicação. Podemos então converter a nossa função "),o("code",[e._v("acumulador-auxiliar")]),e._v(" em uma função anônima dentro de "),o("code",[e._v("conta-vogais")]),e._v(".\n\nComo o código que está dentro de "),o("code",[e._v("acumulador-auxiliar")]),e._v(" não vai ser alterado, vamos apenas indicar sua localização com um comentário para o livro não se transforme em uma bagunça e para que você não se perca na explicação.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Terceira versão do nosso contador de vogais",label:"cap04-recur-10"}},[e._v('\n(defn conta-vogais [texto]\n  ((fn [vogais texto]\n    ; aqui vem o código que estava dentro da\n    ; função contador-auxiliar\n    ) 0 texto))\n\n(conta-vogais "Livro de Clojure")\n; 6\n')]),e._v("\n\nAgora temos apenas uma função, que recebe apenas o texto e nos devolve a quantidade correta de vogais. Funciona, mas está difícil de ler.\n\nOs dois parênteses juntos logo no começo do código, para que possamos invocar uma função anônima assim que ela é criada, causa arrepios em quem já não gosta muito dos parênteses de um LISP. E aquele "),o("code",[e._v("0 texto")]),e._v(" ali embaixo dão uma sensação de coisa fora do lugar.\n\n"),o("index",{attrs:{entry:"loop"}}),e._v("\n\nFelizmente, a linguagem oferece uma construção que abstrai essa bagunça e deixa nosso código tão simples de ler quanto o "),o("code",[e._v("recur")]),e._v(" deixou lá no início do exemplo. Ela se chama "),o("code",[e._v("loop")]),e._v(", e é uma mistura de "),o("code",[e._v("let")]),e._v(" com função anônima.\n\nInternamente, o "),o("code",[e._v("loop")]),e._v(" informa para o "),o("code",[e._v("recur")]),e._v(" o ponto para o qual a recursão deve voltar na próxima iteração. É como a função anônima da listagem "),o("label",{attrs:{entry:"cap04-recur-10"}}),e._v(", mas sem os parênteses extras nem os parâmetros perdidos.\n\nAo invés de declararmos a função anônima, vamos declarar "),o("code",[e._v("(loop")]),e._v(", em seguida um vetor contendo os bindings "),o("code",[e._v("vogais")]),e._v(" e "),o("code",[e._v("texto")]),e._v(" e os respectivos valores iniciais, que são "),o("i",[e._v("0")]),e._v(" e o valor passado por parâmetro para a função, assim como faríamos em um "),o("code",[e._v("let")]),e._v(".\n\nNossa última versão ficaria com essa cara:\n\n"),o("snippet",{attrs:{language:"clojure",title:"Versão final do contador de vogais",label:"cap04-recur-11"}},[e._v('\n(defn conta-vogais [texto]\n  (loop [vogais 0\n         texto  texto]\n    (if (seq texto)\n        (recur (if (vogal? (first texto))\n                   (inc vogais)\n                   vogais)\n               (rest texto))\n        vogais)))\n\n(conta-vogais "Livro de Clojure")\n; 6\n')]),e._v("\n\nA quantidade de parâmetros que passamos ao "),o("code",[e._v("recur")]),e._v(" deve ser igual à quantidade de "),o("code",[e._v("bindings")]),e._v(" que o "),o("code",[e._v("loop")]),e._v(" declara, assim como em um "),o("code",[e._v("recur")]),e._v(" sem "),o("code",[e._v("loop")]),e._v(", a quantidade de parâmetros deve ser a mesma que a função declara.\n\nAgora que já sabemos como criar funções recursivas sem medo de estourar a pilha de chamadas da JVM, podemos processar dados que estão em uma sequência sem nos preocupar tanto com seu tamanho.\n\nExistem casos em que a recursão não é a melhor das soluções, mas existem estratégias que vamos apresentar no decorrer do livro. A partir daí vai caber a você avaliar qual a melhor técnica para resolver cada tipo de problema.\n\n"),o("h2",[e._v("4.11. Closures, currying e aplicações parciais")]),e._v("\n\nGeralmente, se você é um programador habituado a linguagens imperativas, o primeiro contato com os conceitos da programação funcional acontece através de artigos na Wikipedia ou textos contendo cargas assustadoras de conceitos matemáticos e termos aparentemente ininteligíveis.\n\nInfelizmente isso afasta o programador comum, como eu ou você, que não tem intenção de ir atrás de um mestrado em matemática apenas para entender o que é que os autores desses textos crípticos tentaram dizer.\n\nA boa notícia é que os conceitos básicos da programação funcional são muito simples e, com um pouco de prática, podem entrar facilmente para o seu arsenal de técnicas de desenvolvimento.\n\nPrimeiro vamos criar uma função chamada "),o("code",[e._v("saudacao")]),e._v(", que recebe dois parâmetros. O primeiro contém uma mensagem simpática e o segundo contém um nome. É uma função bem bacana para utilizarmos assim que o usuário se conectar a um sistema.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Um jeito repetitivo de dar bom dia",label:"cap04-closure-0"}},[e._v('\n(defn saudacao [mensagem nome]\n  (str mensagem ", " nome))\n\n(saudacao "Bom dia" "João")\n; "Bom dia, João"\n\n(saudacao "Bom dia" "José")\n; "Bom dia, José"\n\n(saudacao "Bom dia" "Nicolau")\n; "Bom dia, Nicolau"\n')]),e._v("\n\nNossa função retorna as saudações corretamente na listagem "),o("label",{attrs:{entry:"cap04-closure-0"}}),e._v(", mas em cada chamada de função temos que repetir a mensagem. E se houvesse um jeito de dizer apenas uma vez que a saudação deve ser "),o("i",[e._v("Bom dia")]),e._v(" e precisássemos informar somente o nome?\n\nPois isso é possível reescrevendo a função como na listagem "),o("label",{attrs:{entry:"cap04-closure-1"}}),e._v(":\n\n"),o("snippet",{attrs:{language:"clojure",title:"Reduzindo a repetição usando closure",label:"cap04-closure-1"}},[e._v('\n(defn saudacao [mensagem]\n  (fn [nome]\n    (str mensagem ", " nome)))\n\n(def bom-dia (saudacao "Bom dia"))\n\n(bom-dia "João")\n; "Bom dia, João"\n\n(bom-dia "José")\n; "Bom dia, José"\n\n(bom-dia "Nicolau")\n; "Bom dia, Nicolau"\n')]),e._v("\n\nA nossa função "),o("code",[e._v("saudação")]),e._v(" agora retorna uma função anônima. Sempre que uma função recebe outra como parâmetro ou devolve outra função como resultado, a chamamos de "),o("i",[e._v("high order function")]),e._v(".\n\nEssa função anônima que foi retornada recebe um parâmetro "),o("code",[e._v("nome")]),e._v(" e o concatena ao valor de "),o("code",[e._v("mensagem")]),e._v(" que foi passado por parâmetro usando a função "),o("code",[e._v("str")]),e._v(".\n\nO interessante aqui é que "),o("code",[e._v("bom-dia")]),e._v(" guarda a função anônima retornada por "),o("code",[e._v("saudacao")]),e._v(", que guarda todo o contexto existente em "),o("code",[e._v("saudação")]),e._v(" no momento em que foi criada. Isso significa, de maneira simplificada, que "),o("i",[e._v("a função anônima se lembra do momento em que foi criada")]),o("bib",{attrs:{entry:"function-of-function"}}),e._v(". Chamamos essa "),o("i",[e._v("lembrança"),o("i",[e._v(" de ")]),e._v("closure")]),e._v(".\n\nDito isso, sabemos que a função anônima se lembra do valor de "),o("code",[e._v("mensagem")]),e._v(", mesmo depois que a função "),o("code",[e._v("saudacao")]),e._v(" já não está mais sendo executada.\n\nAo executarmos "),o("code",[e._v("saudacao")]),e._v(" novamente, criaremos uma nova função anônima, que vai guardar o valor de "),o("code",[e._v("mensagem")]),e._v(" que foi utilizado dessa vez.\n\nFazendo uma analogia com a orientação a objetos, a cada vez que você cria um objeto, ele encapsula informações que independem da existência de outro objeto do mesmo tipo. Da mesma forma, "),o("i",[e._v("closures")]),e._v(" encapsulam informação dentro de uma função, independente do fato de existirem outras funções.\n\nVamos tentar atribuir a função anônima diretamente a "),o("code",[e._v("bom-dia")]),e._v(", sem usar "),o("i",[e._v("closure")]),e._v(". Na listagem "),o("label",{attrs:{entry:"cap04-closure-2"}}),e._v(" vemos o que acontece.\n\n"),o("snippet",{attrs:{language:"clojure",title:"Usando a função anônima sem closure",label:"cap04-closure-2"}},[e._v('\n(def bom-dia (fn [nome]\n    (str mensagem ", " nome)))\n; CompilerException java.lang.RuntimeException:\n; Unable to resolve symbol: mensagem in this context\n')]),e._v("\n\nAntes mesmo de tentarmos executar "),o("code",[e._v("bom-dia")]),e._v(", o compilador acusou que não existe o símbolo "),o("code",[e._v("mensagem")]),e._v(". Isso aconteceu porque, no nosso código original da listagem "),o("label",{attrs:{entry:"cap04-closure-1"}}),e._v(", "),o("code",[e._v("mensagem")]),e._v(" foi definida fora da função anônima.\n\nIsso significa que "),o("code",[e._v("mensagem")]),e._v(", dentro do contexto da função anônima, é uma "),o("i",[e._v("variável livre")]),e._v(".\n\n"),o("box",{attrs:{title:"Para os puristas..."}},[e._v("\nEm termos mais técnicos, uma "),o("i",[e._v("closure")]),e._v(", ou "),o("i",[e._v("lexical closure")]),e._v(", é uma função anônima cujas variáveis livres foram presas, ou enclausuradas ("),o("i",[e._v("closed")]),e._v(", em inglês) pelo escopo léxico em que ela foi criada.\n\n"),o("i",[e._v("Closure")]),e._v(" também é o nome em inglês para aquilo que fecha um recipiente, como um tampa ou rolha.\n")]),e._v("\n\nJá a função anônima, que depende de "),o("i",[e._v("closure")]),e._v(" para funcionar, é chamada de "),o("i",[e._v("aplicação parcial")]),e._v(", ou "),o("i",[e._v("partial function application")]),e._v(".\n\n"),o("index",{attrs:{entry:"partial"}}),e._v("\n\nExiste uma função em Clojure específica para criarmos aplicações parciais, que recebe o nome óbvio de "),o("code",[e._v("partial")]),e._v(".\n\nO código da listagem "),o("label",{attrs:{entry:"cap04-closure-1"}}),e._v(" ficaria assim usando "),o("code",[e._v("partial")]),e._v(":\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn saudacao [mensagem]\n  (partial str mensagem ", "))\n\n(def bom-dia (saudacao "Bom dia"))\n\n(bom-dia "Luis")\n; Bom dia, Luis\n\n(bom-dia "Luis " "Carlos")\n; Bom dia, Luis Carlos\n')]),e._v("\n\nTodas os argumentos recebidos pela função criada com "),o("code",[e._v("partial")]),e._v(" são adicionados no final da expressão.\n\n"),o("box",{attrs:{title:"Partial e currying"}},[e._v("\n\nOutra palavra mágica na programação funcional, e que frequentemente causa confusão e medo, é "),o("i",[e._v("currying")]),e._v(".\n\n"),o("i",[e._v("Currying")]),e._v(" nada mais é do que a técnica de transformar uma função que receba N argumentos em N funções com um argumento cada. Na listagem "),o("label",{attrs:{entry:"cap04-closure-3"}}),e._v(" é apresentado um exemplo de como uma função comum é transformada usando "),o("i",[e._v("currying")]),e._v(".\n\n"),o("snippet",{attrs:{language:"javascript",title:"Demonstrando currying com uma pseudolinguagem",label:"cap04-closure-3"}},[e._v("\n// a função original\ny = f(a, b, c)\n\n// a função 'curried'\ng = f(a)\nh = g(b)\ny = h(c)\n")]),e._v("\n\nO termo é frequentemente confundido com aplicação parcial"),o("bib",{attrs:{entry:"partial-not-curry"}}),e._v(", devido ao fato de que, em determinados casos, ambos se sobrepõe e parecem ser a mesma coisa"),o("bib",{attrs:{entry:"vidal-curry"}}),e._v(" e, apesar do Clojure ter suporte nativo a aplicação parcial, não existe uma forma transparente de utilizar "),o("i",[e._v("currying")]),e._v(", como acontece na linguagem "),o("i",[e._v("Haskell")]),e._v(".\n\nNão se preocupe em tentar usar "),o("i",[e._v("currying")]),e._v(" em Clojure. Na maior parte do tempo, o uso de aplicação parcial vai fazer o trabalho sem problemas.\n")],1),o("h2",[e._v("4.12. Memoização")]),e._v("\n\nMemoização"),o("bib",{attrs:{entry:"memo-functions"}}),e._v(" é uma técnica de otimização em que você troca processamento por memória.\n\nAo "),o("i",[e._v("memoizar")]),e._v(" uma função, é criado um mapa em memória contendo os parâmetros de entrada e o valor de retorno.\n\nNa primeira vez que a função é executada, é adicionado um item nesse mapa e, nas próximas vezes, ao invés de executá-la, o valor é extraido diretamente do mapa, reduzindo consideravelmente o tempo de retorno.\n\n"),o("box",{attrs:{title:"Memoization e closure"}},[e._v("\nCaso você tenha curiosidade de ir mais a fundo na linguagem, o código fonte da função "),o("code",[e._v("memoize")]),e._v(" é um ótimo exemplo de uso real de "),o("i",[e._v("closure")]),e._v(".\n\nDentro do REPL, digite "),o("code",[e._v("(source memoize)")]),e._v(" e releia os parágrafos acima acompanhando as linhas de código para entender melhor a função.\n\nPode ir sem medo. O código é bem curto e simples de entender.\n")]),o("index",{attrs:{entry:"time"}}),e._v("\nA biblioteca padrão do Clojure nos fornece uma função chamada "),o("code",[e._v("time")]),e._v(", que informa o tempo que uma expressão leva para ser executada.\n\n"),o("index",{attrs:{entry:"Thread/sleep"}}),e._v("\nVamos criar uma função propositadamente lenta, que retorna o mesmo valor que usarmos como entrada. Vamos usar um "),o("code",[e._v("sleep")]),e._v(" de dois segundos para deixar a função lenta:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn lento [x]\n  (Thread/sleep 2000)\n  x)\n\n(time (lento 10))\n; "Elapsed time: 2017.528206 msecs"\n; 10\n')]),e._v("\n\nA função levou um pouco mais de dois segundos para ser retornar o mesmo valor que usamos como argumento. Fizemos isso para simular um cálculo demorado e complexo.\n\nVamos agora usar a função "),o("code",[e._v("memoize")]),e._v(", que recebe a função lenta como parâmetro e nos devolve uma versão memoizada da função lenta.\n\nVamos ao código:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def memo-lento (memoize lento))\n\n(time (memo-lento 10))\n; "Elapsed time: 2017.185984 msecs"\n; 10\n\n(time (memo-lento 10))\n; "Elapsed time: 0.029892 msecs"\n; 10\n')]),e._v("\n\nNa primeira vez que executamos a versão memoizada, o tempo de execução foi praticamente o mesmo. Porém, na segunda vez, a função centésimos de segundo para retornar o mesmo valor. Sem dúvida, uma grande diferença.\n\nUma coisa importante e que deve ser deixada explícita, é que "),o("b",[e._v("você só deve memoizar funções puras")]),e._v(", sem efeitos colaterais. Como a função só será executada na primeira vez, qualquer efeito colateral deixará de ocorrer nas vezes seguintes.\n\n"),o("box",{attrs:{title:"Funções puras"}},[e._v("\nUma função pura é simplesmente aquela que não causa efeito colateral durante a sua execução. Um acesso ao banco de dados, ao sistema de arquivos, à rede, a alteração de um valor global ou mesmo o ato de imprimir algo na tela são exemplos de efeitos colaterais.\n\nAssim como a imutabilidade, o conceito de pureza de função é muito importante para a programação funcional.\n\nQuando falamos em imutabilidade, não significa que todos os seus dados devam ser imutáveis, mas que as partes mutáveis devam ser isoladas e mantidas sob controle.\n\nDa mesma forma, uma aplicação que seja totalmente pura não tem lá muita utilidade prática, então é uma boa prática isolarmos as funções impuras das puras, para que não tenhamos surpresas com comportamentos imprevistos.\n\nUm exemplo simples de função pura é a operação aritmética de soma, que recebe um conjunto de valores e devolve uma resposta, sem alterar mais nada no ambiente.\n")]),e._v("\n\nVamos criar uma função com efeito colateral para demonstrar. No nosso exemplo, o efeito colateral será uma mensagem impressa na tela, mas na sua aplicação poderia ser um acesso à rede, ao arquivo ou a qualquer outro recurso externo:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn colateral [x]\n  (println "Imprimindo " x)\n  x)\n\n(colateral 10)\n; Imprimindo  10\n; 10\n\n(def memo-colateral (memoize colateral))\n\n(memo-colateral 10)\n; Imprimindo  10\n; 10\n\n(memo-colateral 10)\n; 10\n\n(memo-colateral 30)\n; Imprimindo  30\n; 30\n\n(memo-colateral 30)\n; 30\n')]),e._v("\n\nÉ algo esperado se você se lembrar de que a função é executada apenas uma vez para cada argumento utilizado. O efeito colateral só ocorreu uma vez quando utilizamos o valor "),o("i",[e._v("10")]),e._v(", e aconteceu novamente uma vez ao utilizarmos o valor "),o("i",[e._v("30")]),e._v(".\n\n"),o("h3",[e._v("Memoization e recursão")]),e._v("\n\nO recurso de usar memoização com recursão pode ajudar bastante em cálculos pesados, mas exige alguns cuidados.\n\n"),o("index",{attrs:{entry:"Fibonacci"}}),e._v("\n\nVou utilizar a versão recursiva do cálculo do enésimo número da sequência de Fibonacci para demonstrar como podemos otimizar utilizando memoização e, em seguida, os tais cuidados que você precisa ter.\n\nA sequência de Fibonacci consiste em um número subsequente igual ao resultado da soma dos dois anteriores. No nosso exemplo, vamos começar pelo "),o("i",[e._v("1")]),e._v(", então teremos "),o("i",[e._v("1")]),e._v(", "),o("i",[e._v("2")]),e._v(", "),o("i",[e._v("3")]),e._v(", "),o("i",[e._v("5")]),e._v(", "),o("i",[e._v("8")]),e._v(", "),o("i",[e._v("13")]),e._v(" e assim por diante.\n\n"),o("index",{attrs:{entry:"zero?"}}),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defn fib [n]\n  (if  (or (zero? n) (= n 1))\n    1\n    (+ (fib (- n 1)) (fib (- n 2)))))\n")]),e._v("\n\nApenas como um lembrete amigável, essa é a segunda pior forma possível de se calcular a sequência de Fibonacci. De acordo com a minha experiência, a pior forma é tentar calcular com um lápis de ponta quebrada num papel de pão. De qualquer maneira, é uma forma válida para o que pretendemos fazer.\n\nVamos calcular o quadragésimo item da sequência e apresentar o tempo que levaremos para calculá-lo:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(time (fib 40))\n; "Elapsed time: 28777.402994 msecs"\n; 165580141\n')]),e._v("\n\nNossa função levou 28 segundos para calcular 40 números. E esse tempo cresce numa progressão geométrica se você tentar calcular um valor maior.\n\n"),o("image",{attrs:{src:"images/capitulo_04/recursao.png",description:"Grafo de chamadas de (fib 5)",label:"diagrama-recursao",width:"50%"}}),e._v("\n\nO diagrama da figura "),o("label",{attrs:{entry:"diagrama-recursao"}}),e._v(" mostra que tivemos onze chamadas de função para calcular o quinto número da sequência. Se tivessemos calculado o sexto número, teríamos dezenove chamadas. Apenas a título de curiosidade, nosso cálculo do quadragésimo item fez 267.914.294 chamadas de função, e "),o("code",[e._v("(fib 2)")]),e._v(" é calculado mais de setecentas vezes.\n\nSem dúvida nenhuma, o nosso algoritmo é totalmente ineficiente.\n\nPor que não melhoramos isso e reduzimos o cálculo para apenas uma vez em cada argumento?\n\nFácil, vamos memoizar tudo:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn fib [n]\n  (if  (or (zero? n) (= n 1))\n    1\n    (+ (fib (- n 1)) (fib (- n 2)))))\n\n(def memo-fib (memoize fib))\n\n(time (memo-fib 40))\n; "Elapsed time: 29374.836646 msecs"\n; 165580141\n')]),e._v("\n\nO tempo permaneceu praticamente o mesmo. Isso acontece porque memoizamos apenas a execução de "),o("code",[e._v("(fib 40)")]),e._v(". Todas as outras repetições desnecessárias continuam acontecendo internamente.\n\nVamos então fazer com que a função "),o("code",[e._v("fib")]),e._v(" chame a sua versão memoizada, "),o("code",[e._v("memo-fib")]),e._v(".\n\nO problema dessa solução é que temos aqui aquele velho paradoxo do ovo e da galinha: como memoizar uma função que ainda não existe? Ou como fazer a função chamar sua versão memoizada se ela ainda não foi memoizada?\n\nO nosso código demonstra o que você vai encontrar se insistir em ignorar o paradoxo:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defn fib [n]\n  (if  (or (zero? n) (= n 1))\n    1\n    (+ (memo-fib (- n 1)) (fib (- n 2)))))\n; CompilerException java.lang.RuntimeException: Unable to resolve\n;   symbol: memo-fib in this context\n")]),e._v("\n\nO compilador do Clojure tem uma tabela de "),o("i",[e._v("vars")]),e._v(" com seus respectivos nomes. Ao tentar compilar a função "),o("code",[e._v("fib")]),e._v(", o compilador não encontrou o "),o("i",[e._v("var")]),o("code",[e._v("memo-fib")]),e._v(" em sua tabela interna e lançou uma exceção nos informando o problema.\n\n"),o("index",{attrs:{entry:"forward declaration"}}),e._v("\n\nPara resolver isso, vamos usar uma técnica chamada "),o("i",[e._v("forward declaration")]),e._v(", ou "),o("i",[e._v("declaração prematura")]),e._v(" numa tradução livre.\n\nA sacada da declaração prematura é que o "),o("i",[e._v("var")]),e._v(" precisa existir, mas a função não, pois ela só será chamada quando executarmos "),o("code",[e._v("fib")]),e._v(". Então temos tempo suficiente para fazer "),o("code",[e._v("fib")]),e._v(" chamar sua versão memoizada e só então efetuarmos a memoização.\n\nNosso código então ficaria assim:\n\n"),o("snippet",{attrs:{language:"clojure",title:"Resolvendo Fibonacci com memoização",label:"cap04-forward-declaration"}},[e._v('\n(declare memo-fib) ; aqui o var é criado\n\n(defn fib [n]\n  (if  (or (zero? n) (= n 1))\n    1\n    (+ (memo-fib (dec n)) (memo-fib (- n 2)))))\n\n(def memo-fib (memoize fib)) ; e só aqui ele recebe a memoização\n\n(time (memo-fib 40))\n; "Elapsed time: 0.244445 msecs"\n; 165580141\n')]),e._v("\n\nReduzimos o tempo de execução de 27 segundos para apenas dois décimos, mais de cem vezes mais rápido.\n\nNa primeira vez que você calcular o quadragésimo número da sequência, serão feitas quarenta chamadas de função. Numa segunda vez que você calcular o mesmo número, será feita apenas uma chamada de função.\n\n"),o("box",{attrs:{title:"Diferença entre declare e def"}},[o("index",{attrs:{entry:"declare"}}),e._v("\n\nNa listagem "),o("label",{attrs:{entry:"cap04-forward-declaration"}}),e._v(" poderíamos ter usado "),o("code",[e._v("(def memo-fib)")]),e._v(" no lugar da forma "),o("code",[e._v("declare")]),e._v(".\n\nA vantagem do "),o("code",[e._v("declare")]),e._v(" é que você pode fazer mais de uma declaração prematura de uma vez. Internamente será executado um "),o("code",[e._v("def")]),e._v(" para cada item.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n; esse código\n(declare par impar primo)\n\n; faz a mesma coisa que esse\n(def par)\n(def impar)\n(def primo)\n")]),e._v("\n\nComo declarações prematuras não são uma coisa comum, e devem ser evitadas quando possível, dificilmente você precisará declarar mais de um "),o("i",[e._v("var")]),e._v(" ao mesmo tempo.\n")],1),o("image",{attrs:{src:"images/capitulo_04/memoizado.png",description:"Grafo de chamadas de (memo-fib 5)",label:"diagrama-memoizado",width:"50%"}}),e._v("\n\nNo diagrama da imagem "),o("label",{attrs:{entry:"diagrama-memoizado"}}),e._v(" você pode ver a diferença ao calcularmos "),o("code",[e._v("(fib 5)")]),e._v(". Experimente comparar com o diagrama anterior.\n\n"),o("h3",[e._v("Memoização para adultos")]),e._v("\n\nA implementação da função "),o("code",[e._v("memoize")]),e._v(" é a mais simples possível, e existem situações em que ela se apresenta insuficiente ou inadequada.\n\nComo fazer se você precisar que o valor memoizado tenha um prazo de validade?\n\nUm exemplo válido ocorre ao lermos um arquivo de configuração. Podemos ler o arquivo toda vez que algum processo precisar de uma configuração, o que é lento e perigoso, ou podemos ler apenas na primeira vez e memoizar o resultado para que todos os demais processos acessem a informação diretamente da memória de forma segura.\n\nE se o arquivo de configuração for modificado? Teremos que reiniciar a aplicação toda vez que isso acontecer? Não temos como invalidar o valor memoizado para o arquivo seja lido novamente, mantendo sempre a informação mais recente em memória?\n\nCom a implementação padrão da função "),o("code",[e._v("meimoize")]),e._v(" não temos muito o que fazer além de reiniciar a aplicação toda vez.\n\nPara evitar esse tipo de problema, que acaba sendo limitado a casos específicos, existe uma biblioteca chamada "),o("code",[e._v("core.memoize")]),e._v(", que pode ser encontrada em http://git.io/U2QLvA.\n\nCaso você se pergunte porque não tornar o código dessa biblioteca como padrão do Clojure, eu te respondo. Simplesmente porque memoização é uma das formas de se resolver um tipo de problema específico e a biblioteca é uma forma específica de resolver um problema no problema específico. Seria complicar demais a biblioteca padrão para algo que deve responder por uma pequena fração da necessidade dos usuários.\n\nLembre-se que faz parte da filosofia por trás do desenvolvimento do Clojure que a biblioteca padrão permaneça simples e contendo somente o necessário, enquanto toda solução para problemas específicos ou complicados acaba ficando em pequenas bibliotecas que podem ser adicionados conforme a necessidade.\n\nAssim você mantém a linguagem enxuta e sua aplicação carrega somente o peso que precisar carregar.\n\n"),o("h2",[e._v("4.13. Recursão mútua com trampoline")]),e._v("\n\nRecursão mútua acontece quando temos duas ou mais funções e uma depende da outra, e vice-versa.\n\nÉ um recurso que fica restrito a campos bem específicos, como por exemplo a criação de parsers, máquinas de estados finitos e fractais.\n\nUm exemplo de máquina de estados finitos bem conhecido é o semáforo de trânsito. No diagrama da imagem "),o("label",{attrs:{entry:"diagrama-semaforo"}}),e._v(" temos os estados válidos de um semáforo e suas possíveis mudanças.\n\n"),o("image",{attrs:{src:"images/capitulo_04/semaforo.png",description:"Estados possíveis de um semáforo",width:"40%",label:"diagrama-semaforo"}}),e._v("\n\nEm uma linguagem imperativa, normalmente teríamos um "),o("i",[e._v("loop")]),e._v(" com um "),o("i",[e._v("if")]),e._v(" ou um "),o("i",[e._v("switch")]),e._v(" invocando alguma função ou método de acordo com o estado atual do semáforo. Para isso teríamos um estado compartilhado entre os três blocos de código responsáveis por cada um dos estados.\n\nEm uma linguagem funcional podemos fazer com que cada função responsável pelo estado do semáforo guarde o estado atual, sem a necessidade de um estado global e compartilhado. Assim que houver a mudança no estado, que no nosso caso é a cor da luz, outra função é invocada e assim por diante.\n\nNa listagem "),o("label",{attrs:{entry:"cap04-semaforo-1"}}),e._v(" vamos tentar implementar o semáforo seguindo as regras do diagrama da figura "),o("label",{attrs:{entry:"diagrama-semaforo"}}),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure",title:"Primeira versão do semáforo",label:"cap04-semaforo-1"}},[e._v('\n(declare verde amarelo)\n\n(defn vermelho []\n  (println "vermelho")\n  (Thread/sleep 2000)\n  (verde))\n\n(defn verde []\n  (println " verde")\n  (Thread/sleep 2000)\n  (amarelo))\n\n(defn amarelo []\n  (println "  amarelo")\n  (Thread/sleep 500)\n  (vermelho))\n\n(defn semaforo []\n  (vermelho))\n\n(semaforo)\n; vermelho\n;  verde\n;   amarelo\n; vermelho\n;  verde\n; ...\n; StackOverflowError   clojure.walk/stringify-keys/fn--6998\n')]),e._v("\n\nO código é bem simples. Ao chamarmos a função "),o("code",[e._v("semaforo")]),e._v(", o semáforo começa a funcionar com a luz vermelha, depois de um tempo passa para verde, passa rapidamente para amarelo e acende a luz vermelha novamente. Apenas uma luz fica acesa por vez, e a ordem está sendo respeitada.\n\nO problema é que, depois de algum tempo, esse nosso código deixa de funcionar. A cada mudança de estado uma nova chamada de função é feita e uma posição no "),o("i",[e._v("stack")]),e._v(" do Java é consumida. Como o "),o("i",[e._v("stack")]),e._v(" tem um tamanho limitado, quando esse espaço acabar nossa aplicação será finalizada com uma mensagem de erro.\n\nImagine se todos os semáforos da cidade parassem de funcionar depois de algumas horas, ou depois de poucos dias, por conta de um erro de programação.\n\nNo nosso código, a função "),o("code",[e._v("vermelho")]),e._v(" chama "),o("code",[e._v("verde")]),e._v(", que chama "),o("code",[e._v("amarelo")]),e._v(", que chama "),o("code",[e._v("vermelho")]),e._v(" novamente e o ciclo volta a se repetir. Temos aqui um caso de recursão mútua.\n\nVamos resolver esse problema usando a função "),o("code",[e._v("trampoline")]),e._v(". Assim como vimos que a forma "),o("code",[e._v("recur")]),e._v(" permite que usemos recursão sem estourar a pilha de chamadas do Java, "),o("code",[e._v("trampoline")]),e._v(" permite que façamos o mesmo usando recursão mútua.\n\n"),o("box",{attrs:{title:"Pulando de trampolim"}},[e._v("\nA título de curiosidade, a técnica recebeu o nome de "),o("i",[e._v("trampolim")]),e._v(" porque, internamente, consiste em fazer o fluxo da aplicação "),o("i",[e._v("pular")]),e._v(" de um lugar para o outro.\n")]),e._v("\n\nO segredo no uso de "),o("code",[e._v("trampoline")]),e._v(" está no fato de que cada função não mais vai chamar a próxima, mas retornar uma função que faz esse trabalho. Assim teremos "),o("i",[e._v("uma função que devolve outra função")]),e._v(" ao invés de termos "),o("i",[e._v("uma função que chama outra função")]),e._v(". Isso é a base de um recurso poderoso chamado "),o("i",[e._v("lazy evaluation")]),e._v(", que veremos em detalhes mais para frente.\n\nUsando a forma reduzida "),o("code",[e._v("#( )")]),e._v(" para criarmos uma função anônima, faremos apenas alterações sutis no nosso código para que ele possa executar indefinidamente, sem consumir a pilha de chamadas.\n\nNa listagem "),o("label",{attrs:{entry:"cap04-semaforo-2"}}),e._v(" nós temos o código modificado. Perceba que substituimos as chamadas de função por funções anônimas, e que a função "),o("code",[e._v("semaforo")]),e._v(" agora executa "),o("code",[e._v("trampoline vermelho")]),e._v(" ao invés de chamar diretamente a função "),o("code",[e._v("vermelho")]),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure",title:"Versão do semáforo que não consome a pilha",label:"cap04-semaforo-2"}},[e._v('\n(declare verde amarelo)\n\n(defn vermelho []\n  (println "vermelho")\n  (Thread/sleep 2000)\n  #(verde))\n\n(defn verde []\n  (println " verde")\n  (Thread/sleep 2000)\n  #(amarelo))\n\n(defn amarelo []\n  (println "  amarelo")\n  (Thread/sleep 500)\n  #(vermelho))\n\n(defn semaforo [])\n  (trampoline vermelho))\n\n(semaforo)\n; vermelho\n;  verde\n;   amarelo\n; vermelho\n;  verde\n; ... e continua indefinidamente\n')]),o("h2",[e._v("4.14. Composição de funções")]),e._v("\n\nComo dissemos no início do capítulo, numa linguagem funcional os dados são transformados por uma série de funções até que tenhamos o resultado que precisamos. O uso dessas séries de funções é chamada de "),o("i",[e._v("composição")]),e._v(".\n\nQuando você compra um produto, é aplicada uma série de cálculos em cima de um valor base e, no final, você paga o valor que resultar dessa série. Podemos pensar em cada um desses cálculos como uma função, e na série toda como sendo a "),o("i",[e._v("composição")]),e._v(".\n\nVamos imaginar que estamos comprando um computador. Simplificando muito a equação, vamos afirmar que a loja tenha 20% de margem de lucro, e que seja cobrado 10% de "),o("i",[e._v("imposto genérico")]),e._v(". O "),o("i",[e._v("imposto genérico")]),e._v(" é algo que só existe no nosso exemplo para que a coisa fique mais simples possível. No final, ainda tem um desconto de 2% porque pagamos à vista.\n\nA fórmula de cálculo que vamos precisar é "),o("code",[e._v("valorTotal = desconto(imposto(margem(valorBase)))")]),e._v(".\n\nVamos então criar o código em Clojure que calcula o nosso valor total:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def valor-base 1500)\n\n(defn adiciona-margem [valor] (* valor 1.2))\n\n(defn adiciona-imposto [valor] (* valor 1.1))\n\n(defn desconto [valor] (* valor 0.98))\n\n(desconto (adiciona-imposto (adiciona-margem valor-base)))\n; 1940.4\n")]),e._v("\n\nSabendo que o valor total de venda sempre vai ser a composição das funções "),o("code",[e._v("desconto")]),e._v(", "),o("code",[e._v("adiciona-imposto")]),e._v(" e "),o("code",[e._v("adiciona-margem")]),e._v(", podemos juntar essa composição em apenas uma função.\n\n"),o("index",{attrs:{entry:"comp"}}),e._v("\nComo todas as funções recebem a mesma quantidade de parâmetros, podemos usar a função "),o("code",[e._v("comp")]),e._v(", que recebe as funções a serem agrupadas como parâmetro e devolve uma função que executa toda a sequência.\n\nNosso código ficaria assim, usando "),o("code",[e._v("comp")]),e._v(":\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def valor-base 1500)\n\n(defn adiciona-margem [valor] (* valor 1.2))\n\n(defn adiciona-imposto [valor] (* valor 1.1))\n\n(defn desconto [valor] (* valor 0.98))\n\n(def total (comp desconto adiciona-imposto adiciona-margem))\n\n(total valor-base)\n; 1940.4\n")]),e._v("\n\nA função "),o("code",[e._v("comp")]),e._v(" é uma boa alternativa para deixar o código mais limpo e também para evitarmos que ele se encha de parênteses.\n\nQuando alguma das funções da composição tem uma quantidade diferente de parâmetros, podemos criar uma "),o("i",[e._v("partial functions")]),e._v(" para deixarmos o código uniforme.\n\nVamos reaproveitar o nosso exemplo do contador de vogais para demonstrar como podemos utilizar "),o("i",[e._v("partial")]),e._v(" e composição em conjunto.\n\nUsando o "),o("i",[e._v("set")]),o("code",[e._v("vogal?")]),e._v(" que já conhecemos, vamos usar um filtro para eliminar todas as letras que não sejam vogais para, no final, contarmos quantas letras sobraram.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def vogal? (set "aeiouAEIOU"))\n\n(def texto "Livro de Clojure")\n\n(count (filter vogal? texto))\n; 6\n')]),o("box",{attrs:{title:"Mas já?"}},[e._v('\nAí você diz: "Puxa vida, mas eu escrevi aquela função grandona para contar vogais e agora você aparece com uma linha de código?".\n\nConforme você for se habituando a escrever código de maneira funcional, vai perceber que seus programas vão ficando menores e mais simples de entender.\n')]),e._v("\n\nVamos criar uma função parcial chamada "),o("code",[e._v("filtra-vogais")]),e._v(" que remove todas as letras do texto que não forem vogais. Assim como a função "),o("code",[e._v("count")]),e._v(" recebe apenas um parâmetro, nossa função parcial também vai trabalhar apenas com um argumento. Com as duas funções tendo a mesma aridade, fica fácil juntarmos tudo usando "),o("code",[e._v("comp")]),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def filtra-vogais (partial filter vogal?))\n\n(count (filtra-vogais texto))\n; 6\n")]),e._v("\n\nE agora podemos juntar "),o("code",[e._v("count")]),e._v(" e "),o("code",[e._v("filtra-vogais")]),e._v(" em uma função só:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(def conta-vogais (comp count filtra-vogais))\n\n(conta-vogais texto)\n; 6\n")]),e._v("\n\nMas você, como um bom observador, vai se perguntar qual a vantagem disso quando temos uma composição de apenas duas funções. Vantagem nenhuma se isso só deixar seu código mais complicado. Porém, quando estamos trabalhando com aplicações de verdade, é comum você utilizar muitas funções em sequência, ou uma função que faz coisas demais.\n\nNesses casos é muito útil quebrar a função que está muito grande em pedaços pequenos e altamente especializados, unindo-os com composição, ou então simular uma função grande compondo várias funções menores.\n\n"),o("h2",[e._v("4.15. Thread macros")]),e._v("\nExistem casos em que simplesmente compor funções não é o suficiente. Se você tiver diversas funções com aridades diferentes, e não for reutilizar a função composta, criar várias funções parciais vai apenas tornar o código mais difícil de entender.\n\nPor outro lado, encadear muitas chamadas de função sem nenhuma macro ou função para ajudar vai fazer com que o código tenha parênteses demais.\n\n"),o("box",{attrs:{title:"O significado de Thread"}},[e._v("\nA palavra "),o("i",[e._v("thread")]),e._v(", em seu sentido original, significa "),o("i",[e._v("cordão")]),e._v(", ou "),o("i",[e._v("barbante")]),e._v(". A palavra passou a ser utilizada em qualquer sentido que denote continuidade ou sequencia, ou simplesmente algo que vá de uma ponta à outra, como um cordão.\n\nEm Clojure nós usamos o termo em dois casos distintos. O primeiro é quando falamos de "),o("i",[e._v("thread macros")]),e._v(", seja a "),o("i",[e._v("thread first")]),e._v(" ou a "),o("i",[e._v("thread last")]),e._v(", que vamos ver a seguir. Esse nome indica que temos uma sequencia de operações sendo aplicadas em um dado inicial, sendo o resultado da primeira operação passada para a segunda, da segunda para a terceira e assim por diante, como em uma linha de montagem.\n\nO segundo caso, muito mais conhecido, é quando falamos de "),o("i",[e._v("thread")]),o("bib",{attrs:{entry:"thread-history"}}),e._v(" nos referindo a sequencias de processos"),o("bib",{attrs:{entry:"dijkstra-thread"}}),e._v(" que são executados de forma paralela, ou quase, entre si. É o caso de termos "),o("i",[e._v("duas ou mais threads sendo executadas simultaneamente")]),e._v(".\n")],1),e._v("\n\nNa listagem "),o("label",{attrs:{entry:"cap04-thread-0"}}),e._v(" vamos relembrar o cálculo do valor total do produto, com os impostos, lucro e descontos. O valor base é "),o("i",[e._v("1500")]),e._v(" e o valor final é "),o("code",[e._v("1940.4")]),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure",title:"Cálculo do preço total pelo jeito longo",label:"cap04-thread-0"}},[e._v("\n(def valor-base 1500)\n\n(defn adiciona-margem [valor] (* valor 1.2))\n\n(defn adiciona-imposto [valor] (* valor 1.1))\n\n(defn desconto [valor] (* valor 0.98))\n\n(desconto (adiciona-imposto (adiciona-margem valor-base)))\n; 1940.4\n")]),e._v("\n\nA cada nova operação que adicionarmos no cálculo, teremos que que adicionar a função no começo da expressão e o parêntese correspondente no final. Não há nada de errado nisso, mas com o tempo começa a ficar difícil se encontrar no meio dos parênteses sem a ajuda de um editor de texto que ajude nesse ponto.\n\nVamos adicionar um cálculo qualquer de envio pelo correio, que vamos chamar de "),o("code",[e._v("frete")]),e._v(", e o código vai ficar assim:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(frete (desconto (adiciona-imposto (adiciona-margem valor-base))))\n")]),e._v("\n\nA expressão começa a ficar mais longa e mais difícil de manter.\n\nPara ajudar a reduzir esse aumento de complexidade, o Clojure oferece os operadores conhecidos por "),o("i",[e._v("thread macros")]),e._v(".\n\n"),o("index",{attrs:{entry:"->"}}),o("h3",[e._v("Thread first")]),e._v("\n\nO primeiro deles é o operador "),o("code",[e._v("->")]),e._v(", chamado de "),o("i",[e._v("thread first")]),e._v(".\n\nCom o "),o("i",[e._v("thread first")]),e._v(" você informa o valor inicial a ser transformado, que no nosso cálculo é o "),o("code",[e._v("valor-base")]),e._v(". Em seguida informa a primeira função que vai transformar o valor, depois a segunda, a terceira, e assim por diante. O resultado da primeira função é passado como parâmetro para a segunda, cujo resultado é passado para a terceira, até que acabe a lista de operações. No final você recebe o valor.\n\nVamos demonstrar passo a passo como funciona o operador "),o("code",[e._v("->")]),e._v(". Primeiro informamos o valor inicial a ser transformado:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(-> valor-base)\n; 1500\n")]),e._v("\n\nAgora vamos aplicar a função "),o("code",[e._v("adiciona-margem")]),e._v(" em cima desses "),o("i",[e._v("1500")]),e._v(" referentes ao valor base:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(-> valor-base\n    adiciona-margem)\n; 1800\n")]),e._v("\n\nAgora vamos adicionar os impostos usando a função "),o("code",[e._v("adiciona-imposto")]),e._v(". Essa função vai receber como parâmetro o valor de "),o("i",[e._v("1800")]),e._v(" que conseguimos até aqui.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(-> valor-base\n    adiciona-margem\n    adiciona-imposto)\n; 1980\n")]),e._v("\n\nE assim por diante, até chegarmos ao cálculo do desconto. Vamos aproveitar para comparar o jeito que o código ficou usando "),o("i",[e._v("thread first")]),e._v(" com o jeito anterior, aninhando as expressões:\n\n"),o("snippet",{attrs:{language:"clojure",title:"Código completo usando ->",label:"cap04-thread-1"}},[e._v("\n; cálculo utilizando ->\n(-> valor-base\n    adiciona-margem\n    adiciona-imposto\n    desconto)\n; 1940.4\n\n; cálculo do jeito longo\n(desconto (adiciona-imposto (adiciona-margem valor-base)))\n; 1940.4\n")]),e._v("\n\nNo final, chegamos ao mesmo valor de "),o("code",[e._v("1940.4")]),e._v(", mas de uma forma bem mais organizada. A cada nova operação que quisermos acrescentar ao processo, basta ir adicionando função por função, na ordem, ao final da lista.\n\nO operador "),o("code",[e._v("->")]),e._v(" é chamado de "),o("i",[e._v("thread first")]),e._v(" porque insere o resultado do passo anterior como primeiro parâmetro do passo seguinte. Essa sequencia de passos para transformar um valor também é conhecida por "),o("i",[e._v("pipeline")]),e._v(".\n\nNosso exemplo foi bem simples. Todas as funções recebem apenas um argumento. E quando a função recebe dois ou mais?\n\nVamos pensar em uma expressão matemática simples, apenas para exemplificar o funcionamento. Vamos escrever a expressão "),o("code",[e._v("((((2 + 3) * 4) - 5) / 6)"),o("code",[e._v(" da forma normal e, em seguida vamos escrever da forma reduzida usando o operador ")]),e._v("->")]),e._v(":\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n; cálculo do jeito longo\n(/ (- (* (+ 2 3) 4) 5) 6)\n; 5/2\n\n; cálculo usando ->\n(-> 2 (+ 3) (* 4) (- 5) (/ 6))\n; 5/2\n")]),o("box",{attrs:{title:"De onde surgiu esse 5/2?"}},[e._v("\nEm Clojure existem três tipos numéricos básicos: inteiros, decimais e racionais.\n\n"),o("index",{attrs:{entry:"BigDecimal"}}),e._v("\n\nOs números decimais são aqueles a que já estamos acostumados, no formato "),o("code",[e._v("2.5")]),e._v(" e internamente utilizando a classe "),o("code",[e._v("java.lang.Double")]),e._v(" do Java.\n\n"),o("index",{attrs:{entry:"Ratio"}}),e._v("\nJá os tipos racionais são apresentados na forma "),o("code",[e._v("5/2")]),e._v(" e são retornados sempre que uma divisão não resulta em um número inteiro. Internamente usa-se o tipo "),o("code",[e._v("Ratio")]),e._v(" para representar esse tipo numérico.\n\nNo próximo capítulo serão apresentados mais detalhes sobre esse tipo e a motivação para que ele exista.\n")],1),e._v("\n\nAvaliando passo a passo a expressão que criamos com "),o("code",[e._v("->")]),e._v(", vamos pegar o primeiro item da lista, que é "),o("i",[e._v("2")]),e._v(", e passá-lo como primeiro parâmetro para o segundo item, "),o("code",[e._v("(+ 3)")]),e._v(".\n\nO resultado, "),o("code",[e._v("(+ 2 3)")]),e._v(" é passado como primeiro parâmetro para o próximo item da lista, que é "),o("code",[e._v("(* 4)"),o("code",[e._v(", se transformando internamente em ")]),e._v("(* (+ 2 3) 4)")]),e._v(", que vai ser passado como o primeiro parâmetro do item seguinte, que é "),o("code",[e._v("(- 5)")]),e._v(".\n\nCom isso temos a expressão "),o("code",[e._v("(- (* (+ 2 3) 4) 5)")]),e._v(", que vai ser passada como o primeiro parâmetro do último item da lista, que é "),o("code",[e._v("(/ 6)")]),e._v(", resultado na expressão em seu formato normal, que é "),o("code",[e._v("(/ (- (* (+ 2 3) 4) 5) 6)")]),e._v(".\n\n"),o("h3",[e._v("Acessando mapas com thread first")]),e._v("\n\nO operador "),o("code",[e._v("->")]),e._v(" nos permite acessar mapas de forma bem mais simples. Na listagem "),o("label",{attrs:{entry:"cap04-thread-2"}}),e._v(", vamos relembrar do mapa que usamos ao falar sobre "),o("i",[e._v("destructuring")]),e._v(". Esse mapa contém os dados de um livro qualquer e vamos demonstrar como extrair informações utilizando o operador "),o("code",[e._v("->")]),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure",title:"Mapa com os dados de um livro qualquer",label:"cap04-thread-2"}},[e._v('\n(def info-livro\n        {:titulo "Livro de Clojure"\n         :autor "Plínio Balduino"\n         :capitulos {:capitulo01 "Apresentação"\n                     :capitulo02 "Uma introdução gentil ao Clojure"}})\n')]),e._v("\n\nSe quisermos extrair o título do capítulo 2, precisaremos acessar a propriedade "),o("code",[e._v(":capitulos"),o("code",[e._v(" e, com o resultado, acessar a propriedade ")]),e._v(":capitulo02")]),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n; :capitulos guarda um mapa\n(info-livro :capitulos)\n; {:capitulo01 "Apresentação",\n;  :capitulo02 "Uma introdução gentil ao Clojure"}\n\n; e acessando :capitulo02, temos o título\n((info-livro :capitulos) :capitulo02)\n; "Uma introdução gentil ao Clojure"\n')]),e._v("\n\nDa mesma forma que, quando maior a expressão, maior a quantidade de parênteses, acontece o mesmo com mapas, onde quanto mais a fundo você precisar ir em um mapa para encontrar a informação, mais difícil de ler fica a expressão.\n\nDe forma parecida, para acessarmos uma informação de um mapa, vamos passar o nome do mapa como primeiro parâmetro para o operador "),o("code",[e._v("->")]),e._v(":\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(-> info-livro)\n; {:titulo "Livro de Clojure",\n; :capitulos {:capitulo01 "Apresentação",\n;             :capitulo02 "Uma introdução gentil ao Clojure"},\n; :autor "Plínio Balduino"}\n')]),e._v("\n\nEm seguida adicionamos na lista de parâmetros a chave do primeiro nível da informação, que é "),o("code",[e._v("capítulos")]),e._v(":\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(-> info-livro\n    :capitulos)\n; {:capitulo01 "Apresentação",\n;  :capitulo02 "Uma introdução gentil ao Clojure"}\n')]),e._v("\n\nE, finalmente, informamos a chave que contém o próximo nível de informação, que é "),o("code",[e._v(":capitulo02")]),e._v(":\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(-> info-livro\n    :capitulos\n    :capitulo02)\n; "Uma introdução gentil ao Clojure"\n')]),e._v("\n\nDessa forma, podemos buscar dados em mapas grandes de forma fácil de entender e de manter.\n\n"),o("h3",[e._v("Thread last")]),o("index",{attrs:{entry:"->>"}}),e._v("\n\nO operador "),o("code",[e._v("->>")]),e._v(", conhecido por "),o("i",[e._v("thread last")]),e._v(", funciona de forma muito parecida com o "),o("i",[e._v("thread first")]),e._v(", pegando o primeiro parâmetro e usando como parâmetro do segundo, e assim por diante. A diferença é que esse parâmetro é usado como último argumento do próximo item da lista.\n\nVamos usar uma expressão matemática para exemplificar. Sempre achei que exemplos práticos são a melhor maneira de se entender uma funcionalidade.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n; Cálculo da forma normal\n(/ 6 (- 5 (* 4 (+ 3 2))))\n; -2/5\n\n; E o mesmo cálculo usando ->>\n(->> 2 (+ 3) (* 4) (- 5) (/ 6))\n; -2/5\n")]),e._v("\n\nInternamente, o primeiro valor, "),o("i",[e._v("2")]),e._v(", vai ser passado como o último parâmetro da próxima expressão, que é "),o("code",[e._v("(+ 3)"),o("code",[e._v(", resultando em ")]),e._v("(+ 3 2)")]),e._v(". Esse resultado é usado como o último parâmetro da expressão seguinte, que é "),o("code",[e._v("(* 4)"),o("code",[e._v(" e com isso temos ")]),e._v("(* 4 (+ 3 2))")]),e._v(".\n\nDepois o resultado é usado com a expressão "),o("code",[e._v("(- 5)")]),e._v(", resultando em "),o("code",[e._v("(- 5 (* 4 (+ 3 2)))")]),e._v(" e com o último item, "),o("code",[e._v("(/ 6)")]),e._v(", resultando na expressão original, que é "),o("code",[e._v("(/ 6 (- 5 (* 4 (+ 3 2))))")]),e._v(".\n\nVamos encerrar reescrevendo aquele nosso código que conta as vogais. Primeiro criamos uma função recursiva e depois resolvemos o mesmo problema usando "),o("code",[e._v("count")]),e._v(" e "),o("code",[e._v("filter")]),e._v(". Agora vamos reescrever o código usando "),o("code",[e._v("->>")]),e._v(".\n\nEis o código que escrevemos quando estávamos aprendendo composição de funções:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def vogal? (set "aeiouAEIOU"))\n\n(def texto "Livro de Clojure")\n\n(count (filter vogal? texto))\n; 6\n')]),e._v("\n\nPara reescrever esse código usando "),o("i",[e._v("thread last")]),e._v(", primeiro pegamos o último parâmetro da expressão que estiver mais aninhada, que é "),o("code",[e._v("(filter vogal? texto)")]),e._v(", e passamos como parâmetro para o operador "),o("code",[e._v("->>")]),e._v(". Em seguida adicionamos o restante da expressão que estiver mais aninhada:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(->> texto\n     (filter vogal?))\n; (\\i \\o \\e \\o \\u \\e)\n")]),o("box",{attrs:{title:"Um pequeno detalhe sobre -> e ->>"}},[e._v("\nEnquanto o operador "),o("code",[e._v("->")]),e._v(" permite que você passe apenas um parâmetro, o operador "),o("code",[e._v("->>")]),e._v(" exige que pelo menos dois argumentos sejam utilizados.\n\nNão sei dizer se isso é intencional ou um pequeno detalhe que passou em branco.\n")]),e._v("\n\nAgora que temos a lista de vogais que estão no texto, vamos aplicar a função "),o("code",[e._v("count")]),e._v(" para sabermos quantos são:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(->> texto\n     (filter vogal?)\n     count)\n; 6\n")]),e._v("\n\nE finalmente temos a quantidade de vogais contida em nosso texto, de forma mais legível e simples de manter.\n\nUm leitor mais atento vai perceber que, enquanto usamos parênteses para delimitar a expressão "),o("code",[e._v("(filter vogal?)")]),e._v(", não usamos para delimitar a função "),o("code",[e._v("count")]),e._v(".\n\nPercebendo isso, será inevitável que faça a pergunta a respeito de quando se deve usar ou não os parênteses com os operadores "),o("code",[e._v("->"),o("code",[e._v(" e ")]),e._v("->>")]),e._v(".\n\nA resposta é bem simples. Sempre que a expressão for formada por uma função contendo parâmetros, como é o caso de "),o("code",[e._v("(filter vogal?)")]),e._v(", você deve usar parênteses para que o compilador saiba onde ela começa e onde termina.\n\nQuando você estiver usando uma função que não recebe nenhum parâmetro adicional, como é o caso de "),o("code",[e._v("count")]),e._v(", fica a seu critério usar ou não parênteses.\n\nPor exemplo, ambos os códigos abaixo funcionam da mesma forma:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n; Esse código\n(->> texto\n     (filter vogal?)\n     count)\n; 6\n\n; é equivalente a esse\n(->> texto\n     (filter vogal?)\n     (count))\n; 6\n")]),e._v("\n\nDa mesma forma que o nosso exemplo da listagem "),o("label",{attrs:{entry:"cap04-thread-1"}}),e._v(" pode ser escrita das duas formas abaixo:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n; Esse código\n(-> valor-base\n    adiciona-margem\n    adiciona-imposto\n    nil\n    desconto)\n; 1940.4\n\n; é equivalente a esse\n(-> valor-base\n    (adiciona-margem)\n    (adiciona-imposto)\n    (desconto))\n; 1940.4\n")]),e._v("\n\nSendo que a segunda forma é discutivelmente mais difícil de ser lida.\n\n"),o("h3",[e._v("Lidando com valores nulos")]),e._v("\n\nE se, em algum momento, um dos passos da transformação retornar "),o("code",[e._v("nil")]),e._v("?\n\nVamos inventar uma função chamada "),o("code",[e._v("nulo")]),e._v(", que nada mais faz do que retornar o valor "),o("code",[e._v("nil")]),e._v(". Imagine que essa função precise acessar um banco de dados, um site, e por qualquer motivo acabe retornando um valor nulo.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defn nulo [valor])\n\n(nulo 123)\n; nil\n")]),e._v("\n\nA função "),o("code",[e._v("nulo")]),e._v(" não retorna nada, o que é entendido como "),o("code",[e._v("nil")]),e._v(" pelo Clojure.\n\nVamos adicionar essa função "),o("code",[e._v("nulo")]),e._v(" no meio do nosso cálculo de preço:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(-> valor-base\n    adiciona-margem\n    adiciona-imposto\n    nulo\n    desconto)\n; NullPointerException   clojure.lang.Numbers.multiply\n")]),o("index",{attrs:{entry:"some->"}}),e._v("\n\nA partir da versão 1.5 do Clojure, passamos a contar com a macro "),o("code",[e._v("some->")]),e._v(", que interrompe o processamento assim que um valor nulo é encontrado. Ai fica por sua conta devolver uma mensagem de erro para o usuário ou retornar zero como o valor do produto.\n\nQualquer que seja a sua estratégia, ainda será melhor do que explodir um erro na cara do usuário ou a aplicação parar de funcionar por conta de um erro não tratado.\n\nVamos alterar nosso código para utilizar a macro "),o("code",[e._v("some->")]),e._v(":\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(some-> valor-base\n    adiciona-margem\n    adiciona-imposto\n    nulo\n    desconto)\n; nil\n")]),e._v("\n\nDa mesma forma como existem os operadores "),o("code",[e._v("->"),o("code",[e._v(" e ")]),e._v("->>")]),e._v(", também existe o operador "),o("code",[e._v("some->>"),o("code",[e._v(" além do ")]),e._v("some->")]),e._v(".\n\nO funcionamento de "),o("code",[e._v("some->>")]),e._v(" é idêntico ao "),o("code",[e._v("->>")]),e._v(", mas finalizando o processamento assim que um valor nulo for encontrado.\n\n"),o("index",{attrs:{entry:"Multimethods"}}),o("h2",[e._v("4.16. Polimorfismo com multimethods")]),e._v("\n\nHá alguns anos trabalhei em um servidor escrito em Java que recebia o nome do serviço como texto e invocava o método correspondente após validar a sessão do usuário.\n\nA classe que fazia essa distribuição de trabalho chegou a ter mais de mil e quinhentas linhas de código. Era difícil de manter, difícil de testar e, além de tudo, era bem feio.\n\nEm Clojure teríamos algo com essa cara:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn dispatcher [{service-name :service-name\n                   parameters   :parameters}]\n  (cond\n    (= service-name "activate-product")\n      (println "Ativando produto")\n    (= service-name "upload-data")\n      (println "Enviando dados")\n    :else\n      (println "Serviço não encontrado:" service-name)))\n')]),e._v("\n\nPara executar a função, passarímos os dados da requisição em um "),o("i",[e._v("hashmap")]),e._v(".\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(dispatcher {:service-name "activate-product"\n             :parameters 123})\n; Ativando produto\n\n(dispatcher {:service-name "desconhecido"\n             :parameters 123})\n; Serviço não encontrado: desconhecido\n')]),e._v("\n\nUma alternativa encontrada foi quebrar o código em pequenas classes, informando o nome do serviço correspondente em uma anotação. Uma outra classe pesquisava em tempo de execução pelo serviço que estava sendo invocado e executava a classe correta.\n\n"),o("index",{attrs:{entry:"Reflection"}}),e._v("\nO código ficou mais fácil de testar, mais simples de dar manutenção, mas ficou com cheiro de mágica, uma vez que foi feito uso pesado de "),o("i",[e._v("reflection")]),e._v(".\n\n"),o("box",{attrs:{title:"Reflection"}},[e._v("\nDe acordo com a documentação do Java"),o("bib",{attrs:{entry:"reflect-tutorial"}}),e._v(", "),o("i",[e._v("reflection")]),e._v(", ou "),o("i",[e._v("reflexão")]),e._v(", é normalmente utilizado por programas que necessitam examinar ou modificar o comportamento em tempo de execução.\n\n"),o("i",[e._v("Reflection")]),e._v(" é uma forma de utilizarmos metaprogramação em Java, ou seja, uma forma de manipularmos e acessarmos detalhes do programa enquanto ele está sendo executado. Vamos ver isso na prática ao aprendermos sobre integração com Java e "),o("i",[e._v("reader macros")]),e._v(".\n")],1),o("index",{attrs:{entry:"Dispatch, dynamic"}}),o("index",{attrs:{entry:"Dispatch, runtime"}}),e._v("\nEsse tipo de abordagem, quando o método a ser executado é definido em tempo de execução, é chamado "),o("i",[e._v("dynamic dispatch")]),e._v(", ou "),o("i",[e._v("runtime dispatch")]),e._v(".\n\n"),o("index",{attrs:{entry:"Runtime polymorphism"}}),e._v("\nFelizmente em Clojure é possível resolver esse problema sem apelar para gambiarras através de "),o("i",[e._v("polimorfismo em tempo de execução")]),e._v(", ou "),o("i",[e._v("runtime polymorphism")]),e._v(" no original em Inglês.\n\n"),o("index",{attrs:{entry:"Multiple dispatch"}}),o("index",{attrs:{entry:"Dispatch, multiple"}}),e._v("\nUma das formas de implementar esse tipo de polimorfismo é utilizando "),o("i",[e._v("multiple dispatch")]),e._v(", que nada mais é do que um nome bonito para a definição em tempo de execução para qual código será executado de acordo com parâmetros pré-definidos. Exatamente o que foi feito naquele servidor Java usando truques de metaprogramação.\n\n"),o("box",{attrs:{title:"Multiple dispatch"}},[e._v("\nNão existe uma tradução decente para o termo, então preferi manter assim mesmo. Você deve concordar comigo que "),o("i",[e._v("despachos múltiplos")]),e._v(" não faria muito sentido.\n")]),o("index",{attrs:{entry:"multimethod"}}),e._v("\nNo Clojure o recurso de "),o("i",[e._v("multiple dispatch")]),e._v(" aparece na forma de "),o("i",[e._v("multimethod")]),e._v(". É uma das formas que a linguagem utiliza para implementar polimorfismo, aquele conceito tão conhecido das linguagens orientadas a objeto.\n\nCom ele, o nosso exemplo do servidor ficaria bem mais simples e legível.\n\n"),o("index",{attrs:{entry:"defmulti"}}),e._v("\nPrimeiro devemos definir uma função de "),o("i",[e._v("dispatch")]),e._v(" através do operador "),o("code",[e._v("defmulti")]),e._v(". Função de "),o("i",[e._v("dispatch")]),e._v(" é aquela que "),o("i",[e._v("despacha as requisições")]),e._v(", ou seja, delega a responsabilidade a determinado trecho de código de acordo com os valores recebidos.\n\nO primeiro parâmetro é o próprio nome da função de "),o("i",[e._v("dispatch")]),e._v(", enquanto o segundo parâmetro é a função que vai tratar os dados recebidos. Caso você esteja trabalhando com um "),o("i",[e._v("hashmap")]),e._v(", pode também informar a chave que vai conter a informação necessária para invocar o método correto. No próximo capítulo vamos ver em detalhes como funciona um "),o("i",[e._v("hashmap")]),e._v(" e suas respectivas chaves.\n\nVamos usar uma chave de um "),o("i",[e._v("hashmap")]),e._v(" no nosso exemplo.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defmulti dispatcher :service-name)\n")]),e._v("\n\nAqui criamos um "),o("i",[e._v("multimethod")]),e._v(" chamado "),o("code",[e._v("dispatcher")]),e._v(", que vai usar o valor indicado pela chave "),o("code",[e._v(":service-name")]),e._v(" no "),o("i",[e._v("hashmap")]),e._v(" que será passado como parâmetro.\n\nAgora vamos criar os métodos que serão executados de acordo com o valor contido no "),o("i",[e._v("hashmap")]),e._v(". Métodos são funções especiais invocadas pelo "),o("i",[e._v("multimethod")]),e._v(".\n\n"),o("index",{attrs:{entry:"defmethod"}}),e._v("\nPara criar um método, você deve usar o operador "),o("code",[e._v("defmethod")]),e._v(", passando como argumentos o nome da função de "),o("i",[e._v("dispatch")]),e._v(", que é o mesmo que você usou com "),o("code",[e._v("defmulti")]),e._v(", o valor que vai definir se aquele método vai ser executado e o parâmetro que o método vai receber.\n\nNo nosso caso, o valor que define se o método vai ser executado é o nome do serviço, em formato texto mesmo.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defmethod dispatcher "activate-product" [request]\n  (println "Ativando produto"))\n\n(defmethod dispatcher "upload-data" [request]\n  (println "Enviando dados"))\n')]),e._v("\n\nPara executar o nosso "),o("i",[e._v("multimethod")]),e._v(", o código continua exatamente o mesmo:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(dispatcher {:service-name "activate-product"\n           :parameters 123})\n; Ativando produto\n\n(dispatcher {:service-name "upload-data"\n           :parameters 123})\n; Enviando dados\n')]),e._v("\n\nPorém, ao tentarmos invocar algum serviço que não tem um método associado, receberemos uma mensagem de erro:\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(dispatcher {:service-name \"desconhecido\"\n           :parameters 123})\n; IllegalArgumentException No method in multimethod 'dispatcher'\n; for dispatch value: desconhecido\n; clojure.lang.MultiFn.getFn (MultiFn.java:160)\n")]),o("index",{attrs:{entry:"multimethod :default"}}),e._v("\nPara resolver isso basta criarmos um método padrão, que recebe todas as requisições que não encontrarem um método. Basta utilizarmos o valor "),o("code",[e._v(":default")]),e._v(" como critério e tudo volta a funcionar.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defmethod dispatcher :default [request]\n  (println "Serviço não encontrado:"\n           (:service-name request)))\n\n(dispatcher {:service-name "desconhecido"\n             :parameters 123})\n; Serviço não encontrado: desconhecido\n')]),e._v("\n\nAgora, imagine que "),o("code",[e._v(":default")]),e._v(" já seja um valor válido na sua aplicação e você queira que o Clojure saia da sua frente e pare de atrapalhar. Teria como fazer o método padrão enxergar outro valor?\n\nSim, felizmente isso é possível. Basta mudarmos um pouco a declaração do "),o("i",[e._v("multimethod")]),e._v(" informando o valor padrão.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defmulti dispatcher :service-name :default :nao-encontrado)\n\n(defmethod dispatcher :nao-encontrado [request]\n  (println "Serviço não encontrado:"\n           (:service-name request)))\n\n(dispatcher {:service-name "desconhecido"\n             :parameters 123})\n; Serviço não encontrado: desconhecido\n')]),e._v("\n\nA melhor ferramenta é aquela que não atrapalha o seu trabalho.\n\n"),o("h3",[e._v("Overloading com tipos")]),o("index",{attrs:{entry:"static dispatch"}}),e._v("\nImagine agora que você tenha que invocar métodos diferentes de acordo com o tipo do parâmetro. No Java basta mudarmos a assinatura do método e o próprio compilador resolve a questão. Esse caso, em que o compilador define quem vai ser executado, é chamado de "),o("i",[e._v("static dispatch")]),e._v(".\n\n"),o("snippet",{attrs:{language:"java"}},[e._v('\npublic class OverloadPorTipo {\n  public static void qualTipo(String valor) {\n    System.out.println("É String");\n  }\n\n  public static void qualTipo(Number valor) {\n    System.out.println("É um número");\n  }\n\n  public static void qualTipo(Object valor) {\n    System.out.println("É um objeto");\n  }\n}\n\nOverloadPorTipo.qualTipo("Texto");\n// É String\n\nOverloadPorTipo.qualTipo(3.14);\n// É um número\n\nOverloadPorTipo.qualTipo(Boolean.TRUE);\n// É um objeto\n')]),e._v("\n\nPodemos chegar ao mesmo utilizando "),o("i",[e._v("multimethods")]),e._v(" que faz uso de "),o("i",[e._v("dynamic dispatch")]),e._v(".\n\n"),o("index",{attrs:{entry:"JavaREPL"}}),o("box",{attrs:{title:"Testando código Java"}},[e._v("\nVocê pode usar o "),o("i",[e._v("JavaREPL")]),e._v(" para testar códigos Java curtos, sem a necessidade de abrir um IDE.\n\nhttp://www.javarepl.com/\n")]),o("index",{attrs:{entry:"class"}}),e._v("\nLembrando que na declaração do "),o("i",[e._v("multimethod")]),e._v(" você informa a função que vai retornar o valor usado como critério, vamos utilizar a função "),o("code",[e._v("class")]),e._v(", que retorna a classe do valor recebido.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defmulti qual-tipo class)\n\n(defmethod qual-tipo java.lang.String [valor]\n  (println "É String"))\n\n(defmethod qual-tipo java.lang.Number [valor]\n  (println "É um número"))\n\n(defmethod qual-tipo java.lang.Object [valor]\n  (println "É um objeto"))\n')]),e._v("\n\nAgora vamos executar o nosso código. Note como ficou parecido com as chamadas do Java.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(qual-tipo "Texto")\n; É String\n\n(qual-tipo 3.14)\n; É um número\n\n(qual-tipo Boolean/TRUE)\n; É um objeto\n')]),o("index",{attrs:{entry:"Protocolos"}}),o("h2",[e._v("4.17. Polimorfismo com protocolos")]),e._v("\n\nProtocolos são um conjunto de funções que seguem uma regra predefinida.\n\nÉ como se você tivesse uma versão Clojure das interfaces do Java, onde você precisa implementar um conjunto mínimo métodos para que o seu objeto seja aceito, mas essa implementação fica por sua conta.\n\nDessa forma, podemos passar a implementação de um protocolo para uma função, que vai poder executar um conjunto de operações com ele sem medo de que a operação não saiba como lidar com o tipo de dado.\n\n"),o("index",{attrs:{entry:"Expression problem"}}),e._v("\nAlém do mais, o uso de protocolos permite que você estenda e complemente tipos já existentes, resolvendo assim um problema conhecido como "),o("i",[e._v("expression problem")]),e._v("."),o("bib",{attrs:{entry:"expression-problem"}}),e._v(".\n\nResumidamente, um "),o("i",[e._v("expression problem")]),e._v(" é um tipo de problema que não pode ser resolvido facilmente com Programação Funcional ou com Orientação a Objetos ao mesmo tempo"),o("bib",{attrs:{entry:"expression-problem-lammel"}}),e._v(".\n\nEm uma linguagem puramente funcional podemos facilmente adicionar código que trabalhe com dados sem a necessidade de alterar o código já existente, mas não conseguimos alterar os tipos já existentes sem modificar o código"),o("bib",{attrs:{entry:"expression-problem-fowler"}}),e._v(".\n\n"),o("image",{attrs:{src:"images/capitulo_08/expression-problem-fp.png",description:"Na Programação Funcional é fácil adicionar funcionalidades",width:"80%",label:"expression-problem-fp"}}),e._v("\n\nPor outro lado, em uma linguagem puramente orientada a objetos, podemos criar novos tipos de dados facilmente, mas não conseguimos adicionar funcionalidades ao código atual sem alterá-lo.\n\n"),o("image",{attrs:{src:"images/capitulo_08/expression-problem-oop.png",description:"Na Orientação a Objetos é fácil adicionar tipos",width:"80%",label:"expression-problem-oop"}}),o("index",{attrs:{entry:"Open classes"}}),o("index",{attrs:{entry:"Monkey patching"}}),e._v("\n\nNo Ruby esse problema é resolvido utilizando "),o("i",[e._v("open classes")]),e._v(", que é a habilidade de permitir que alteremos classes já existentes sem alterar o código que existe hoje. Essas alterações são chamadas de "),o("i",[e._v("monkey patching")]),o("bib",{attrs:{entry:"ruby-lucas"}}),e._v(".\n\nPor exemplo, todo texto é uma instância da classe "),o("code",[e._v("String")]),e._v(". Se quisermos saber quantas palavras tem um texto de uma maneira que toda "),o("code",[e._v("String")]),e._v(" tenha essa funcionalidade, basta adicionarmos o método diretamente na classe e automaticamente todo o nosso código terá acesso a ele.\n\nVamos chamar nosso método de "),o("code",[e._v("count_words")]),e._v(".\n\n"),o("snippet",{attrs:{language:"ruby"}},[e._v('\nfrase = "Meu cavalo come abobora"\n\nfrase.class\n# String\n\nfrase.count_words\n# NoMethodError: undefined method `count_words\' for\n# "Meu cavalo come abobora":String `\n')]),e._v("\n\nO método "),o("code",[e._v("count_words")]),e._v(" não existe na implementação padrão da classe "),o("code",[e._v("String")]),e._v(", então vamos adicioná-lo.\n\n"),o("snippet",{attrs:{language:"ruby"}},[e._v('\nclass String\n  def count_words\n    self.split(" ").count\n  end\nend\n\nfrase.count_words\n# 4\n')]),e._v("\n\nAgora vamos tentar com um texto que não existia quando adicionamos o método:\n\n"),o("snippet",{attrs:{language:"ruby"}},[e._v('\n"Essa frase eh nova em folha".count_words\n# 6\n')]),e._v("\n\nJá JavaScript resolve isso utilizando "),o("i",[e._v("prototipação")]),e._v(", que é a forma como a linguagem implementa Orientação a Objetos sem a necessidade de utilizar classes.\n\n"),o("snippet",{attrs:{language:"javascript"}},[e._v('\nconst frase = "Meu cavalo come abóbora";\n\ntypeof frase\n// "string"\n\nfrase.countWords();\n// VM417:2 Uncaught TypeError: frase.countWords is not a function\n// (anonymous function)\n\nString.prototype.countWords = function() {\n  return this.split(" ").length\n};\n\nfrase.countWords();\n// 4\n\n"Essa é outra frase qualquer".countWords();\n// 5\n')]),e._v("\n\nMas você comprou um livro de Clojure, e não de Ruby ou de JavaScript, então você deve estar curioso para saber como resolvemos isso sem apelar para outras linguagens.\n\nA primeira forma nós já vimos no capítulo "),o("label",{attrs:{entry:"capitulo-funcoes"}}),e._v(" e chama-se "),o("i",[e._v("multimethod")]),e._v(".\n\n"),o("index",{attrs:{entry:"multimethod"}}),o("i",[e._v("Multimethods")]),e._v(" são legais e bem poderosos, mas fazem uso de "),o("i",[e._v("dynamic dispatching")]),e._v(", decidindo em tempo de execução qual trecho de código vai ser chamado. Ao mesmo tempo que isso aumenta bastante a flexibilidade da linguagem, também acaba nos oferecendo um código relativamente lento.\n\nA outra forma é justamente usando protocolos, como o leitor mais atento já tinha imaginado.\n\nProtocolos são, basicamente, um conjunto de métodos e assinaturas sem as respectivas implementações, como se fosse uma interface Java. Inclusive, ao criar um protocolo, uma interface Java é criada internamente contendo todos métodos declarados.\n\n"),o("index",{attrs:{entry:"Dispatch, static"}}),o("index",{attrs:{entry:"Dispatch, compile time"}}),e._v("\nA grande vantagem dos protocolos em relação aos "),o("i",[e._v("multimethods")]),e._v(" está na velocidade, já que protocolos fazem "),o("i",[e._v("static dispatching")]),e._v(", ou "),o("i",[e._v("compile time dispatch")]),e._v(", que é a decisão em tempo de compilação de qual trecho de código será executado de acordo com o tipo de dado envolvido.\n\nVamos demonstrar como podemos utilizar polimorfismo com protocolos usando um exemplo do mundo real. Assim nós fugimos do manjado exemplo dos "),o("i",[e._v("cachorros e gatos são animais")]),o("label",{attrs:{entry:"dominando-js"}}),e._v(".\n\nEstamos desenvolvendo uma biblioteca de "),o("i",[e._v("log")]),e._v(", onde você pode registrar mensagens conforme o código vai sendo executado. Isso é muito útil para encontrar a causa de problemas na aplicação ou mesmo para entender melhor como ela funciona.\n\nPoderíamos simplesmente usar "),o("code",[e._v("println")]),e._v(" para exibir as mensagens, mas queremos algo mais dinâmico. Queremos ter a possibilidade de exibir as mensagens no console, ou gravar as mensagens em um arquivo ou em um banco de dados ou mesmo enviar para um servidor de "),o("i",[e._v("logs")]),e._v(". Tudo isso sem alterar o código que vai ser inspecionado.\n\nUm protocolo define apenas a estrutura que o nosso tipo de dados vai ter, sem qualquer detalhe sobre sua implementação.\n\nExistem três formas de implementarmos um protocolo.\n\nA primeira forma considera que um protocolo é apenas uma interface Java, já que internamente o Clojure vai criar uma interface para o protocolo e utiliza o operador "),o("code",[e._v("reify")]),e._v(". Vamos ver esse operador com calma no capítulo "),o("label",{attrs:{entry:"capitulo-integracao-java"}}),e._v(".\n\nAs duas outras formas são muito parecidas entre si, sendo que uma cria uma estrutura chamada "),o("i",[e._v("record")]),e._v(" e a outra cria uma estrutura chamada "),o("i",[e._v("type")]),e._v(". A diferença entre ambas é que "),o("i",[e._v("record")]),e._v(" é imutável e "),o("i",[e._v("type")]),e._v(" não.\n\nVamos utilizar "),o("i",[e._v("record")]),e._v(" para os nossos exemplos e deixar "),o("i",[e._v("type")]),e._v(" para o final, apenas para demonstrar como utilizar mutabilidade. Em todo o resto ambos funcionam da mesma forma.\n\nAo final do capítulo "),o("label",{attrs:{entry:"capitulo-integracao-java"}}),e._v(" você vai encontrar um diagrama que ajuda a escolher qual construção será utilizada de acordo com suas necessidades.\n\nVamos implementar um "),o("i",[e._v("record")]),e._v(" chamado "),o("code",[e._v("Loggable")]),e._v(", onde vamos definir quatro níveis de mensagem, de acordo com a gravidade do que queremos registrar.\n\nO nível mais baixo chama-se "),o("code",[e._v("debug")]),e._v(", com mensagens utilizadas apenas para depurar, ou "),o("i",[e._v("debugar")]),e._v(", a aplicação. O nível seguinte chama-se "),o("code",[e._v("warning")]),e._v(", com mensagens de alerta de que algo pode não estar de acordo com o esperado, como por exemplo uma tentativa de acesso ao sistema sem a devida autenticação.\n\nEm seguida temos "),o("code",[e._v("error")]),e._v(", para quando ocorre um erro que pode ser recuperado, como por exemplo um problema na conexão de rede e, finalmente, temos "),o("code",[e._v("fatal")]),e._v(", para quando ocorre um erro que não pode ser recuperado, como falta de memória ou algo grave dentro da JVM, e que obriga a aplicação a ser finalizada.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defprotocol Loggable\n  (debug   [this message])\n  (warning [this message])\n  (error   [this message ^Throwable e])\n  (fatal   [this message ^Throwable e]))\n; Loggable\n")]),e._v("\n\nCada método de um "),o("i",[e._v("record")]),e._v(" deve, obrigatoriamente, ter pelo menos um parâmetro que vai armazenar a referência a si mesmo. Imaginando um "),o("i",[e._v("procotol")]),e._v(" como uma interface Java e um "),o("i",[e._v("record")]),e._v(" ou "),o("i",[e._v("type")]),e._v(" como uma classe, é como se cada método recebesse o objeto "),o("code",[e._v("this")]),e._v(" como primeiro parâmetro.\n\nExatamente por conta dessa analogia eu chamei o primeiro parâmetro de cada método de "),o("code",[e._v("this")]),e._v(", mas você pode utilizar o nome que for mais conveniente.\n\nAlém de "),o("code",[e._v("this")]),e._v(", todos os métodos têm um parâmetro por onde você vai poder passar a mensagem a ser exibida. Note que "),o("code",[e._v("error")]),e._v(" e "),o("code",[e._v("fatal")]),e._v(" também têm um parâmetro "),o("code",[e._v("e")]),e._v(", que obrigatoriamente deve ser uma implementação de "),o("code",[e._v("java.lang.Throwable")]),e._v(".\n\nTodos os erros e exceções da JVM são implementações de "),o("code",[e._v("java.lang.Throwable")]),e._v(". Isso vai ser útil para que possamos saber exatamente onde ocorreu o erro.\n\nO caracter "),o("code",[e._v("^"),o("code",[e._v(" na frente de ")]),e._v("Throwable")]),e._v(" indica um "),o("i",[e._v("type hint")]),e._v(", que é uma forma de informarmos ao compilador com qual tipo queremos trabalhar ali. Veremos "),o("i",[e._v("type hints")]),e._v(" com calma no capítulo "),o("bib",{attrs:{entry:"capitulo-integracao-java"}}),e._v(".\n\nAgora vamos implementar o código da forma mais simples de "),o("i",[e._v("log")]),e._v(", que é aquela que exibe a informação na tela, ou no console, se preferir. Vamos chamar essa implementação de "),o("code",[e._v("ConsoleLogger")]),e._v(", que não vai receber nenhuma parâmetro em sua criação..\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defrecord ConsoleLogger []\n  Loggable\n  (debug   [this message]\n    (println "[DEBUG]" message)\n    message)\n  (warning [this message]\n    (println "[WARN ]" message)\n    message)\n  (error   [this message e]\n    (println "[ERROR]" message)\n    (.printStackTrace e)\n    message)\n  (fatal   [this message e]\n    (println "[FATAL]" message)\n    (.printStackTrace e)\n    message))\n; user.ConsoleLogger\n')]),e._v("\n\nPerceba que em "),o("code",[e._v("error")]),e._v(" e "),o("code",[e._v("fatal")]),e._v(" nós também exibimos o "),o("i",[e._v("stacktrace")]),e._v(" do erro, que é aquela lista de métodos e funções com os respectivos números de linha exibida sempre que ocorre um erro na execução do código.\n\nPerceba também que todos os nossos métodos retornam a própria mensagem que foi passada como parâmetro. Isso nos permite utilizar o "),o("i",[e._v("log")]),e._v(" dentro de um código sem alterar o resultado.\n\nAgora vamos criar um "),o("i",[e._v("var")]),e._v(" chamado "),o("code",[e._v("logger")]),e._v(", que armazenar uma instância de "),o("code",[e._v("ConsoleLogger")]),e._v(" e é por onde vamos utilizar nossa ferramenta de "),o("i",[e._v("log")]),e._v(".\n\nToda vez que você criar um "),o("i",[e._v("record")]),e._v(" ou um "),o("i",[e._v("type")]),e._v(", o Clojure vai te dar uma função iniciada por "),o("code",[e._v("->")]),e._v(" que cria o objeto para você. É como se fosse um construtor de uma classe Java.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def logger (->ConsoleLogger))\n\n(debug logger "Isso é uma mensagem de debug")\n; [DEBUG] Isso é uma mensagem de debug\n; "Isso é uma mensagem de debug"\n')]),e._v("\n\nAqui "),o("code",[e._v("debug")]),e._v(" não só exibiu a mensagem de depuração como também retornou o mesmo texto da entrada.\n\nO mesmo acontece com os demais métodos.\n\n"),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(warning logger "Uma mensagem de aviso")\n; [WARN ] Uma mensagem de aviso\n; "Uma mensagem de aviso"\n\n(error logger "Agora um erro" (java.io.FileNotFoundException.))\n; [ERROR] Agora um erro\n; java.io.FileNotFoundException\n;       at user$eval1137.invoke(NO_SOURCE_FILE:3)\n;       at clojure.lang.Compiler.eval(Compiler.java:6703)\n;       at clojure.lang.Compiler.eval(Compiler.java:6692)\n;       at clojure.lang.Compiler.eval(Compiler.java:6666)\n;; mais um monte de chamadas\n; "Agora um erro"\n\n(fatal logger "E aqui o mundo acabou" (StackOverflowError.)))\n; [FATAL] E aqui o mundo acabou\n; java.lang.StackOverflowError\n;       at user$eval1139.invoke(NO_SOURCE_FILE:4)\n;       at clojure.lang.Compiler.eval(Compiler.java:6703)\n;       at clojure.lang.Compiler.eval(Compiler.java:6693)\n;       at clojure.lang.Compiler.eval(Compiler.java:6666)\n;; mais um monte de chamadas\n; "E aqui o mundo acabou"\n')]),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(def w (java.io.FileWriter. "arquivo.log"))\n\n(.append w (str "Linha 1" \\return))\n(.flush w)\n')]),e._v("\n[TODO continuar daqui]\n\n"),o("h3",[e._v("A seguir...")]),e._v("\n\nApesar das funções serem uma parte muito importante da linguagem, como você deve ter notado pelo tamanho todo deste capítulo, elas não teriam muita utilidade sem as estruturas de dados que a linguagem oferece, e é isso que veremos com detalhes no próximo capítulo.\n")],1)},eo=[],ao={name:"Functions"},oo=ao,so=Object(l["a"])(oo,Za,eo,!1,null,null,null),ro=so.exports,to=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("page",[o("h1",[e._v("2. Uma introdução gentil ao Clojure")]),o("bib",{attrs:{entry:"bio-marvin-minsky"}}),o("chapter-quote",{attrs:{author:"Marvin Minsky"}},[e._v('\n    "Qualquer pessoa pode aprender LISP em um dia, exceto os que aprenderam FORTRAN. Esses demorarão três dias."\n  ')]),o("h2",[e._v("2.1 O que é Clojure?")]),o("index",{attrs:{entry:"CLR"}}),o("index",{attrs:{entry:"JVM"}}),o("index",{attrs:{entry:"Hickey, Rich"}}),o("p",{staticClass:"text-justify"},[e._v("A linguagem Clojure foi criada por Rich Hickey e lançada em 2007, focando o desenvolvimento na JVM, mas hoje em dia é possível executar a linguagem sobre a CLR (a máquina virtual do .NET) e mesmo sobre alguma "),o("i",[e._v("engine")]),e._v(" JavaScript, como o V8, que é a base do "),o("i",[e._v("Node.js")]),e._v(".")]),o("index",{attrs:{entry:"concorrência"}}),o("index",{attrs:{entry:"multithreading"}}),o("index",{attrs:{entry:"programação funcional"}}),o("index",{attrs:{entry:"JavaScript"}}),o("index",{attrs:{entry:"Scala"}}),o("p",{staticClass:"text-justify"},[e._v("É uma linguagem funcional, como o JavaScript e o Scala, e foi pensada para facilitar o desenvolvimento de aplicações que dependam de concorrência de processos e "),o("i",[e._v("multithreading")]),o("bib",{attrs:{entry:"clojure-rationale"}}),e._v(", o que não significa que não possa ser usada para criar outras aplicações que não dependam disso. Sistemas concorrentes que podem ser bem difíceis de desenvolver com Java acabam se tornando mais simples e concisos.")],1),o("p",{staticClass:"text-justify"},[e._v("É também um dialeto LISP"),o("bib",{attrs:{entry:"history-lisp"}}),e._v(", mas com mudanças interessantes na forma de apresentar a linguagem, o que elimina uma porção de parênteses"),o("bib",{attrs:{entry:"lisp-differences"}}),e._v(" quando comparamos códigos equivalentes escritos em Common Lisp ou Scheme, que são os dois dialetos LISP historicamente mais conhecidos.")],1),o("h2",[e._v("2.2 Configurando o ambiente")]),o("p",{staticClass:"text-justify"},[e._v("No decorrer do livro, vamos escrever código o tempo todo e é importante que você já tenha o ambiente instalado antes mesmo de inserir sua primeira instrução.")]),o("p",{staticClass:"text-justify"},[e._v("A primeira coisa que precisamos nos certificar é que você tenha o JDK instalado em sua máquina. Ele pode ser baixado no seguinte link:")]),o("p",{staticClass:"text-justify"},[o("code",[e._v("http://www.oracle.com/technetwork/java/javase/downloads/index.html")])]),o("p",{staticClass:"text-justify"},[e._v("Verifique se a versão instalada do Java é a 1.8 ou mais recente. As versões mais recentes do Clojure não funcionam com versões mais antigas do Java.")]),o("p",{staticClass:"text-justify"},[e._v("Digite "),o("code",[e._v("java -version")]),e._v(" em seu Prompt de Comandos ou Terminal para verificar se você está com a máquina virtual instalada e qual sua respectiva versão.")]),o("p",{staticClass:"text-justify"},[e._v("Após termos o JDK funcionando, vamos instalar uma ferramenta chamada "),o("i",[e._v("Leiningen")]),e._v(", que vai ser nosso grande companheiro mesmo depois que você terminar o livro.")]),o("p",{staticClass:"text-justify"},[e._v("O "),o("i",[e._v("Leiningen")]),e._v(" automatiza uma série de tarefas, gerencia dependências, agiliza a execução de testes, compilação e pode ser estendido com o uso de plugins. Existem plugins para praticamente todas as tarefas comuns que você precise executar ao desenvolver com Clojure. Para quem está vindo do Java, podemos entender o Leiningen como um primo turbinado do "),o("i",[e._v("Maven")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Acesse http://leiningen.org/#install e leia as instruções para instalação do script. Em seguida, execute o comando "),o("code",[e._v("lein -v")]),e._v(" para verificar a versão atual e baixar as dependências que serão usadas inicialmente.")]),o("p",{staticClass:"text-justify"},[e._v("Durante a escrita desse livro, o Leiningen estava em sua versão "),o("code",[e._v("2.9.0")]),e._v(", mas não se preocupe se a sua versão for mais recente enquanto você estiver lendo o livro.")]),o("p",{staticClass:"text-justify"},[e._v("Execute "),o("code",[e._v("lein")]),e._v(" sem nenhum parâmetro para ver as opções de uso do Leiningen. Voltaremos a elas assim que explicarmos a sintaxe da linguagem.")]),o("h2",[e._v("2.3 Explicando a sintaxe")]),o("p",{staticClass:"text-justify"},[e._v("É bem provável que você se assuste na primeira vez que ver um código Clojure, mas fique tranquilo, pois existe uma lógica muito simples por trás dessa cara diferentona.")]),o("p",{staticClass:"text-justify"},[e._v("É comum pensar num primeiro momento que o Clojure é invertido em relação às outras linguagens por conta da ordem em que as expressões são escritas, mas você vai acabar percebendo que, na verdade, a linguagem é consistente até demais se olharmos em perspectiva.")]),o("p",{staticClass:"text-justify"},[e._v("Relembrando das aulas de matemática, nós expressamos funções dessa forma:")]),o("snippet",{attrs:{language:"javascript"}},[e._v("y = f(x)")]),o("p",{staticClass:"text-justify"},[e._v("Para calcular o dobro, teríamos "),o("code",[e._v("y = f(x) = x * 2")]),e._v(", ou "),o("code",[e._v("y = x * 2")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Para calcularmos o dobro de um número, onde internamente calcularíamos o valor de um parâmetro "),o("code",[e._v("x")]),e._v(" multiplicado por "),o("i",[e._v("2")]),e._v(", teríamos:")]),o("snippet",{attrs:{language:"javascript"}},[e._v("y = dobro(21)")]),o("index",{attrs:{entry:"notação prefixa"}}),o("index",{attrs:{entry:"operador"}}),o("index",{attrs:{entry:"index operando"}}),o("p",{staticClass:"text-justify"},[e._v("Note que estamos usando uma notação diferente: primeiro vem o "),o("i",[e._v("operador")]),o("code",[e._v("dobro")]),e._v(" e, em seguida, vem o "),o("i",[e._v("operando")]),e._v(", ou parâmetro, "),o("i",[e._v("21")]),e._v(". Chamamos isso de "),o("i",[e._v("notação prefixa")]),e._v(".")]),o("box",{attrs:{title:"Notação prefixa, ou simbólica"}},[o("p",{staticClass:"text-justify"},[e._v("A notação prefixa utilizada no Clojure, e em qualquer outro LISP, é conhecida também como "),o("i",[e._v("S-Expression")]),e._v(". Esse nome vem do termo "),o("i",[e._v("Symbolic Expression")]),e._v(", ou expressão simbólica, onde uma lista contendo outras listas pode ser representada internamente como uma árvore.")]),o("p",{staticClass:"text-justify"},[e._v("O termo foi utilizado pela primeira vez por John McCarthy, o criador do "),o("i",[e._v("LISP")]),o("bib",{attrs:{entry:"lisp-1"}}),e._v(". Antes das "),o("i",[e._v("S-Expressions")]),e._v(", McCarthy tinha trabalhado com a ideia de "),o("i",[e._v("M-Expressions")]),e._v(", ou "),o("i",[e._v("meta-expressions")]),e._v(", mas a ideia foi descartada"),o("bib",{attrs:{entry:"history-lisp"}}),e._v(".")],1)]),o("p",{staticClass:"text-justify"},[e._v("Já para executar um cálculo aritmético, usamos a forma abaixo:")]),o("snippet",{attrs:{language:"javascript"}},[e._v("y = 21 * 2")]),o("index",{attrs:{entry:"notação infixa"}}),o("p",{staticClass:"text-justify"},[e._v("Primeiro temos um operando "),o("i",[e._v("21")]),e._v(", depois temos um operador responsável pela multiplicação e, finalmente, o segundo operando "),o("i",[e._v("2")]),e._v(". Chamamos essa forma de "),o("i",[e._v("notação infixa")]),e._v(".")]),o("box",{attrs:{title:"Se você veio do Ruby..."}},[o("index",{attrs:{entry:"Ruby"}}),o("p",{staticClass:"text-justify"},[e._v("Se você é um desenvolvedor Ruby, ignore esta última expressão.")]),o("p",{staticClass:"text-justify"},[e._v("No Ruby, o cálculo acima utiliza internamente a notação prefixa onde "),o("i",[e._v("21")]),e._v(" é um objeto, "),o("code",[e._v("*")]),e._v(" é um método (ou uma mensagem, se preferir) e "),o("i",[e._v("2")]),e._v(" é um parâmetro.")]),o("snippet",{attrs:{language:"ruby"}},[e._v("x = 21 * 2\n\ny = 21.*(2)")]),o("p",{staticClass:"text-justify"},[e._v("As duas formas são válidas e equivalentes, apesar da segunda ser mais difícil de ler.")])],1),o("p",{staticClass:"text-justify"},[e._v("A coisa fica bagunçada quando misturamos as duas formas:")]),o("snippet",{attrs:{language:"javascript"}},[e._v("y = dobro(7 * 3)")]),o("p",{staticClass:"text-justify"},[e._v("Na expressão acima misturamos notação prefixa com infixa. Não há problema algum com isso, mas não é um bom exemplo de consistência.")]),o("p",{staticClass:"text-justify"},[e._v("Quando falamos em Clojure, ou qualquer outra forma de LISP, o primeiro item de uma lista é um operador e todos os demais são operandos.")]),o("index",{attrs:{entry:"função"}}),o("index",{attrs:{entry:"macros"}}),o("index",{attrs:{entry:"forma especial"}}),o("p",{staticClass:"text-justify"},[e._v("Todo operador é uma "),o("i",[e._v("função")]),e._v(", "),o("i",[e._v("macro")]),e._v(" ou "),o("i",[e._v("forma especial")]),e._v(", inclusive os operadores matemáticos. Não se preocupe em entender agora o que são macros ou formas especiais.")]),o("p",{staticClass:"text-justify"},[e._v("Todo os itens do resto da lista são considerados valores, parâmetros ou operandos.")]),o("p",{staticClass:"text-justify"},[e._v("Imagine agora que o símbolo + é uma função. Para calcularmos uma soma usaríamos o seguinte código:")]),o("snippet",{attrs:{language:"javascript"}},[e._v("+(1, 2)")]),o("p",{staticClass:"text-justify"},[e._v("Movendo os parênteses e removendo as vírgulas, a nossa soma inicial ficaria:")]),o("snippet",{attrs:{language:"javascript"}},[e._v("(+ 1 2)")]),o("box",{attrs:{title:"Molhando os dedos"}},[o("p",{staticClass:"text-justify"},[e._v("Vamos usar uma ferramenta muito importante do Clojure chamada REPL. Não se preocupe agora em saber o que significa, pois teremos um capítulo todo só para isso.")]),o("p",{staticClass:"text-justify"},[e._v("No Terminal do seu sistema operacional, execute o comando "),o("code",[e._v("lein repl")]),e._v(" para carregar o REPL do Clojure. Se for a primeira vez que você o abre, algumas dependências ainda serão baixadas para o seu computador.")]),o("p",{staticClass:"text-justify"},[e._v("Digite a instrução "),o("code",[e._v("(+ 1 2)")]),e._v(" e pressione ENTER. A linha de baixo trará o resultado, "),o("i",[e._v("3")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Parabéns, você acabou de escrever seu primeiro código em Clojure e nós ainda nem começamos a aprender a linguagem.")]),o("p",{staticClass:"text-justify"},[e._v("Use o REPL para acompanhar os exemplos desse livro enquanto for lendo, digitando e vendo os resultados conforme você aprende.")]),o("p",{staticClass:"text-justify"},[e._v("Quando quiser sair do REPL, digite "),o("code",[e._v("exit")]),e._v(" e pressione ENTER.")])]),o("p",{staticClass:"text-justify"},[e._v("Sabemos que "),o("code",[e._v("dobro")]),e._v(" também é uma função. Para calcular "),o("code",[e._v("dobro")]),e._v(", usaríamos:")]),o("snippet",{attrs:{language:"clojure"}},[e._v("(dobro 21)")]),o("p",{staticClass:"text-justify"},[e._v("Percebam que agora temos uma regra que se aplica a todos os casos. Repetindo a expressão acima que mistura as notações infixa e prefixa usando as regras do LISP, teríamos:")]),o("snippet",{attrs:{language:"clojure"}},[e._v("(dobro (* 7 3))")]),o("box",{attrs:{title:"Testando 'dobro'"}},[o("p",{staticClass:"text-justify"},[e._v("Para que possamos testar todos os exemplos desse capítulo, precisamos criar uma função chamada "),o("code",[e._v("dobro")]),e._v(", que recebe um parâmetro "),o("code",[e._v("x")]),e._v(" e devolve seu valor multiplicado por dois.")]),o("p",{staticClass:"text-justify"},[e._v("Em Clojure, criamos uma função "),o("code",[e._v("dobro")]),e._v(" da seguinte forma:")]),o("snippet",{attrs:{language:"clojure"}},[e._v("(defn dobro [x]\n  (* x 2))")]),o("p",{staticClass:"text-justify"},[e._v("Agora vamos abrir o REPL e digitar as linhas abaixo:")]),o("snippet",{attrs:{language:"clojure"}},[e._v("(dobro 21)\n\n(dobro (* 7 3))")]),o("p",{staticClass:"text-justify"},[e._v("Em ambos os casos, você obterá o número "),o("i",[e._v("42")]),e._v(" como resposta.")]),o("p",{staticClass:"text-justify"},[e._v("Ah, e comemore: você acabou de escrever sua primeira função em Clojure. As funções são parte importantíssima de uma linguagem funcional.")])],1),o("p",{staticClass:"text-justify"},[e._v("Talvez pela sua origem acadêmica e fortemente influenciada pela matemática, as implementações de LISP levam muito a sério a questão da consistência.")]),o("h2",[e._v("Explicando os parênteses")]),o("index",{attrs:{entry:"expressões numéricas"}}),o("p",{staticClass:"text-justify"},[e._v("Quando eu estava na quarta série, aprendi algo chamado de "),o("i",[e._v("expressão numérica")]),e._v(", que consiste em resolver um cálculo extenso atacando um pedaço por vez, organizadamente.")]),o("p",{staticClass:"text-justify"},[e._v("Cada pedaço desse cálculo fica dentro de parênteses, colchetes ou chaves, dependendo do quão aninhado esteja a expressão. Eu nunca mais vi esse tipo de hierarquia, mas sempre considerei como um jeito bacana de manter a organização.")]),o("p",{staticClass:"text-justify"},[e._v("Uma expressão numérica tem essa cara:")]),o("snippet",{attrs:{language:"javascript"}},[e._v("x = {1 + [3 * (5 + 7)]}")]),o("p",{staticClass:"text-justify"},[e._v("Resolve a expressão de dentro para fora:")]),o("snippet",{attrs:{language:"javascript"}},[e._v("x = {1 + [3 * (12)]}\n\nx = {1 + [36]}\n\nx = {37}\n\nx = 37")]),o("p",{staticClass:"text-justify"},[e._v("Simples, não?")]),o("p",{staticClass:"text-justify"},[e._v("Agora vamos extrapolar o que aprendemos na quarta série para uma linguagem de programação, trocando chaves e colchetes por parênteses:")]),o("snippet",{attrs:{language:"javascript"}},[e._v("x = (1 + (3 * (5 + 7)))")]),o("p",{staticClass:"text-justify"},[e._v("Vamos substituir a nossa conhecida notação infixa pela prefixa:")]),o("snippet",{attrs:{language:"javascript"}},[e._v("x = (+ 1 (* 3 (+ 5 7)))")]),o("p",{staticClass:"text-justify"},[e._v("Pronto. Você tem uma expressão numérica com a cara do LISP, resolvendo da forma como a professora ensinou lá na quarta série: primeiro você resolve os parênteses de dentro, depois os próximos, até terminar.")]),o("p",{staticClass:"text-justify"},[e._v("Pode parecer estranho, mas não se preocupe, com o tempo essa notação não te trará dificuldades na leitura e entendimento do código. E há sim mais razões pela qual ela é dessa maneira, que desvendaremos aos poucos.")]),o("p",{staticClass:"text-justify"},[e._v("Qualquer LISP que você encontrar pela frente, incluindo o Clojure, funciona exatamente dessa maneira.")]),o("index",{attrs:{entry:"precedência de operadores"}}),o("p",{staticClass:"text-justify"},[e._v("Uma vantagem que isso traz é que você não precisa ficar se preocupando com precedência de operadores. Imagine que você tem o código abaixo:")]),o("snippet",{attrs:{language:"javascript"}},[e._v("x = 3 * 2 + 1\n\ny = 1 + 2 * 3")]),o("p",{staticClass:"text-justify"},[e._v("Os valores de "),o("code",[e._v("x")]),e._v(" e "),o("code",[e._v("y")]),e._v(" serão iguais? Sim, ambas as variáveis contém o número "),o("i",[e._v("7")]),e._v(", mas para saber disso você precisou ler em algum outro lugar que "),o("i",[e._v("o operador de multiplicação tem precedência sobre o operador de adição")]),e._v(". É algo que você espera que seja assim e age como se realmente fosse.")]),o("p",{staticClass:"text-justify"},[e._v("E o que aconteceria se você estiver usando uma linguagem em que a adição tem precedência sobre a multiplicação? Ou pior ainda: os operadores são executados da esquerda para a direita conforme forem aparecendo.")]),o("p",{staticClass:"text-justify"},[e._v("No primeiro caso, "),o("code",[e._v("x")]),e._v(" e "),o("code",[e._v("y")]),e._v(" continuariam sendo iguais, mas ambos teriam o valor "),o("i",[e._v("9")]),e._v(". No segundo caso, "),o("code",[e._v("x")]),e._v(" seria igual a "),o("i",[e._v("7")]),e._v(" e "),o("code",[e._v("y")]),e._v(" seria igual a "),o("i",[e._v("9")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Seria mais fácil se as expressões fossem escritas assim:")]),o("snippet",{attrs:{language:"javascript"}},[e._v("x = (3 * 2) + 1\n\ny = 1 + (2 * 3)")]),o("p",{staticClass:"text-justify"},[e._v("Agora está claro para qualquer pessoa o que vai ser executado primeiro, independente do modo como a expressão seja interpretada pela linguagem. Pois saiba que é exatamente assim que um LISP trabalha. Usando a notação prefixa, as expressões acima ficariam da forma a seguir, que você pode testar usando o REPL:")]),o("snippet",{attrs:{language:"javascript"}},[e._v("(+ (* 3 2) 1)\n\n(+ 1 (* 3 2))")]),o("p",{staticClass:"text-justify"},[e._v("Primeiro será executada a multiplicação, que está nos parênteses mais internos e, em seguida, será executada a adição. Tudo isso sem se preocupar com regras ocultas ou peculiaridades do compilador.")]),o("p",{staticClass:"text-justify"},[e._v("No capítulo a seguir, vamos aprender mais sobre o REPL para que possamos utilizar Clojure de uma forma rápida e produtiva.")])],1)},no=[],io={name:"GentleIntroduction"},mo=io,uo=Object(l["a"])(mo,to,no,!1,null,null,null),co=uo.exports,lo=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("page",[o("h1",[e._v("Sobre a versão online")]),o("h2",[e._v("Instruções")]),o("h2",[e._v("Prefácio da versão online")]),o("p",{staticClass:"text-justify"},[e._v("\n  Quando comecei a escrever este livro há alguns anos, havia uma total\n  falta de material em Português, com exceção de alguns posts em blogs\n  técnicos e algumas poucas palestras. O autor do prefácio, Paulo Suzart,\n  foi pioneiro ao escrever sobre Clojure e eu o acompanhei algum tempo depois.\n  Isso foi em 2008 e pouca coisa aconteceu nesse sentido desde então.\n  ")]),o("p",{staticClass:"text-justify"},[e._v("\n  Hoje, felizmente, o cenário está um pouco melhor. Temos um livro publicado\n  em Português tratando da linguagem que satisfaz os iniciantes e os traz\n  para mais perto, sem que tenham que depender da documentação padrão da\n  linguagem, que é longe de ser amigável.\n  ")]),o("p",{staticClass:"text-justify"},[e._v("\n  Por falha única e exclusivamente minha, por uma série de motivos alheios\n  a este foro, este acabou não sendo o tal livro pioneiro. De qualquer\n  maneira havia aqui conteúdo o bastante, já testado e amadurecido, e seria\n  um grande desperdício deixá-lo guardado. Estas últimas são, inclusive,\n  palavras dos revisores e dos primeiros leitores da obra, que tiveram\n  acesso a ela muito antes de qualquer publicação ser feita.\n  ")]),o("p",{staticClass:"text-justify"},[e._v("\n  Finalmente, o resultado de tantos anos de trabalho e espera está sendo\n  disponibilizado a você, gratuitamente, gradualmente e online. Conforme\n  o último trecho for publicado, disponibilizarei também a opção de adquirir\n  a versão em papel. Seria uma forma de me ajudar e também de satisfazer\n  aqueles que preferem um livro físico para ler e fazer anotações. Estou\n  considerando a publicação em ebook também, mas talvez seja redundante.\n  Vamos ver como vai ser.\n  ")]),o("p",{staticClass:"text-justify"},[e._v("\n  Desde já agradeço seu interesse, espero realmente que o conteúdo do livro\n  atenda às suas expectativas e necessidades e fique à vontade para oferecer\n  sua opinião, indicação de erros ou mesmo sugestões de melhoria.\n  ")]),o("p",{staticClass:"text-justify"},[e._v("\n  Para sugestões ou correções, utilize o sistema de "),o("i",[e._v("issues")]),e._v(" em "),o("a",{attrs:{href:"https://github.com/pbalduino/descobrindoclojure"}},[e._v("https://github.com/pbalduino/descobrindoclojure")])]),o("p",{staticClass:"text-justify"},[e._v("\n  Aproveite.\n  ")])])},vo=[],po={name:"OnlineVersion"},_o=po,fo=Object(l["a"])(_o,lo,vo,!1,null,null,null),go=fo.exports,qo=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("page",[o("h1",[e._v("1. Apresentação")]),o("index",{attrs:{entry:"Whyte, David"}}),o("chapter-quote",{attrs:{author:"David Whyte, poeta"}},[e._v('\n  "Anything or anyone that does not bring you alive is too small for you"\n')]),o("h2",[e._v("1.1 Por que Clojure?")]),o("index",{attrs:{entry:"Raymond, Eric"}}),o("chapter-quote",{attrs:{author:"Eric Raymond em",work:"How to become a hacker"}},[e._v('\n"Vale a pena aprender LISP pela experiência de profunda iluminação que você terá quando finalmente o entender; essa experiência o tornará um programador melhor para o resto de sua vida, mesmo que você raramente use LISP."\n')]),o("p",{staticClass:"text-justify"},[o("i",[e._v('"Afinal, por que Clojure?"')])]),o("p",{staticClass:"text-justify"},[e._v("Talvez essa seja a pergunta que você se faça ao ver um livro sobre o assunto. Talvez seja a pergunta que você mais escute de chefes ou colegas de trabalho ao comentar sobre a linguagem.")]),o("p",{staticClass:"text-justify"},[e._v("Eu poderia dizer que Clojure é uma excelente ferramenta para que você trabalhe com processamento concorrente sem toda a complicação de ter que gerenciar "),o("i",[e._v("locks")]),e._v(" e "),o("i",[e._v("racing conditions")]),e._v(", além de oferecer nativamente formas de compartilhar estados entre "),o("i",[e._v("threads")]),e._v(" de acordo com a sua necessidade, mas nem toda aplicação que você desenvolver depende de "),o("i",[e._v("multithread")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Eu poderia demonstrar como a estratégia de "),o("i",[e._v("lazy evaluation")]),e._v(" permite que você processe quantidades absurdamente grandes de informação sem acabar com a memória da máquina e ainda assim retornar um resultado em um tempo aceitável, mas nem todo mundo tem quantidades absurdamente grandes de informação para trabalhar.")]),o("p",{staticClass:"text-justify"},[e._v("Poderia dizer também que Clojure é uma linguagem funcional, e a programação funcional naturalmente leva a códigos menores e mais simples, evitando boa parte da complexidade trazida pela orientação a objetos com a qual nos habituamos, mas a orientação a objetos é hoje um padrão de mercado e inúmeros problemas continuam sendo resolvidos assim.")]),o("p",{staticClass:"text-justify"},[e._v("Eu poderia também apontar que Clojure naturalmente faz com que você escreva funções menores e mais especializadas, aumentando o reuso de código e reduzindo a quantidade de bugs no sistema, mas utilizar boas práticas de programação também causam esse mesmo efeito com qualquer outra linguagem.")]),o("p",{staticClass:"text-justify"},[e._v("Eu posso argumentar que Clojure me ajudou a ver o perigo da mutabilidade espalhada por um sistema, e como isso me tornou um programador melhor e mais cuidadoso em Java ou em qualquer outra linguagem que eu use no dia a dia, limitando as partes móveis onde for realmente necessário e fazendo meu código ficar "),o("i",[e._v("thread-safe")]),o("bib",{attrs:{entry:"java-threads"}}),e._v(" sem perder legibilidade ou produtividade.")],1),o("p",{staticClass:"text-justify"},[e._v("Eu poderia dizer que Clojure tem um elegante sistema de macros, que permite que você adicione construções à linguagem que podem tornar seu código muito mais expressivo e elegante, ou mesmo criar DSLs conforme a sua necessidade sem ter que criar compiladores para isso, mas linguagens líderes de mercado não têm esse recurso e nosso trabalho continua sendo entregue com elas.")]),o("p",{staticClass:"text-justify"},[e._v("Posso demonstrar para o meu chefe que um sistema pode ser desenvolvido em um tempo menor, com menos bugs e ainda assim o código continua compreensível para qualquer colega novo que tiver que dar manutenção nele.")]),o("p",{staticClass:"text-justify"},[e._v("Eu posso também mostrar que você não precisa reinventar a roda, desenvolvendo novamente bibliotecas que já foram testadas e aprovadas, mas sim aproveitar de forma transparente todo o ecossistema já existente hoje que torna a plataforma Java tão poderosa e abrangente e, sem esforço, ainda pode aproveitar todo o poder e maturidade da JVM.")]),o("p",{staticClass:"text-justify"},[e._v("Mas, além de todas essas vantagens, eu vou dizer a você que Clojure é uma linguagem que além de divertida e expressiva, aumenta consideravelmente seu arsenal de técnicas para resolver problemas, mesmo que no dia a dia você acabe utilizando qualquer outra linguagem.")]),o("h2",[e._v("1.2 Para quem é esse livro")]),o("p",{staticClass:"text-justify"},[e._v("Este livro foi escrito para quem que já tem alguma experiência com desenvolvimento de software e compreende conceitos básicos como operadores lógicos, desvios condicionais, estruturação de código em funções, módulos e classes.")]),o("p",{staticClass:"text-justify"},[e._v("Vai ajudar bastante se você já estiver familiarizado com a máquina virtual do Java, mas é possível acompanhar o livro inteiro sem nunca ter escrito uma linha de código em Java ou qualquer outra linguagem para a JVM.")]),o("p",{staticClass:"text-justify"},[e._v("Finalmente, não é necessário qualquer conhecimento prévio de LISP, Clojure ou fundamentos de programação funcional. O propósito deste livro é justamente te guiar através desses conceitos sem cair nas armadilhas do jargão acadêmico.")]),o("h2",[e._v("1.3 Como o livro está organizado")]),o("p",{staticClass:"text-justify"},[e._v("No mercado de livros técnicos, existem duas formas muito comuns:")]),o("p",{staticClass:"text-justify"},[e._v('A primeira consiste em pegar a documentação da linguagem ou da ferramenta e ir explicando item a item. Com isso temos aqueles livros gigantescos intitulados "bíblias", que faziam muito sentido antes da popularização da Internet. Hoje em dia qualquer um pode entrar no seu site de busca preferido e alcançar qualquer informação que precisar, sem precisar gastar dinheiro com um livro.')]),o("p",{staticClass:"text-justify"},[e._v("A segunda forma são os "),o("i",[e._v("cookbooks")]),e._v(", livros com receitas para resolver problemas do dia-a-dia. São livros muito interessantes para quem já conhece a ferramenta, mas não são acessíveis para quem está começando porque focam em resolver problemas reais e deixam de lado as informações básicas, criando dúvidas para quem ainda não tem a base necessária.")]),o("p",{staticClass:"text-justify"},[e._v("Eu particularmente gosto muito desse tipo de livro depois que já me familiarizei com os conceitos e características da linguagem ou ferramenta.")]),o("p",{staticClass:"text-justify"},[e._v("Este livro segue um terceiro caminho, botando a mão na massa o tempo todo, mas explicando os conceitos por trás de cada código, num ritmo que começa devagar e vai acelerando conforme o leitor vai se habituando ao Clojure.")]),o("p",{staticClass:"text-justify"},[e._v("Ao escrever este livro tentamos apresentar as informações com o máximo de simplicidade possível, para que o leitor que nunca teve contato com LISP ou programação funcional consiga absorver todo o conteúdo sem problemas.")]),o("box",{attrs:{title:"Abrindo parênteses"}},[o("p",{staticClass:"text-justify"},[e._v("No decorrer do livro teremos essas caixas, chamadas pelos editores de "),o("i",[e._v("boxes")]),e._v(", que contém dicas e conteúdo relacionado ao assunto que estamos vendo.")]),o("p",{staticClass:"text-justify"},[e._v("Geralmente são textos que apresentam conceitos que não influem diretamente no texto, mas fazem com que você entenda o que há por trás de um conceito ou que experimente algo diferente sem que o texto em si perca o ritmo.")]),o("p",{staticClass:"text-justify"},[e._v("Caso esteja com muita pressa, você pode pular o conteúdo do "),o("i",[e._v("box")]),e._v(" sem prejuízo para a leitura e voltar mais tarde, depois de descansar um pouco.")])]),o("p",{staticClass:"text-justify"},[e._v("No decorrer do livro são usadas algumas convenções que vale a pena conhecer:")]),o("p",{staticClass:"text-justify"},[o("i",[e._v("Trechos em itálico")]),e._v(" indicam termos em inglês ou outro idioma que não costumam ser traduzidos ou "),o("i",[e._v("links")]),e._v(" para sites. Por exemplo, neste livro você vai encontrar a palavra "),o("i",[e._v("framework")]),e._v(" ao invés de arcabouço, pelo bem da leitura.")]),o("p",{staticClass:"text-justify"},[o("b",[e._v("Trechos em negrito")]),e._v(" indicam pontos muito importantes que "),o("b",[e._v("devem ser lidos com maior atenção")]),e._v(".")]),o("p",{staticClass:"text-justify"},[o("code",[e._v("Trechos em fonte monoespaçada")]),e._v(" indicam código, nomes de arquivos, classes ou "),o("i",[e._v("namespaces")]),e._v(".")]),o("h2",[e._v("1.4 Lista de discussão e código fonte")]),o("p",{staticClass:"text-justify"},[e._v("Disponibilizamos uma lista de discussão sobre o livro, onde você pode tirar suas dúvidas, apontar correções, indicar melhorias e o que mais achar relevante para o outros leitores:")]),o("index",{attrs:{entry:"lista de discussão"}}),o("p",{staticClass:"text-justify"},[e._v("http://goo.gl/eYmGy"),o("br"),e._v("\nou\nhttps://groups.google.com/forum/?fromgroups#!forum/casadocodigo-clojure")]),o("p",{staticClass:"text-justify"},[e._v("O código fonte estará disponível no GitHub, no endereço abaixo:")]),o("index",{attrs:{entry:"código fonte"}}),o("p",{staticClass:"text-justify"},[e._v("https://github.com/pbalduino/livro-clojure")]),o("p",{staticClass:"text-justify"},[e._v("Sinta-se à vontade para enviar dúvidas e alterar os fontes conforme você for avançando no livro.")])],1)},bo=[],xo={name:"Presentation"},jo=xo,ho=Object(l["a"])(jo,qo,bo,!1,null,null,null),yo=ho.exports,Co=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("page",[o("h1",[e._v("3. O REPL é tão importante...")]),o("chapter-quote",{attrs:{author:"Brian Kernighan,",work:"coautor do UNIX e da linguagem C"}},[e._v('"A única forma de se aprender uma nova linguagem é escrevendo programas nela"')]),o("h2",[e._v("3.1. ... que merece um capítulo a parte")]),o("index",{attrs:{entry:"REPL"}}),o("p",{staticClass:"text-justify"},[e._v("O "),o("code",[e._v("REPL")]),e._v(" é uma das ferramentas mais úteis para se programar em Clojure. Se você está chegando do Ruby ou do Python está mais do que acostumado a usar o "),o("code",[e._v("IRB")]),e._v(" ou o modo interativo do Python. Veremos no decorrer do capítulo que o REPL é bem mais do que um prompt da linguagem, que serve apenas para que instruções sejam testadas.")]),o("p",{staticClass:"text-justify"},[e._v("O termo "),o("code",[e._v("REPL")]),e._v(", pronuncia-se "),o("i",[e._v("Répol")]),e._v(" com aquele "),o("i",[e._v("R")]),e._v(" do Chico Bento, é formado pelas iniciais de "),o("i",[e._v("Read-Eval-Print-Loop")]),e._v(", que é o ciclo efetuado pela ferramenta ao "),o("b",[e._v("Ler")]),e._v(" a instrução digitada pelo programador, "),o("b",[e._v("avaliar")]),e._v(" e executar a instrução, "),o("b",[e._v("imprimir")]),e._v(" o resultado e "),o("b",[e._v("voltar")]),e._v(" ao início, aguardando a próxima instrução, como na figura "),o("ref-label",{attrs:{entry:"repl-diagram"}}),e._v(".")],1),o("image",{attrs:{src:"images/capitulo_03/repl_diagram.png",description:"Read-eval-print-loop",width:"40%",label:"repl-diagram"}}),o("box",{attrs:{title:"O que é avaliar?"}},[o("index",{attrs:{entry:"avaliar"}}),o("p",{staticClass:"text-justify"},[e._v("Quando estamos usando algum dialeto LISP, como é o caso do Clojure, é comum usarmos o termo "),o("b",[e._v("avaliar")]),e._v(" para descrever o momento em que o comando é analisado e executado pelo interpretador da linguagem.")]),o("p",{staticClass:"text-justify"},[e._v("Então, sempre que você se deparar com o verbo "),o("b",[e._v("avaliar")]),e._v(", entenda que a instrução está sendo lida e interpretada.")])],1),o("p",{staticClass:"text-justify"},[e._v("A grande vantagem dessa abordagem é que o desenvolvedor vê o resultado imediatamente, sem a necessidade de compilar o projeto, executar e esperar a resposta. Com isso, você pode testar diferentes abordagens e até mesmo brincar com instruções para chegar ao resultado esperado num período muito curto.")]),o("p",{staticClass:"text-justify"},[e._v("Após instalarmos o Leiningen, como vimos no capítulo passado, vamos abrir o REPL executando o comando abaixo no seu terminal:")]),o("snippet",[e._v("lein repl")]),o("p",{staticClass:"text-justify"},[e._v("Vamos ver mensagens parecidas com a da figura "),o("ref-label",{attrs:{entry:"lein-repl"}}),e._v(".")],1),o("image",{attrs:{src:"images/capitulo_03/lein_repl.png",description:"REPL do Clojure",width:"70%",label:"lein-repl"}}),o("p",{staticClass:"text-justify"},[e._v("Essas mensagens foram adicionadas na versão 1.5 do Clojure e te dão algumas dicas sobre como se achar dentro da ferramenta. Para nós, o importante agora vai ser a última linha, que tem o cursor piscando, aguardando os nossos comandos.")]),o("snippet",[e._v("user=>")]),o("index",{attrs:{entry:"namespace"}}),o("index",{attrs:{entry:"user"}}),o("p",{staticClass:"text-justify"},[e._v("O texto "),o("code",[e._v("user")]),e._v(" indica o "),o("i",[e._v("namespace")]),e._v(" em que estamos trabalhando. Vamos falar disso mais para frente, mas por enquanto é suficiente saber que um "),o("i",[e._v("namespace")]),e._v(" é como se fosse um pacote contendo funções que lidam com determinada parte do trabalho. Outras linguagens implementam essa forma de organização, como o Java com "),o("i",[e._v("packages")]),e._v(", C# e C++ também com "),o("i",[e._v("namespaces")]),e._v(" ou Ruby e Python com "),o("i",[e._v("modules")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Vamos começar exibindo valores simples, omitindo a exibição do namespace para evitar confusão ao digitar. Perceba que não estamos usando parênteses, já que se tratam de valores, e não expressões a serem avaliadas:")]),o("snippet",[e._v('\n1\n\ntrue\n\n"Texto"\n')]),o("p",{staticClass:"text-justify"},[e._v("Exibimos um número inteiro, um valor lógico e um texto. A saída dos dados pode ser vista na figura "),o("ref-label",{attrs:{entry:"repl-values"}}),e._v(".")],1),o("image",{attrs:{src:"images/capitulo_03/repl_values.png",description:"Exibindo valores simples",width:"90%",label:"repl-values"}}),o("p",{staticClass:"text-justify"},[e._v("Vamos agora executar algumas expressões. Como já dissemos, uma expressão deve estar entre parênteses para ser executada, ou se preferir, avaliada.")]),o("index",{attrs:{entry:"not"}}),o("index",{attrs:{entry:"or"}}),o("snippet",[e._v("\n;; uma soma simples\n(+ 1 2)\n; 3\n\n;; o operador not e um valor booleano\n(not true)\n; false\n\n;; o operador or e dois valores booleanos\n(or false true)\n; true\n")]),o("p",{staticClass:"text-justify"},[e._v("Podemos ver o resultado na figura "),o("ref-label",{attrs:{entry:"repl-expressions"}}),e._v(".")],1),o("image",{attrs:{src:"images/capitulo_03/repl_expressions.png",description:"Exibindo os resultados de expressões",width:"90%",label:"repl-expressions"}}),o("p",{staticClass:"text-justify"},[e._v("Uma coisa interessante que o uso da notação prefixa permite é que um operador não precisa trabalhar com os valores de dois em dois, como acontece com uma adição ou um operador lógico na notação infixa.")]),o("p",{staticClass:"text-justify"},[e._v("É possível, por exemplo, somar inúmeros valores de uma vez só, tendo o resultado da figura "),o("ref-label",{attrs:{entry:"repl-multiple-values"}}),e._v(".")],1),o("snippet",[e._v("\n; uma soma com vários valores\n(+ 1 2 3 4 5 6)\n\n; o operador or com vários valores\n(or true false true false true true)\n")]),o("image",{attrs:{src:"images/capitulo_03/repl_multiple_values.png",width:"90%",description:"Múltiplos valores",label:"repl-multiple-values"}}),o("index",{attrs:{entry:"println"}}),o("index",{attrs:{entry:"print"}}),o("p",{staticClass:"text-justify"},[e._v("Existe uma função chamada "),o("code",[e._v("println")]),e._v(" que, veja só, imprime valores na tela e pula uma linha. Há uma irmã dela que não pula linha e chama-se "),o("code",[e._v("print")]),e._v(", mas dificilmente vamos usá-la aqui.")]),o("index",{attrs:{entry:"nil"}}),o("p",{staticClass:"text-justify"},[e._v("Essa função "),o("code",[e._v("println")]),e._v(" retorna "),o("code",[e._v("nil")]),e._v(", que é a representação de um valor nulo no Clojure. Por conta disso, não se preocupe com o "),o("code",[e._v("nil")]),e._v(" que é exibido após a impressão do valor.")]),o("p",{staticClass:"text-justify"},[e._v("Você pode passar quantos parâmetros quiser para essa função, e ela vai imprimir um a um, até terminar.")]),o("snippet",[e._v('\n(println 3)\n\n(println "Um texto" "Outro texto")\n')]),o("p",{staticClass:"text-justify"},[e._v("Primeiro mandamos imprimir na tela um valor qualquer e, em seguida, mandamos exibir dois textos. Podemos ver como ficou na figura "),o("ref-label",{attrs:{entry:"repl-println"}}),e._v(".")],1),o("p",{staticClass:"text-justify"},[e._v("Perceba que os valores são impressos e, logo abaixo, é exibido "),o("code",[e._v("nil")]),e._v(". A impressão é o "),o("i",[e._v("efeito colateral")]),e._v(" da função, e "),o("code",[e._v("nil")]),e._v(" é o retorno.")]),o("image",{attrs:{src:"images/capitulo_03/repl_println.png",description:"Usando a função println",width:"90%",label:"repl-println"}}),o("p",{staticClass:"text-justify"},[e._v("Agora vamos imprimir o resultado da soma entre os números "),o("i",[e._v("1")]),e._v(" e "),o("i",[e._v("2")]),e._v(", conforme a figura "),o("ref-label",{attrs:{entry:"repl-println-expression-fail"}})],1),o("image",{attrs:{src:"images/capitulo_03/repl_println_expression_fail.png",description:"Não imprimiu o que queríamos",width:"90%",label:"repl-println-expression-fail"}}),o("p",{staticClass:"text-justify"},[e._v("Ao invés do número "),o("i",[e._v("3")]),e._v(", foram exibidos os três itens da nossa expressão: o sinal de adição, que nada mais é do que o nome de uma função, e os números "),o("i",[e._v("1")]),e._v(" e "),o("i",[e._v("2")]),e._v(".")]),o("index",{attrs:{entry:"+"}}),o("index",{attrs:{entry:"-"}}),o("index",{attrs:{entry:"*"}}),o("index",{attrs:{entry:"/"}}),o("index",{attrs:{entry:"="}}),o("index",{attrs:{entry:">"}}),o("index",{attrs:{entry:"<"}}),o("index",{attrs:{entry:"_"}}),o("p",{staticClass:"text-justify"},[e._v("Em Clojure, os sinais "),o("code",[e._v("+")]),e._v(", "),o("code",[e._v("-")]),e._v(", "),o("code",[e._v("*")]),e._v(", "),o("code",[e._v("/")]),e._v(", "),o("code",[e._v("=")]),e._v(", "),o("code",[e._v(">")]),e._v(", "),o("code",[e._v("<")]),e._v(" e "),o("code",[e._v("_")]),e._v(", e as combinações entre eles, são considerados nomes válidos de função.")]),o("index",{attrs:{entry:"if"}}),o("p",{staticClass:"text-justify"},[e._v("O aprendizado fica muito mais fácil quando você percebe que os operadores aritméticos, lógicos e de comparação são funções como quaisquer outras. De certo modo, até mesmo um "),o("code",[e._v("if")]),e._v(" é uma função em Clojure.")]),o("p",{staticClass:"text-justify"},[e._v("Aí você pergunta: "),o("i",[e._v('"mas, se + é um nome válido de função, por que foi que o REPL imprimiu '),o("code",[e._v("#<core$_PLUS_ ...>")]),e._v(' ao invés do sinal de adição?"')])]),o("index",{attrs:{entry:"bytecode"}}),o("p",{staticClass:"text-justify"},[e._v("Simplesmente porque o Clojure gera "),o("i",[e._v("bytecode")]),e._v(" que é executado na JVM (ou na máquina virtual do .NET), e os símbolos citados acima não são nomes válidos nesses ambientes. Então a linguagem é obrigada a criar uma função interna chamada "),o("code",[e._v("_PLUS_")]),e._v(" que ganha o apelido "),o("code",[e._v("+")]),e._v(" para que o seu código fique fácil de ler.")]),o("box",{attrs:{title:"O que é bytecode"}},[o("p",{staticClass:"text-justify"},[e._v("Uma das ideias mais fortes por trás do Java é "),o("i",[e._v("escreva uma vez, rode em qualquer lugar")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Para que isso aconteça, o compilador do Java gera um código intermediário, independente de plataforma, que será executado pela máquina virtual. Esse codigo intermediário é chamado genericamente de "),o("i",[e._v("bytecode")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Como aplicações escritas em Java puro e Clojure geram o mesmo tipo de bytecode, é bem simples integrarmos o código de um com o outro, como vamos ver mais no capítulo "),o("ref-label",{attrs:{entry:"capitulo-integracao-java"}}),e._v(".")],1)]),o("p",{staticClass:"text-justify"},[e._v("Vamos corrigir o nosso código para que possamos ver o resultado da soma.")]),o("p",{staticClass:"text-justify"},[e._v("Fica fácil se você pensar que queremos imprimir o resultado de "),o("code",[e._v("+ 1 2")]),e._v(", e não os itens da operação separadamente.")]),o("p",{staticClass:"text-justify"},[e._v("Para trabalharmos com o resultado da soma, vamos colocar os membros entre parênteses. Assim, o "),o("code",[e._v("REPL")]),e._v(" vai avaliar primeiro a soma e depois vai mandar imprimir o resultado.")]),o("p",{staticClass:"text-justify"},[e._v("Nosso código então vai ficar da forma abaixo, e podemos ver o resultado na figura "),o("ref-label",{attrs:{entry:"repl-println-expression-ok"}}),e._v(".")],1),o("snippet",[e._v("\n(println (+ 1 2))\n")]),o("image",{attrs:{src:"images/capitulo_03/repl_println_expression_ok.png",description:"Agora deu certo",width:"90%",label:"repl-println-expression-ok"}}),o("p",{staticClass:"text-justify"},[e._v("Agora que você já sabe usar o "),o("code",[e._v("REPL")]),e._v(" o suficiente para poder seguir os exemplos do livro, vamos aprender a sair.")]),o("p",{staticClass:"text-justify"},[e._v("Para sair do REPL existem duas formas: o jeito "),o("i",[e._v("novo")]),e._v(", incluído na versão 1.5 do Clojure, e o jeito antigo, que ainda é a utilizada no Clojure CLR e nas versões anteriores do Clojure.")]),o("index",{attrs:{entry:"exit"}}),o("p",{staticClass:"text-justify"},[e._v("Para sair pelo jeito novo, basta digitar "),o("code",[e._v("exit")]),e._v(". Como é um comando do "),o("code",[e._v("REPL")]),e._v(", e não do Clojure, não fique preocupado com o fato de não ter que usar parênteses, como podemos ver na figura "),o("ref-label",{attrs:{entry:"repl-exit-new"}}),e._v(".")],1),o("image",{attrs:{src:"images/capitulo_03/repl_exit_new.png",description:"Saindo do REPL pelo jeito novo",width:"90%",label:"repl-exit-new"}}),o("p",{staticClass:"text-justify"},[e._v("Caso você esteja com uma versão antiga, execute o método "),o("code",[e._v("exit")]),e._v(" da classe "),o("code",[e._v("System")]),e._v(" do Java, passando o número "),o("i",[e._v("0")]),e._v(" como código para informar ao sistema operacional que saída ocorreu sem erros.")]),o("snippet",[e._v("\n(System/exit 0)\n")]),o("p",{staticClass:"text-justify"},[e._v("Ao sair por esse modo, não temos a simpática mensagem de adeus, como vemos na figura "),o("ref-label",{attrs:{entry:"repl-exit-old"}}),e._v(".")],1),o("image",{attrs:{src:"images/capitulo_03/repl_exit_old.png",description:"Saindo do REPL pelo jeito anterior",width:"90%",label:"repl-exit-old"}}),o("h2",[e._v("3.2. Alguns truques rápidos com o REPL")]),o("p",{staticClass:"text-justify"},[e._v("Existem alguns atalhos e funções auxiliares que tornam o uso do REPL bem mais produtivo. Por mais que escrever diretamente no REPL não seja tão confortável quando no seu editor preferido, algumas vezes isso acaba sendo necessário.")]),o("h3",[e._v("Qual é mesmo o nome daquela função?")]),o("p",{staticClass:"text-justify"},[e._v("As funções da biblioteca padrão do Clojure vem com um texto explicativo, onde você pode se situar sobre como utilizá-las.")]),o("index",{attrs:{index:"find-doc"}}),o("p",{staticClass:"text-justify"},[e._v("Podemos pesquisar alguma palavra que estiver dentro desses textos para encontrar a função que queremos, mas não lembramos o nome. Para isso, usamos "),o("code",[e._v("find-doc")]),e._v(", seguido da palavra ou trecho de texto relacionado ao que queremos.")]),o("p",{staticClass:"text-justify"},[e._v("Vamos supor que eu esteja procurando algo sobre "),o("i",[e._v("sockets")]),e._v(". Basta digitar "),o("code",[e._v('(find-doc "socket")')]),e._v(" no REPL.")]),o("snippet",[e._v('\n(find-doc "socket")\n; -------------------------\n; clojure.tools.nrepl/connect\n; ([& {:keys [port host transport-fn], :or {transport-fn\n;  transport/bencode, host "localhost"}}])\n;  Connects to a socket-based REPL at the given host (defaults\n; to localhost) and port, returning the Transport (by default\n; clojure.\n\n; e mais um monte de coisas\n')]),o("index",{attrs:{entry:"connect"}}),o("p",{staticClass:"text-justify"},[e._v("No nosso exemplo, encontramos a função "),o("code",[e._v("connect")]),e._v(", que está no namespace "),o("code",[e._v("clojure.tools.nrepl")]),e._v(".")]),o("index",{attrs:{entry:"apropos"}}),o("p",{staticClass:"text-justify"},[e._v("Se você lembra de alguma parte do nome da função, então pode usar a função "),o("code",[e._v("apropos")]),e._v(", passando como parâmetros o trecho do nome ou uma expressão regular. Não se preocupe com expressões regulares agora, pois veremos esse assunto em detalhes mais para frente.")]),o("index",{attrs:{entry:"vector"}}),o("p",{staticClass:"text-justify"},[e._v("Vamos supor que eu esteja manipulando vetores e não lembre o nome da função, mas saiba que a estrutura chama-se "),o("code",[e._v("vector")]),e._v(":")]),o("snippet",[e._v('\n(apropos "vector")\n; (vector-of vector vector? vector-zip)\n')]),o("index",{attrs:{entry:"apropos-better"}}),o("p",{staticClass:"text-justify"},[e._v("Existe uma variação de "),o("code",[e._v("apropos")]),e._v(" chamada "),o("code",[e._v("apropos-better")]),e._v(", que informa também o namespace da função quando ela não estiver dentro do namespace "),o("code",[e._v("clojure.core")]),e._v(" ou dentro do namespace em que você estiver no momento:")]),o("snippet",[e._v('\n(apropos-better "vector")\n; (vector vector-of vector? clojure.zip/vector-zip)\n')]),o("index",{attrs:{entry:"doc"}}),o("p",{staticClass:"text-justify"},[e._v("Agora você pode usar a função "),o("code",[e._v("doc")]),e._v(" para ver a documentação daquela que mais se parecer com o que você estiver procurando:")]),o("snippet",[e._v("\n(doc vector?)\n; -------------------------\n; clojure.core/vector?\n; ([x])\n;   Return true if x implements IPersistentVector\n")]),o("index",{attrs:{entry:"javadoc"}}),o("p",{staticClass:"text-justify"},[e._v("Caso você queira ver a documentação de uma classe ou objeto Java, a função "),o("code",[e._v("doc")]),e._v(" não pode te ajudar. Felizmente é possível consultar o "),o("i",[e._v("Javadoc")]),e._v(", que é a forma padrão de documentação do Java "),o("bib",{attrs:{entry:"oracle-javadoc"}}),e._v(". Para isso usamos a função "),o("code",[e._v("javadoc")]),e._v(", obviamente:")],1),o("snippet",[e._v('\n(source java.io.File)\nSource not found\n\n(javadoc java.io.File)\n; "http://java.sun.com/javase/7/docs/api/java/io/File.html"\n')]),o("p",{staticClass:"text-justify"},[e._v("Além de retornar um texto com a localização da documentação, a função "),o("code",[e._v("javadoc")]),e._v(" também abre o seu browser padrão na página indicada, como podemos ver na figura "),o("ref-label",{attrs:{entry:"cap03-javadoc"}}),e._v(":")],1),o("image",{attrs:{src:"images/capitulo_03/javadoc.png",description:"E a função abre o browser para você",label:"cap03-javadoc",width:"70%"}}),o("p",{staticClass:"text-justify"},[e._v("Eu sempre gostei da forma como a documentação do pacote "),o("code",[e._v("java.io")]),e._v(" foi escrita e achei que daria um bom exemplo.")]),o("h3",[e._v("Um pouco de Bash na sua vida")]),o("p",{staticClass:"text-justify"},[e._v("Quando você usa o REPL por dentro do Leiningen, alguns atalhos já conhecidos pelos usuários de Bash estão disponíveis, mesmo para quem está usando o Leiningen no Windows.")]),o("index",{attrs:{entry:"Bash"}}),o("box",{attrs:{title:"O que é Bash"}},[o("i",[e._v("Bash")]),e._v(" é um dos "),o("i",[e._v("shells")]),e._v(" mais conhecidos por quem usa sistemas operacionais baseados em UNIX ou Linux. Shell é a camada mais externa do sistema operacional e onde você insere comandos e recebe os resultados, de modo similar ao que acontece no REPL.\n")]),o("p",{staticClass:"text-justify"},[e._v("O primeiro deles é a tecla "),o("i",[e._v("TAB")]),e._v(", que exibe os nomes de funções que começam com o que você já digitou.")]),o("index",{attrs:{entry:"map"}}),o("p",{staticClass:"text-justify"},[e._v("Por exemplo, vou digitar "),o("code",[e._v("map")]),e._v(" e pressionar "),o("i",[e._v("TAB")])]),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(map\n; map           map-indexed   map?          mapcat        mapv\n")]),o("p",{staticClass:"text-justify"},[e._v("É possível também encontrar algum "),o("i",[e._v("namespace")]),e._v(" específico da mesma maneira que foi feita para procurar a função:")]),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(clojure.s\n; clojure.set          clojure.stacktrace   clojure.string\n")]),o("p",{staticClass:"text-justify"},[e._v("Você pode usar a tecla "),o("i",[e._v("TAB")]),e._v(" para ver todas as funções disponíveis em determinado "),o("i",[e._v("namespace")]),e._v(", bastando adicionar uma barra após o nome:")]),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(clojure.set/\n; clojure.set/difference clojure.set/index clojure.set/join\n; clojure.set/intersection clojure.set/map-invert\n; clojure.set/project clojure.set/rename clojure.set/rename-keys\n; clojure.set/select clojure.set/subset? clojure.set/superset?\n; clojure.set/union\n")]),o("p",{staticClass:"text-justify"},[e._v("Outra combinação que agiliza bastante o trabalho é a combinação "),o("i",[e._v("Control L")]),e._v(", ou "),o("i",[e._v("Command L")]),e._v(" se você estiver usando MacOS, que limpa os resultados das expressões anteriores e mantém apenas a expressão que você estiver digitando no momento.")]),o("p",{staticClass:"text-justify"},[e._v("Existe também a combinação "),o("i",[e._v("Control R")]),e._v(", ou "),o("i",[e._v("Command R")]),e._v(", que completa o que você estiver digitando usando o histórico de comandos do REPL. Pressionando essa combinação mais de uma vez vai alternar entre todas as combinações já utilizadas que contenham o texto que você já digitou.")]),o("p",{staticClass:"text-justify"},[e._v("Usar as setas "),o("i",[e._v("para cima")]),e._v(" ou "),o("i",[e._v("para baixo")]),e._v(" permite que você navegue nos comandos utilizados recentemente.")]),o("h3",[e._v("Recuperando os últimos resultados")]),o("index",{attrs:{entry:"*1"}}),o("index",{attrs:{entry:"*2"}}),o("index",{attrs:{entry:"*3"}}),o("index",{attrs:{entry:"*e"}}),o("p",{staticClass:"text-justify"},[e._v("Existem também símbolos especiais que guardam os resultados das últimas expressões e exceções. Eles são "),o("code",[e._v("*1")]),e._v(", "),o("code",[e._v("*2")]),e._v(" e "),o("code",[e._v("*3")]),e._v(" para os valores e "),o("code",[e._v("*e")]),e._v(" para a última exceção, ou erro, que ocorreu:")]),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(+ 1 2)\n; 3\n\n(* 2 4)\n; 8\n\n(/ 8 2)\n; 4\n\n(println "Resultados anteriores:" *1 *2 *3)\n; Resultados anteriores: 4 8 3\n\n(/ 1 0)\n; ArithmeticException Divide by zero\n\n(println "Último erro:" *e)\n; Último erro: #<ArithmeticException java.lang.ArithmeticException:\n;   Divide by zero>\n')]),o("index",{attrs:{entry:"pst"}}),o("p",{staticClass:"text-justify"},[e._v("Caso você queira ver a lista de chamadas, ou "),o("i",[e._v("stacktrace")]),e._v(", do último erro, basta utilizar a função "),o("code",[e._v("pst")]),e._v(":")]),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(/ 1 0)\n; ArithmeticException Divide by zero\n\n(println "Último erro:" *e)\n; Último erro: #<ArithmeticException java.lang.ArithmeticException:\n;   Divide by zero>\n\nuser=> (pst)\n; java.lang.ArithmeticException: Divide by zero\n; Numbers.java:156 clojure.lang.Numbers.divide\n; Numbers.java:3691 clojure.lang.Numbers.divide\n; ... um monte de linhas ...\n; Thread.java:745 java.lang.Thread.run\n')]),o("h3",[e._v("Consultando o código fonte")]),o("p",{staticClass:"text-justify"},[e._v("Algumas vezes é bom ter acesso ao código fonte de determinada função ou macro para que possamos entender melhor como ela funciona. Enquanto eu escrevia este livro, fiz isso constantemente para descobrir como as coisas funcionam por baixo dos panos.")]),o("p",{staticClass:"text-justify"},[e._v("Infelizmente, nem sempre é simples ir até o site onde o código fonte do Clojure está disponível e procurar o arquivo em que aquela função está definida.")]),o("p",{staticClass:"text-justify"},[e._v("Pior ainda quando a versão que está lá é diferente da versão que você está usando no momento. E fica ainda pior quando você não tem acesso ao código fonte da biblioteca que estiver utilizando.")]),o("index",{attrs:{entry:"source"}}),o("p",{staticClass:"text-justify"},[e._v("Para nos ajudar, existe a macro "),o("code",[e._v("source")]),e._v(", que recebe como parâmetro o nome da função, sem aspas, e exibe o respectivo código fonte, quando possível.")]),o("p",{staticClass:"text-justify"},[e._v("Existem casos em que isso não é possível, como quando você tentar ler o fonte de uma forma especial ou de um código que foi compilado utilizando AOT (veremos isso em detalhes mais para frente).")]),o("p",{staticClass:"text-justify"},[e._v("Vamos exibir o código fonte da função "),o("code",[e._v("+")]),e._v(", responsável por somar dois ou mais números:")]),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(source +)\n; (defn +\n;   "Returns the sum of nums. (+) returns 0. Does not auto-promote\n;   longs, will throw on overflow. See also: +\'"\n;   {:inline (nary-inline \'add \'unchecked_add)\n;    :inline-arities >1?\n;    :added "1.2"}\n;   ([] 0)\n;   ([x] (cast Number x))\n;   ([x y] (. clojure.lang.Numbers (add x y)))\n;   ([x y & more]\n;      (reduce1 + (+ x y) more)))\n')]),o("p",{staticClass:"text-justify"},[e._v("Note que temos acesso a todos os detalhes internos da função "),o("code",[e._v("+")]),e._v(", incluindo sua documentação e mais algumas informações que são úteis para o compilador ou para alguma função que gere documentação automaticamente.")]),o("p",{staticClass:"text-justify"},[e._v("Ao tentarmos ver o código fonte de uma forma especial ou de algum código escrito nativamente em Java, receberemos uma mensagem de que o código fonte não foi encontrado:")]),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(source Thread/sleep)\n; Source not found\n")]),o("h2",[e._v("3.3. Desenvolvimento baseado no REPL")]),o("p",{staticClass:"text-justify"},[e._v("Uma das características que faz o Clojure tão interessante para desenvolvermos software é que o REPL não é apenas um "),o("i",[e._v("console")]),e._v(" da linguagem. Ele não serve apenas para que você teste expressões ou funções de uma biblioteca. Com o REPL você pode "),o("b",[e._v("alterar o programa enquanto ele está sendo executado")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Se você trabalha com Java e utiliza TDD, o seu workflow pode ser resumido em escrever um teste, rodar o teste e vê-lo falhar. Em seguida você escreve o código necessário para que o teste passe e então recomeça o ciclo até concluir o desenvolvimento.")]),o("index",{attrs:{entry:"warmup"}}),o("p",{staticClass:"text-justify"},[e._v("A cada vez que você roda os testes, a JVM demora algum tempo carregando a si mesma até começar a executar o conjunto de testes que você selecionou. Esse tempo é chamado de "),o("i",[e._v("warmup")]),e._v(". Existem técnicas para reduzir esse tempo, mas é inevitável que ele exista.")]),o("p",{staticClass:"text-justify"},[e._v("Para executar a aplicação há um tempo gasto com a compilação, o tempo de warmup da JVM e só então sua aplicação começa a ser executada.")]),o("p",{staticClass:"text-justify"},[e._v("Quando você desenvolve em Ruby, mais especificamente quando está utilizando Rails, o console da linguagem permite que você altere dados da aplicação enquanto ela está sendo executada, mas você não pode alterar a estrutura do que já foi carregado, como objetos e funções.")]),o("p",{staticClass:"text-justify"},[e._v("É aqui que o Clojure começa a mostrar a sua diferença: você pode alterar código e dados durante a execução do programa, mesmo que eles já tenham sido carregados, sem que para isso você perca tempo esperando o warmup da JVM ou recompilando a aplicação.")]),o("h2",[e._v("3.4. Criando uma aplicação de exemplo")]),o("p",{staticClass:"text-justify"},[e._v("Vamos criar uma pequena aplicação para demonstrar como isso funciona na prática.")]),o("index",{attrs:{entry:"lein new"}}),o("p",{staticClass:"text-justify"},[e._v("Primeiro, execute o comando "),o("code",[e._v("lein new capitulo03")]),e._v(" para criar um novo projeto. Será criado um diretório chamado "),o("code",[e._v("capitulo03")]),e._v(" com um esqueleto dessa aplicação. Não se preocupe com a estrutura que foi criada, pois mais para frente vamos explicar em detalhes o que é cada arquivo e cada diretório.")]),o("index",{attrs:{entry:"namespace"}}),o("p",{staticClass:"text-justify"},[e._v("Dentro do diretório "),o("code",[e._v("src/capitulo03")]),e._v(" existe um arquivo chamado "),o("code",[e._v("core.clj")]),e._v(". Ele contém o "),o("i",[e._v("namespace")]),o("code",[e._v("capitulo03.core")]),e._v(", que informamos dentro do arquivo "),o("code",[e._v("project.clj")]),e._v(", e isso é declarado logo na primeira linha, por meio da instrução "),o("code",[e._v("(ns capitulo03.core)")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Vamos criar agora uma função chamada "),o("code",[e._v("texto")]),e._v(". Essa função apenas imprime "),o("i",[e._v('"Texto original"')]),e._v(" na tela. Para isso usaremos a função "),o("code",[e._v("println")]),e._v(", que imprime os valores passados por parâmetro para saída padrão. Nossa função ficará assim:")]),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn texto []\n  (println "Texto original"))\n')]),o("index",{attrs:{entry:"entry point"}}),o("index",{attrs:{entry:"loop"}}),o("p",{staticClass:"text-justify"},[e._v("Em seguida, vamos criar a função "),o("code",[e._v("-main")]),e._v(", que é a função inicial da aplicação, ou "),o("i",[e._v("entry point")]),e._v(". Nela vamos criar um "),o("i",[e._v("loop")]),e._v(" infinito que invoca a função "),o("code",[e._v("texto")]),e._v(" e faz uma pausa de dois segundos. Não se preocupe com os detalhes, já que vamos explicar todos eles mais para frente.")]),o("index",{attrs:{entry:";"}}),o("index",{attrs:{entry:"comentários"}}),o("p",{staticClass:"text-justify"},[e._v("Os comentários, iniciados pelo caracter "),o("code",[e._v(";")]),e._v(" foram adicionados para que você não se perca logo no terceiro capítulo do livro:")]),o("index",{attrs:{entry:"Thread/sleep"}}),o("snippet",{attrs:{language:"clojure"}},[e._v("\n(defn -main [& args]\n  (loop []              ; inicia o loop\n    (texto)             ; chama a função texto\n    (Thread/sleep 2000) ; espera dois segundos\n    (recur)))           ; retorna ao início do loop\n")]),o("index",{attrs:{entry:"lein repl"}}),o("p",{staticClass:"text-justify"},[e._v("Agora salve o arquivo e volte ao diretório "),o("code",[e._v("capitulo03")]),e._v(", execute o comando "),o("code",[e._v("lein repl")]),e._v(" para abrir o "),o("i",[e._v("REPL")]),e._v(". Note que na primeira linha é exibido um texto dizendo que o "),o("i",[e._v("nREPL")]),e._v(" foi iniciado em uma determinada porta, no IP "),o("i",[e._v("127.0.0.1")]),e._v(". Anote o número dessa porta, pois vamos precisar daqui a pouco.")]),o("p",{staticClass:"text-justify"},[e._v("Execute a instrução "),o("code",[e._v("(use 'capitulo03.core)")]),e._v(" para importar as funções do namespace "),o("i",[e._v("capitulo03.core")]),e._v(". Isso vai ser necessário para que possamos executar as duas funções que acabamos de criar.")]),o("p",{staticClass:"text-justify"},[e._v("Agora execute a instrução "),o("code",[e._v("(-main)")]),e._v(" para iniciar nossa aplicação. A cada dois segundos será impresso "),o("i",[e._v("Texto original")]),e._v(".")]),o("h2",[e._v("3.5. Modificando a aplicação através do REPL")]),o("p",{staticClass:"text-justify"},[e._v("Abra uma nova janela do Terminal, vá ao diretório "),o("code",[e._v("capitulo03")]),e._v(" e execute o comando "),o("code",[e._v("lein repl :connect 127.0.0.1:XXXX")]),e._v(", substituindo "),o("code",[e._v("XXXX")]),e._v(" pela porta que você anotou.")]),o("p",{staticClass:"text-justify"},[e._v("Execute a instrução "),o("code",[e._v("(ns capitulo03.core)")]),e._v(" para que possamos trabalhar dentro do namespace em que criamos nossas funções e, em seguida, execute "),o("code",[e._v("(texto)")]),e._v(" para que seja exibido o texto atual, conforme programamos anteriormente.")]),o("p",{staticClass:"text-justify"},[e._v("Agora, usando esse REPL que acabamos de abrir, vamos modificar a aplicação que está sendo executada na outra janela. Digite o código a seguir e vamos analisar o que acontece:")]),o("snippet",{attrs:{language:"clojure"}},[e._v('\n(defn texto []\n  (println "Agora mudou"))\n')]),o("p",{staticClass:"text-justify"},[e._v("Ao executar novamente a instrução "),o("code",[e._v("(texto)")]),e._v(", veremos que o texto exibido foi alterado. Agora volte à janela onde a aplicação está sendo executada e veja o que aconteceu.")]),o("p",{staticClass:"text-justify"},[e._v("O texto exibido a cada dois segundos mudou instantaneamente de "),o("i",[e._v("Texto original")]),e._v(" para "),o("i",[e._v("Agora mudou")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Mas o que aconteceu?")]),o("index",{attrs:{entry:"nREPL"}}),o("p",{staticClass:"text-justify"},[e._v("A aplicação estava sendo executada em uma janela, por dentro de um REPL. O REPL disponibilizado pelo Leiningen vem com uma biblioteca embutida chamada nREPL, que permite que possamos conectar remotamente outro REPL em uma aplicação, e por isso são exibidos um endereço IP e o número de uma porta.")]),o("p",{staticClass:"text-justify"},[e._v("Quando conectamos o REPL da segunda janela na aplicação que imprime o texto a cada dois segundos, estamos conectados "),o("i",[e._v("dentro")]),e._v(" da aplicação. Então, toda alteração que você fizer dentro da segunda janela, será instantaneamente refletida na aplicação da primeira janela.")]),o("index",{attrs:{entry:"Vim"}}),o("index",{attrs:{entry:"Emacs"}}),o("index",{attrs:{entry:"Cider"}}),o("index",{attrs:{entry:"Fireplace"}}),o("index",{attrs:{entry:"Lighttable"}}),o("p",{staticClass:"text-justify"},[e._v("Esse recurso fica ainda mais interessante quando você utiliza um editor de texto que se conecte automaticamente ao REPL, como é o caso do "),o("i",[e._v("Vim")]),e._v(" através do plugin "),o("code",[e._v("fireplace")]),e._v(", do "),o("i",[e._v("Emacs")]),e._v(" através do pacote "),o("code",[e._v("Cider")]),e._v(", ou do "),o("i",[e._v("Lighttable")]),e._v(", editor utilizado nesse livro, que já vem com esse recurso instalado por padrão.")]),o("p",{staticClass:"text-justify"},[e._v("Essa integração com o editor permite que o seu código seja enviado de forma transparente ao REPL, sem que você precise escrever a mesma coisa no editor e depois no REPL, fazendo com que você tenha todas as vantagens do seu editor preferido somado à agilidade que ganhamos ao alterar a aplicação enquanto ela está sendo executada, sem necessidade de a recompilarmos ou esperarmos que ela seja carregada novamente.")]),o("p",{staticClass:"text-justify"},[e._v("Existem vários textos pela Internet explicando como os autores usam esse recurso para criar um fluxo de trabalho ágil e produtivo. Fique à vontade para experimentar e descobrir seu próprio jeito de trabalhar.")]),o("p",{staticClass:"text-justify"},[e._v("Caso seu editor preferido não dê suporte ao nREPL, não se preocupe. Durante o livro vamos explicar cada exemplo sem a necessidade de usarmos esse recurso. Se você não usar, tudo bem. Mas se resolver usar, vai ser melhor ainda.")]),o("p",{staticClass:"text-justify"},[e._v("A partir do próximo capítulo vamos aumentar o ritmo e entrar a fundo na linguagem, apresentando todos os recursos necessários para que você consiga usar Clojure para resolver problemas de verdade e, de repente, até mesmo convencer seus colegas de que vale a pena aprender e usar no trabalho.")])],1)},zo=[],Eo={name:"Repl"},Po=Eo,Ao=Object(l["a"])(Po,Co,zo,!1,null,null,null),Oo=Ao.exports,Vo=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("page",[o("h1",[e._v("Agradecimentos")]),o("chapter-quote",{attrs:{author:"Joseph Campbell"}},[e._v("\n  \"If the path before you is clear, you're probably on someone else's.\"\n  ")]),o("p",{staticClass:"text-justify"},[e._v("Escrever um livro sobre Clojure em Português, utilizando material original e de uma forma que torne a linguagem acessível mesmo para quem nunca ouviu falar em programação funcional é um trabalho imenso e demorado que eu não teria conseguido concluir sozinho.")]),o("p",{staticClass:"text-justify"},[e._v("Foi um trabalho que levou alguns anos de escrita e reescrita, com capítulos sendo inteiramente jogados fora para que apenas o melhor sobrevivesse.")]),o("p",{staticClass:"text-justify"},[e._v("Minhas sinceras desculpas se eu me esquecer de alguém. Eu juro que não foi por mal.")]),o("p",{staticClass:"text-justify"},[o("b",[e._v("Minha esposa e meus filhos, que mais uma vez tiveram que me aturar sentado no computador por horas e dias até que eu finalmente conseguisse terminar este projeto")]),e._v(".")]),o("p",{staticClass:"text-justify"},[e._v("Ao amigo Francelino Guilherme que, ao ensinar conceitos de programação para crianças, me apresentou excelentes analogias para conceitos complicados para quem não desenvolve softwares.")]),o("p",{staticClass:"text-justify"},[e._v("Paulo Suzart pelo apoio desde o primeiro momento. Paulo foi, até onde eu sei, o primeiro brasileiro a escrever sobre Clojure em Português e continua nessa tarefa até hoje.")]),o("p",{staticClass:"text-justify"},[e._v("Thank you very much Joshua Glover, Chas Emerick, Michael Fogus, Bozhidar Batsov, Zachary Kim, Tom and Rich Hickey, Leonardo Borges and all the people from Clojure list.")]),o("p",{staticClass:"text-justify"},[e._v("Paulo Silveira, Adriano Almeida e Igor Hercowitz, que compraram a ideia maluca de lançar um livro sobre Clojure num momento em que ela parecia maluca.")]),o("p",{staticClass:"text-justify"},[e._v("Nicolas França, João Ferreira, Rodrigo Lorca, Ricardo Valeriano, Ana Gabriel, Rodrigo Flores, Edilson Peçanha, Andrew Rosa, Renan Reis, Gilmar Soares, que foram revisores de primeira hora e tiveram a honestidade de apontar onde a coisa não estava boa.")]),o("p",{staticClass:"text-justify"},[e._v("A todos os participantes dos Grupos de Usuários Clojure de São Paulo e Rio de Janeiro, Clojure Brasil e Clojure Portugal, e também aos grupos GURU-SP, Scaladores e Clojure Australia (o antigo clj-syd) por terem servido de inspiração e modelo de como manter um grupo de usuários com um ambiente bacana e organizado.")]),o("p",{staticClass:"text-justify"},[e._v("Colegas de trabalho que participaram de uma forma ou de outra do nascimento deste livro; Rodrigo Vidal, Luiz Costa, Douglas 'qmx' Campos, Breno Ferreira, Henrique Weissmann, José Valim, colegas que estão ajudando ativamente a divulgar e popularizar a programação funcional e o Clojure.")])],1)},So=[],wo={name:"Thanks"},No=wo,Jo=Object(l["a"])(No,Vo,So,!1,null,null,null),Lo=Jo.exports,Ro=function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("page",[o("h1",[e._v("Aviso")]),o("p",{staticClass:"text-justify"},[e._v("\n  Aprender programação funcional, Clojure, ou qualquer outra forma de "),o("i",[e._v("LISP")]),e._v(", pode mudar definitivamente a forma como você enxerga o desenvolvimento de software.\n  ")]),o("p",{staticClass:"text-justify"},[e._v("\n  São esperados efeitos colaterais como aumento de produtividade, concisão de código, surgimento ou aumento dos questionamento sobre as formas atualmente aceitas para se resolver problemas e, em alguns casos, aparecimento ou aumento de pragmatismo.\n  ")]),o("p",{staticClass:"text-justify"},[e._v("\n  Foram relatados casos de euforia por conta de um evento chamado "),o("i",[e._v("iluminação")]),e._v(", onde o desenvolvedor subitamente entende a forma funcional de pensar.\n  ")]),o("p",{staticClass:"text-justify"},[e._v("\n  O autor e a editora não assumem a responsabilidade pelo fato de você se tornar um desenvolvedor ainda melhor e mais curioso após a leitura deste livro.\n  ")]),o("p",{staticClass:"text-justify"},[e._v("\n  Continue por sua conta e risco.\n  ")])])},ko=[],To={name:"Warning"},Io=To,Uo=Object(l["a"])(Io,Ro,ko,!1,null,null,null),Do=Uo.exports;s["a"].config.productionTip=!1,s["a"].use(r["a"]),s["a"].use(i["a"]),s["a"].component("bib",x),s["a"].component("box",E),s["a"].component("chapter-quote",w),s["a"].component("comment",T),s["a"].component("image",Pe),s["a"].component("index",Ne),s["a"].component("page",sa),s["a"].component("ref-label",Ie),s["a"].component("snippet",ha),s["a"].component("wip",Aa);var Mo=!0,Bo=[{path:"/",component:je,meta:{next:"/online"}},{path:"/online",component:go,meta:{next:"/dedication",previous:"/",title:"Sobre a versão online"}},{path:"/dedication",component:Qa,meta:{previous:"/online",next:"/foreword",title:"Dedicatória"}},{path:"/foreword",component:Ya,meta:{previous:"/dedication",next:"/thanks",title:"Prefácio"}},{path:"/thanks",component:Lo,meta:{previous:"/foreword",next:"/author",title:"Agradecimentos"}},{path:"/author",component:Ja,meta:{previous:"/thanks",next:"/warning",title:"Sobre o autor"}},{path:"/warning",component:Do,meta:{previous:"/author",next:"/presentation",title:"Aviso"}},{path:"/presentation",component:yo,meta:{previous:"/warning",next:"/gentleintro",title:"Apresentação"}},{path:"/gentleintro",component:co,meta:{previous:"/presentation",next:"/repl",title:"Uma introdução gentil ao Clojure"}},{path:"/repl",component:Oo,meta:{previous:"/gentleintro",next:"/functions",title:"O REPL é tão importante..."}},{path:"/functions",component:ro,meta:{previous:"/repl",next:"/data",title:"Descobrindo o poder das funções"}},{path:"/data",component:Ua,meta:{previous:"/functions",title:"Dados e metadados"}},{path:"/:chapter",component:_a,meta:{title:":("}}];window.Prism.languages.clojure={comment:/;+[^\r\n]*(\r?\n|$)/g,string:/(")(\\?.)*?\1/g,"operator ":/(::|[:|'])\b[a-zA-Z][a-zA-Z0-9 *+!-_?]*\b/g,keyword:{pattern:/([^\w+*'?-])(def|if|do|let|quote|var|fn|loop|recur|throw|try|monitor-enter|\.|new|set!|def-|defn|defn-|defmacro|defmulti|defmethod|defstruct|defonce|declare|definline|definterface|defprotocol|defrecord|deftype|defproject|ns|\*|\+|-|->|\/|<|<=|=|==|>|>=|\.\.|accessor|agent|agent-errors|aget|alength|all-ns|alter|and|append-child|apply|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assoc|await|await-for|bean|binding|bit-and|bit-not|bit-or|bit-shift-left|bit-shift-right|bit-xor|boolean|branch\?|butlast|byte|cast|char|children|class|clear-agent-errors|comment|commute|comp|comparator|complement|concat|conj|cons|constantly|cond|if-not|construct-proxy|contains\?|count|create-ns|create-struct|cycle|dec|deref|difference|disj|dissoc|distinct|doall|doc|dorun|doseq|dosync|dotimes|doto|double|down|drop|drop-while|edit|end\?|ensure|eval|every\?|false\?|ffirst|file-seq|filter|find|find-doc|find-ns|find-var|first|float|flush|for|fnseq|frest|gensym|get-proxy-class|get|hash-map|hash-set|identical\?|identity|if-let|import|in-ns|inc|index|insert-child|insert-left|insert-right|inspect-table|inspect-tree|instance\?|int|interleave|intersection|into|into-array|iterate|join|key|keys|keyword|keyword\?|last|lazy-cat|lazy-cons|left|lefts|line-seq|list\*|list|load|load-file|locking|long|loop|macroexpand|macroexpand-1|make-array|make-node|map|map-invert|map\?|mapcat|max|max-key|memfn|merge|merge-with|meta|min|min-key|name|namespace|neg\?|new|newline|next|nil\?|node|not|not-any\?|not-every\?|not=|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unmap|nth|nthrest|or|parse|partial|path|peek|pop|pos\?|pr|pr-str|print|print-str|println|println-str|prn|prn-str|project|proxy|proxy-mappings|quot|rand|rand-int|range|re-find|re-groups|re-matcher|re-matches|re-pattern|re-seq|read|read-line|reduce|ref|ref-set|refer|rem|remove|remove-method|remove-ns|rename|rename-keys|repeat|replace|replicate|resolve|rest|resultset-seq|reverse|rfirst|right|rights|root|rrest|rseq|second|select|select-keys|send|send-off|seq|seq-zip|seq\?|set|short|slurp|some|sort|sort-by|sorted-map|sorted-map-by|sorted-set|special-symbol\?|split-at|split-with|str|string\?|struct|struct-map|subs|subvec|symbol|symbol\?|sync|take|take-nth|take-while|test|time|to-array|to-array-2d|tree-seq|true\?|union|up|update-proxy|val|vals|var-get|var-set|var\?|vector|vector-zip|vector\?|when|when-first|when-let|when-not|with-local-vars|with-meta|with-open|with-out-str|xml-seq|xml-zip|zero\?|zipmap|zipper)(?=[^\w+*'?-])/g,lookbehind:!0},boolean:/\b(true|false)\b/g,number:/\b-?(0x)?\d*\.?\d+\b/g,punctuation:/[{}[](),]/g};var Fo=new r["a"]({routes:Bo,scrollBehavior:function(e,a,o){return o||(e.hash?{selector:e.hash}:{x:0,y:0})}});Fo.beforeEach(function(e,a,o){var s="Descobrindo Clojure";e.meta.title?document.title="".concat(s," - ").concat(e.meta.title):document.title="".concat(s),o()}),s["a"].use(n.a,{id:"UA-137706670-1",autoTracking:{screenview:!0},debug:{enabled:!Mo,sendHitTask:Mo},router:Fo});var $o=new s["a"]({router:Fo,render:function(e){return e(p)},data:function(){return{swipeX:-1}},methods:{handleGlobalKeyUp:function(e){var a=e.key,o=this.$route.meta;o&&("Home"===a||"h"===a?this.$router.push("/"):"ArrowRight"!==a&&"k"!==a||!o.next?"ArrowLeft"!==a&&"j"!==a||!o.previous||this.$router.push(o.previous):this.$router.push(o.next))},handleTouchStart:function(e){this.$data.swipeX=e.changedTouches[0].clientX},handleTouchEnd:function(e){var a=this.$route.meta;this.$data.swipeX-100>=e.changedTouches[0].clientX&&a.next?(this.$data.swipeX=-1,this.$router.push(a.next)):this.$data.swipeX+100<=e.changedTouches[0].clientX&&a.previous&&(this.$data.swipeX=-1,this.$router.push(a.previous))}}}).$mount("#app");Fo.afterEach(function(e){$o.$ga.page({page:e.fullPath,title:document.title,location:"".concat(window.location.origin,"/#").concat(e.fullPath)})}),window.addEventListener("keyup",function(e){$o.handleGlobalKeyUp(e)}),document.addEventListener("touchstart",function(e){$o.handleTouchStart(e)}),document.addEventListener("touchend",function(e){$o.handleTouchEnd(e)})},"64a9":function(e,a,o){},"8f96":function(e){e.exports=JSON.parse('"88a9c19"')},d140:function(e,a,o){"use strict";var s=o("f870"),r=o.n(s);r.a},ed52:function(e,a,o){"use strict";var s=o("2aad"),r=o.n(s);r.a},f870:function(e,a,o){}});