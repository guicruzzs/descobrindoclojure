<template>
<page>
<wip /><h1>Dados e metadados</h1>
<index entry="capitulo-dados" />
<chapter-quote author="Rich Hickey" work=", criador do Clojure">"Choose immutability and see where it takes you"</chapter-quote>
<p class="text-justify">Uma das coisas mais difíceis de entender e aceitar em uma linguagem funcional, quando estamos tendo um primeiro contato, é o fato dos dados, na maioria das vezes, não poderem ser alterados depois de criados.</p>
<p class="text-justify">Essa característica de não podermos alterar o dado após sua criação é chamada de.</p>
<p class="text-justify">Em uma linguagem como o Java, por exemplo, é comum criarmos uma variável temporária e alterarmos seu valor até chegarmos ao resultado que queremos.</p>
<p class="text-justify">Lá nos primórdios das linguagens de programação, memória e processamento eram recursos caríssimos, então cadafazia a diferença. O conceito deaté já existia, mas era inviável nas máquinas comerciais existentes.</p>
<p class="text-justify">Por conta disso, o reaproveitamento de variáveis era considerada uma boa prática, e a mutabilidade de dados numa linguagem era quase obrigatória.</p>
<p class="text-justify">De certo modo, modificar o valor de uma variável, desde que isso não insira bugs no código, não é uma prática ruim. O problema começa quando você tem que compartilhar esse valor entre diferentes processos ou.</p>
<p class="text-justify">Partindo do pressuposto que o leitor teve infância, tente imaginar que você tenha um saquinho de bolas de gude (burca, fubeca, ou bila dependendo da época e do lugar da sua infância) e você, na solidão de um quintal ou do carpete da avó, queira contar quantas bolinhas existem ali.</p>
<p class="text-justify">Estando você sozinho, fica fácil de contar por mais que isso demore. Você pegas as bolinhas de um lugar, coloca em outro e incrementa um contador mental. Ao acabar as bolinhas, você tem a quantidade.</p>
<p class="text-justify">Agora imagine que você tenha um irmão que goste de atrapalhar. Irmãos são ótimos para isso. Enquanto você conta as bolinhas, ele muda a quantidade de bolinhas de um lado, do outro, ou mesmo começa a sumir com as bolinhas.</p>
<p class="text-justify">Mesmo que você consiga terminar, sua contagem não vai servir para nada.</p>
<p class="text-justify">Então você resolve organizar as coisas.</p>
<p class="text-justify">Você separa suas bolinhas em dois grupos. Uma para o irmão bagunceiro, outra para você. Ele conta o grupo de lá, você conta o grupo de cá e no final vocês somam os totais.</p>
<p class="text-justify">Bacana, assim funcionou.</p>
<p class="text-justify">Não acho que estavam pensando em bolinhas de gude, mas as pessoas que criam linguagens de programação resolveram colocar semáforos, como esses de trânsito, para que dois processos não alterem a mesma variável, como dois irmãos fazendo bagunça. No Java os semáforos são chamados de.</p>
<p class="text-justify">A história dos semáforos funciona muito bem quando temos dois processos querendo mexer no mesmo valor, mas a coisa começa a ficar bem complicada quando passamos a ter vários processos querendo mexer no mesmo lugar.</p>
<p class="text-justify">Muitos algoritmos foram desenvolvidos, muitas ideias foram pensadas e muitas noites de sono foram perdidas até que alguém se perguntou se não seria uma boa se os valores simplesmente não mudassem.</p>
<p class="text-justify">E essa pessoa estava certa.</p>
<p class="text-justify">Se um valor não se altera até o fim de sua vida, qual a necessidade de criarmos gerenciamentos complicados com semáforos, travas e outras analogias? O númerosempre será, não importando quantas pessoas o estejam usando ao mesmo tempo.</p>
<p class="text-justify">Se você acha isso pouco prático e difícil de imaginar, pense na classedo Java. Uma vez que você crie um valor do tipo, ele não pode mais ser modificado.</p>
<p class="text-justify">Os métodos deretornam um novo valor, mantendo o texto original inalterado. Isso significa que um valoré imutável e, por definição, um valor imutável pode ser compartilhado sem medo entre diferentes processos ou.</p>
<p class="text-justify">Quando um valor pode ser compartilhado entre diferentessem medo de fazermos lambança, dizemos que o valor é.</p>
<p class="text-justify">Como fazemos então para lidar com valores imutáveis se em algum momento vamos precisar que um valor seja modificado para outro?</p>
<p class="text-justify">A primeira coisa que podemos fazer é não modificar valores, e sim transformá-los. Isso significa que vamos gerar um novo valor ao invés de transformar o atual, exatamente como faz a classe.</p>
<p class="text-justify">Por mais que isso possa parecer pouco produtivo em termos de processamento e memória, caso você tenha se perguntado se a cada transformação será criado um objeto completamente novo, o Clojure faz uso depara otimizar essas transformações, compartilhando partes da estrutura entre valores diferentes.</p>
<p class="text-justify">Afinal de contas, se esses valores não serão alterados, qual o problema em os usarmos em diferentes lugares ao mesmo tempo?</p>
<p class="text-justify">A segunda coisa que podemos fazer é limitar as partes móveis da aplicação. Se você isolar as partes mutáveis do seu sistema em lugares que não serão acessados por diferentes threads ao mesmo tempo, ainda assim você consegue manter seu código. Vamos ver como isso funciona ao vermos.</p>
<p class="text-justify">Outro ponto importante de nos apoiarmos em valores imutáveis, mesmo fora do Clojure, é que você não pode confiar naquilo que muda sem que você perceba.</p>
<p class="text-justify">Quando você usa um, por exemplo, você tem cada item formado por uma chave e um valor.</p>
<p class="text-justify">Essa chave é pesquisada através de um valor numérico chamado, que é calculada de acordo com os atributos do objeto. Se os atributos mudam, otambém muda.</p>
<p class="text-justify">Se omuda, a chave dojá não é mais confiável, já que você não vai mais encontrar o objeto com oantigo. É como se você tivesse uma chave de casa para uma fechadura que pode mudar sem você saber. Não parece muito útil, certo?</p>
<p class="text-justify">Por mais que pareça bobeira, é um erro muito comum quando você usa uma linguagem que oferece a mutabilidade como padrão, como é o caso do Java.</p>
<p class="text-justify">Vamos ver em detalhes estruturas persistentes e transientes neste capítulo, enquanto nos capítulos sobre integração com o Java e sobre concorrência vamos ver com calma como a imutabilidade faz toda a diferença.</p>
<p class="text-justify">Um tipo escalar é todo aquele formado por um único valor. Nessa classificação se encaixam;; valores lógicos, ou booleanos, representador pore; e, que representa a ausência de valor ou um valor nulo.</p>
<p class="text-justify">Existem outros dois tipos escalares específicos do Clojure,e.</p>
<p class="text-justify">Você deve se lembrar da formaque usamos para criar umlocal:</p>
<p class="text-justify">No nosso código atribuimos o valor numéricoao.</p>
<p class="text-justify">Odessa expressão é um símbolo Clojure, que internamente vai apontar para o valor. Esse símbolo é representado em Clojure por um tipo chamado.</p>
<p class="text-justify">Por mais que pareça natural ter um símbolo que aponta para um valor em qualquer linguagem, na forma deou, não paramos para pensar no que o símbolo em si representa até encontrarmos um tipo específico para isso, como acontece com o Clojure.</p>
<p class="text-justify">O ato do compilador olhar para um símbolo e utilizar o valor para o qual ele aponta é chamado de. Então, no nosso código, quando você manda imprimir, a linguagem olha para o valor que está sendo apontado e retorna.</p>
<p class="text-justify">Ainda olhando para o código que escrevemos, podemos entender quetambém é um símbolo, que internamente aponta para uma macro, eé ainda outro símbolo que aponta para uma função que imprime na tela.</p>
<p class="text-justify">Então você se pergunta onde é que isso vai ser usado. O tempo todo, eu respondo. Mas você dificilmente vai precisar saber se um valor é um símbolo ou não.</p>
<p class="text-justify">De qualquer maneira, é bom conhecer o que é e o que faz um símbolo.</p>
<p class="text-justify">Existem duas funções para lidar com símbolos:e. A primeira cria um símbolo sem atribuir qualquer valor:</p>
<p class="text-justify">Járetornacaso o parâmetro seja um símbolo. Porém, existe uma pegadinha aí.</p>
<p class="text-justify">Se passarmos o símbolo como parâmetro, a função vai receber o valor que foia ele (daí o nome), e não o símbolo propriamente dito:</p>
<p class="text-justify">Entra em cena o operador, ou simplesmente, que diz ao compilador que aquele símbolo ou expressão não deve ser resolvido ou avaliado.</p>
<p class="text-justify">Já o tipopode ser considerado um irmão mais famoso do, que aponta para si mesmo ao invés de apontar para outro valor. Seé o irmão dedo-duro, podemos dizer queé o irmão egoísta.</p>
<p class="text-justify">normalmente são utilizadas como chaves em um mapa, mas podem também ser utilizadas no lugar de um texto repetitivo que possa indicar uma configuração ou opção de uma função ou biblioteca, como uma constante ou uma enumeração.</p>
<p class="text-justify">Assim como acontece com, existem as funçõesepara, respectivamente, criar umou verificar se o parâmetro é um.</p>
<p class="text-justify">Finalmente, como umtem a si mesmo como valor, não é necessário declará-lo antes de usar.</p>
<p class="text-justify">Internamente, a classe Java responsável pela representação de umimplementa também a classe Javaque é a base de todas as funções do Clojure.</p>
<p class="text-justify">Isso significa que podemos usar umcomo um operador, o que acaba sendo uma boa prática.</p>
<p class="text-justify">Imagine que temos um mapa simples, contendo o código do Estado e seu respectivo nome:</p>
<p class="text-justify">Ambas as formas retornam o mesmo resultado. Mais para frente vamos ver essa característica em detalhes, e quais as suas vantagens.</p>
<p class="text-justify">Existe um tipo especial deque traz automaticamente ono qual ele foi criado junto do próprio nome. Por conta disso ele é chamado de, ou. Vou chamá-los apenas depara não gastar o dedo digitando.</p>
<p class="text-justify">Essede nome diferente funciona assim: ao invés de utilizarmos um sinal de dois-pontos antes do nome, usamos dois. Odo Clojure substitui o segundo sinal de dois-pontos peloatual.</p>
<p class="text-justify">Vamos partir do pressuposto de que você acabou de entrar noe estamos no.</p>
<p class="text-justify">Onão pertence a nenhum. Como já foi dito aqui, ele é um egoísta que só olha para si mesmo. Uma das vantagens disso é que você pode utilizar umem qualquer lugar do sistema sem nem se preocupar onde foi o primeiro lugar em que ele foi criado.</p>
<p class="text-justify">Já opertence ao, não interessando o que aconteça com ele daqui para frente. Isso permite, por exemplo, que você tenha mais de umcom o mesmo nome, desde que cada um pertença a umdiferente.</p>
<p class="text-justify">Apesar do uso dequalificados ser bem menos comum que o seu irmão sem sobrenome, existem situações em que seu uso é bem vindo.</p>
<p class="text-justify">Imagine que você tenha um(ou dicionário, ou mapa - veremos em detalhes a seguir), que pode ser manipulado por funções em diferentes.</p>
<p class="text-justify">Seria uma forma de evitar conflitos caso você tenha doiscom o mesmo nome.</p>
<p class="text-justify">Vamos criar umque será compartilhado por mais de um.</p>
<p class="text-justify">Agora vamos atribuir um valor aoutilizando a função.</p>
<p class="text-justify">Agora vamos criar outroe repetir a alteração.</p>
<p class="text-justify">Podemos utilizarqualificados também para definir hierarquias de tipos de dados. Em linguagens orientadas a objeto nós temos hierarquia de dados na forma de herança. Aquela história de, só que sem herdar os comportamentos típicos de um objeto.</p>
<p class="text-justify">Vamos usar o exemplo dos gatos e cachorros para exemplificar. É um tanto bobo e desconectado do mundo real, mas tem um grande valor didático.</p>
<p class="text-justify">Vamos usar a funçãopara dizer que um tipo é derivado de outro, ou que um tipo é subtipo de outro.</p>
<p class="text-justify">Vamos começar com o cachorro.</p>
<p class="text-justify">Agora vamos para o gato.</p>
<p class="text-justify">Então vamos verificar se um cachorro ou um gato são animais, e então termos certeza de que gatos não são cachorros. Para isso usamos a função.</p>
<p class="text-justify">Parece um tanto lógico também que todo cachorro é um animal, mas nem todo animal é um cachorro.</p>
<p class="text-justify">Podemos dizer também que um poodle é um cachorro, e ainda assim continua sendo um animal.</p>
<p class="text-justify">Lembrando de, vamos integrar com o que acabamos de aprender sobre hierarquia.</p>
<p class="text-justify">Vamos definir alguns mamíferos.</p>
<p class="text-justify">Agora vamos definir alguns animais que voam e outros que nadam.</p>
<p class="text-justify">Agora vamos criarque mostrem mensagens de acordo com tipo do animal. Vamos usar a função, que retorna o próprio parâmetro. Por exemplo,retorna.</p>
<p class="text-justify">Agora começa a diversão. Primeiro vamos testar um cachorro. Para a tranquilidade das entidades protetores de animais, nenhum cachorro será ferido, incomodado ou molestado na execução desses testes.</p>
<p class="text-justify">Legal. Vamos um gato e, em seguida, um morcego.</p>
<p class="text-justify">O Clojure ficou confuso, já que um morcego é mamífero e ao mesmo tempo voador. Tudo bem, é complicado explicar para uma criança que nem todo animal que voa é ave.</p>
<p class="text-justify">Vamos utilizar a funçãopara dizer qual valor tem prioridade na hierarquia.</p>
<p class="text-justify">Vamos dar um desconto ao nosso código por ele não saber que o correto éao invés de.</p>
<p class="text-justify">Fazendo o mesmo com os mamíferos que nadam, podemos testar a baleia e o salmão. Novamente nenhum ser aquático será incomodado na execução do código a seguir.</p>
<p class="text-justify">No capítulovamos descobrir outra aplicação paraqualificados ao trabalharmos com protocolos.</p>
<p class="text-justify">Um valor do tipoé um texto, sem nenhuma diferença especial em relação à sua linguagem preferida. Internamente é usada a classe, que é exatamente a mesma que você usa no Java padrão. Isso significa que todos os métodos que você já utiliza comno Java estão disponíveis no Clojure. Vamos usar a funçãopara poder ver isso na prática:</p>
<p class="text-justify">A biblioteca padrão vem também com um namespace chamadoque traz mais algumas funções para complementar os métodos da classedo Java.</p>
<p class="text-justify">Apesar de umaser um tipo escalar, e não uma coleção (que veremos em detalhes mais adiante), o Clojure dá um jeito para que seja tratado como se fosse. Isso acontece porque, sempre que uma função que lida com sequencias recebe uma, é retornada uma sequencia de verdade, ou parte dela, como resultado:</p>
<p class="text-justify">Quando o Clojure trata umacomo sequencia, cada item é representado por um caracter. Da mesma forma, qualquer método válido para tratar caracteres em Java pode ser usado para manipular caracteres em Clojure, uma vez que o tipo é o mesmo em ambas as linguagens.</p>
<p class="text-justify">A principal diferença aqui é visual. Enquanto em Java os caracteres são representados entre apóstrofos, em Clojure utilizamos uma barra invertida antes do caracter:</p>
<p class="text-justify">E para montar umaa partir de vários caracteres, podemos usar a conhecida função:</p>
<p class="text-justify">Expressões regulares são sequencias de caracteres que formam um padrão de busca. A ideia foi criada na década de 1950, por um matemático chamado Stephen Cole, mas as expressões passaram a ter um uso mais prático na década de 1960, quando Ken Thompson, desenvolveu um editor chamado, que fazia uso de expressões regulares para pesquisar textos dentro de um arquivo.</p>
<p class="text-justify">A título de curiosidade, Ken Thompson também foi o responsável ela linguagem, que deu origem à linguageme também é um dos criadores da linguagem Go.</p>
<p class="text-justify">Uma expressão regular em Clojure é escrita como uma, mas com um caracterna frente. Você também pode criar uma expressão regular a partir de umausando a função:</p>
<p class="text-justify">Para encontrarmos um valor dentro de outro, usamos a função, passando como parâmetros a expressão regular e o texto que pode conter o que precisamos:</p>
<p class="text-justify">Caso a expressão, ou, não seja encontrada na frase, a funçãoretorna. No nosso exemplo, não havia nenhum gato próximo à roupa do rei de Roma e deu no que deu.</p>
<p class="text-justify">Já a funçãonos retorna uma sequencia contendo todas as ocorrências daquele. Vamos criar uma sequencia contendo todas as palavras da frase que comecem com a letra:</p>
<p class="text-justify">E cadê a palavra?</p>
<p class="text-justify">Por padrão, uma expressão regular diferencia maiúsculas de minúsculas. Para alterar esse comportamento precisamos adicionar a opçãoantes do:</p>
<p class="text-justify">Existem várias outras opções além do</p>
<p class="text-justify">Existem guias de expressões regulares para todos os gostos na Internet, além de sites para que você possa testar suas expressões contra textos de diversos tamanhos. Os meus preferidos, e os que recomendo, são o(http://www.rubular.com) e o(http://www.regexr.com/).</p>
<p class="text-justify">A funçãoque está no namespacetambém utiliza expressões regulares para substituir ocorrências dentro de textos.</p>
<p class="text-justify">Vamos usarparaa frase:</p>
<p class="text-justify">Agora que sabemos tudo sobreno Clojure, vamos aos números.</p>
<p class="text-justify">Não há muitos segredos quando se trata de números em Clojure. Números inteiros são, por padrão, representados com a classedo Java, que permite valores entree, o que dá e sobra para a maioria dos cálculos que quisermos fazer.</p>
<p class="text-justify">As constantesecontém, respectivamente, o menor e o maior valor possível que pode ser armazenado como. É bem mais fácil lembrar o nome da constante do que memorizar esses valores gigantescos.</p>
<p class="text-justify">Caso isso ainda não seja suficiente, o próprio Clojureo valor paracaso você utilize os operadores terminados em, como,,e assim por diante.</p>
<p class="text-justify">Para lidar com números decimais, é utilizada a classedo Java. Da mesma forma que acontece com os números inteiros, o Clojure pode promover o valor paracaso seja necessário.</p>
<p class="text-justify">Você pode trabalhar diretamente come, adicionando a letraao final do número inteiro ou a letraao final do número decimal.</p>
<p class="text-justify">Existem também as funçõese, caso você precise converter o valor em tempo de execução.</p>
<p class="text-justify">Resumidamente,é quando tentamos atribuir um valor muito grande a um tipo de dado que não comporta aquela quantidade de informação.</p>
<p class="text-justify">Imagine que você tem um copo de 300ml e queira colocar um litro d'água dentro dele. Obviamente o litro d'água não vai caber no copo, então podem acontecer duas coisas: ou você desiste assim que perceber que a água não vai caber no copo; ou continua assim mesmo, despejando o litro, perdendo tudo o que foi derramado para fora do copo. Aliás, a tradução literal depara o português é justamente.</p>
<p class="text-justify">O Clojure permite que você escolha qualquer uma dessas duas abordagens e ainda traz uma terceira que não seria possível apenas usando o copo.</p>
<p class="text-justify">Na primeira forma, que seria aquela em que desistimos no meio do caminho, vamos causar um erro, parando o processo para que nada de pior aconteça.</p>
<p class="text-justify">Vamos utilizar a constanteque vimos acima, para já começarmos o exemplo no limite da capacidade de um tipo.</p>
<p class="text-justify">Sobre esse valor, vamos somar, que é suficiente para fazermos o copo transbordar, como podemos ver na figura.</p>
<p class="text-justify">Podemos permitir também que o copo transborde usando explicitamente as operações iniciadas por. Com isso deixamos claro que não estamos checando se houve, ganhando um pouco de tempo, mas perdendo completamente a segurança das checagens.</p>
<p class="text-justify">Aqui não ocorre o erro, mas ao somarmosao valor de, que é, teremos um número negativo. Aqui dizemos que ocorreu o, como podemos ver na figura.</p>
<p class="text-justify">Apenas para que você entenda o que aconteceu, considere que um valor do tipoocupa 64 bits de memória. Como esse número pode ser positivo ou negativo, o bit mais significativo, que é aquele mais a esquerda, é usado para indicar o sinal do número:se for negativo,se for positivo.</p>
<p class="text-justify">Com isso, o maior número positivo possível é, enquanto o maior número negativo é. Odo número positivo se deve ao fato do zero ser considerado positivo.</p>
<p class="text-justify">O númeroem binário é uma sequencia de 63 bits. Ao somar o número, teremos um bitseguido de 63 bits. Como acabamos de dizer, o bit mais a esquerda é usado como indicador de sinal, retornando o maior número negativo possível, que é o gigantesco. Esse bit mais a esquerda, que erae viroucom a soma, transbordou na conta, vindo daí o termo.</p>
<p class="text-justify">Na figuratemos uma variável de oito bits contendo o valore ao somarmosrecebemos o valor. Perceba que a soma, ou, para o bit responsável pelo sinal.</p>
<p class="text-justify">Voltando à nossa analogia, imagine que você, percebendo que o copo não vai comportar um litro d'água, ao invés de desistir ou desperdiçar água, busque um recipiente maior. Uma jarra, por exemplo. Pois é exatamente isso que o Clojure faz quando você usa o terceiro tipo de operador.</p>
<p class="text-justify">Vamos utilizar os operadores que já conhecemos seguidos do caracter, assim teremos as operações,e várias outras que automaticamente modificam o tipo do dado em que o valor vai ser guardado.</p>
<p class="text-justify">Perceba na figuraque o resultado está correto e que também aparece a letra, que indica que o número agora é um. Chamamos isso de, ou.</p>
<p class="text-justify">Então devemos usar sempre os operadores seguidos de? Não necessariamente.</p>
<p class="text-justify">Cada uma das formas tem suas vantagens e desvantagens. A formatende a ser mais rápida, sendo muito útil quando você está manipulando dados em conjunto com uma biblioteca do Java e a velocidade é algo crítico.</p>
<p class="text-justify">Já a forma seguida detende a ser mais lenta e ocupar mais memória, mas promove automaticamente os tipos de dados.</p>
<p class="text-justify">De qualquer forma, em pelo menos oitenta por cento dos casos, os operadores que você já conhecia servirão perfeitamente para o que você precisa.</p>
<p class="text-justify">É comum que as linguagens de programação forneçam formas de escrevermos números usando bases diferentes da que estamos habituados.</p>
<p class="text-justify">Nas linguagens inspiradas pelo C, podemos escrever números em baseeno meio do código, e o próprio compilador se vira para converter.</p>
<p class="text-justify">Já o Clojure nos oferece bem mais do que vamos precisar. Podemos escrever números em praticamente qualquer base que desejarmos, além das que as linguagens tradicionais já nos oferecem.</p>
<p class="text-justify">Podemos colocar praticamente qualquer número inteiro antes do literal, e o compilador vai entender que queremos converter a partir daquela base.</p>
<p class="text-justify">Com tanta base disponível de forma transparente, dá para se divertir bastante com mensagens engraçadinhas.</p>
<p class="text-justify">Você pode expressar também números muito grandes ou muito pequenos usando.</p>
<p class="text-justify">Notação científica é uma forma de representar valores usando a notação. Podemos representar dois milhões comoou, em Clojure, como. Umpode ser representado como, ou seja, o dígito um seguido dezeros.</p>
<p class="text-justify">Da mesma forma, podemos representar um número menor queusando um expoente negativo.</p>
<p class="text-justify">Estima-se que um átomo de hidrogênio tenhametros. Isso dá onze zeros depois da vírgula e, em seguida, o número.</p>
<p class="text-justify">Obviamente a precisão e as casas decimais são ignoradas a partir de um certo tamanho porque, como já dissemos, a memória de um computador é limitada e temos estruturas bem reduzidas para armazenar números dentro dele.</p>
<p class="text-justify">Caso você tenha curiosidade de saber os limites dessa notação, as constanteseda classepodem te dizer.</p>
<p class="text-justify">Fique tranquilo. Com essa notação podemos trabalhar com números muito maiores que ume muito menores que o tamanho do menor átomo.</p>
<p class="text-justify">Quando dividimos um número por outro em Clojure podemos ter duas respostas diferentes: um número inteiro ou um número racional.</p>
<p class="text-justify">O resultado deé, um número que internamente é representado pelo tipo.</p>
<p class="text-justify">Quando executamos a mesma operação em Java, Ruby ou qualquer outra linguagem popular, recebemos um número inteiro ou um decimal como resultado. Por que em Clojure é diferente?</p>
<p class="text-justify">O mesmo comportamento, de receber um número racional ao invés de um decimal, é encontrado nas demais implementações de LISP, como o Common Lisp, Scheme e Racket para ficar nas mais conhecidas. Logo, é um comportamento esperado quando estamos usando um Lisp.</p>
<p class="text-justify">Mas não é simplesmente porque todo mundo faz que você deva fazer também. O tipofoi criado para que a perda de precisão com arredondamento seja reduzida ao mínimo possível.</p>
<p class="text-justify">Para convertermos um valor racional em um valor decimal, basta utilizar a função:</p>
<p class="text-justify">E para converter um tipo decimal para racional, usamos a função:</p>
<p class="text-justify">Quando você divide um por três, você tem como resultado o número 0.333... seguido de infinitos 3. Essa repetição infinita de números é chamado de dízima periódica.</p>
<p class="text-justify">O problema é que em um computador existe um espaço finito para armazenar números, o que faz com que apenas uma quantidade reduzida de casas decimais seja armazenada. Esse truncamento do número gera uma perda que, mesmo minúscula, vai se acumulando com outros arredondamentos num processo conhecido matematicamente por.</p>
<p class="text-justify">Em sistemas pequenos esse erro acumulado é irrelevante, mas em grandes sequencias de cálculos pode fazer com que o resultado seja distorcido e cause sérios problemas.</p>
<p class="text-justify">Nas listagensepodemos ver como uma operação matemática pode apresentar diferentes resultados se utilizarmos números decimais.</p>
<p class="text-justify">Para termos uma boa quantidade de números para trabalhar, vamos usar a função, que recebe dois parâmetros e nos retorna uma lista. O primeiro é a quantidade de vezes que o item vai ser repetido, e o segundo parâmetro é o item a ser repetido:</p>
<p class="text-justify">Usando o nosso já conhecido operador, vamos somar cem mil ocorrências do número, que é um dividido por três armazenado como um número decimal:</p>
<p class="text-justify">Agora vamos deixar para converter o valor para decimal apenas no final da operação:</p>
<p class="text-justify">Perceba que houve uma diferença perceptível nos resultados entre as duas formas de calcular. A conversão para decimal no final da operação adia até o último instante a perda de precisão do valor.</p>
<p class="text-justify">Vamos criar uma lista com quatro elementos chamadae vamos adicionar a ela um quinto elemento, guardando o resultado com o nome:</p>
<p class="text-justify">A função, que adiciona um item ao final do vetor, retorna um novo valor e mantém o original inalterado, como já sabemos.</p>
<p class="text-justify">Aparentemente,esãodiferentes. Isso significa que, ainda aparentemente, estamos ocupando memória com duas estruturas distintas, mas com grande parte dos valores repetidos. Isso soa como um belode recursos.</p>
<p class="text-justify">Uma das vantagens de lidarmos com valores imutáveis é que, veja só, eles não mudam.</p>
<p class="text-justify">Isso significa que um valor imutável que está em umimutável permanece o mesmo, não importando o que aconteça. Com isso não precisamos nos preocupar com efeitos colaterais e modificações inesperadas caso esse valor seja compartilhado entre duas estruturas diferentes. E é aí que está o princípio do que em Clojure é chamada de.</p>
<p class="text-justify">Na figurapodemos ter uma idéia do que acontece internamente. Não estamos vendo aqui exatamente como funciona um vetor no Clojure, mas a ideia é a mesma: compartilhar valores iguais entre dois ou mais vetores, otimizando o consumo de memória e melhorando a velocidade das operações.</p>
<p class="text-justify">Mapas e, que veremos adiante, funcionam de forma parecida, sendo armazenados internamente em uma árvore e compartilhando partes conforme a necessidade.</p>
<p class="text-justify">Já uma lista é armazenada internamente como uma lista ligada, mas também compartilha parte de sua estrutura a cada operação.</p>
<p class="text-justify">Em Clojure, existe uma categoria de tipos de dados chamada genericamente de. Uma coleção nada mais é do que a.</p>
<p class="text-justify">O que esse palavreado todo quer dizer?</p>
<p class="text-justify">Quer dizer que uma coleção do Clojure, independente de qual seja, implementa internamente uma mesma interface Java. Essa interface declara operações comuns que permitem que você adicione, remova ou localize itens dentro de uma coleção usando as mesmas funções do Clojure.</p>
<p class="text-justify">Dessa forma você não precisa decorar dezenas de funções diferentes para conseguir trabalhar com cada tipo de coleção. Basta saber que uma função adiciona um item a uma coleção, e essa função vai adicionar itens em qualquer coleção que você esteja trabalhando.</p>
<p class="text-justify">Essas coleções podem ser classificadas, de uma maneira bem simplificada, de acordo com as interfaces Java que cada uma implementa internamente.</p>
<p class="text-justify">Apesar de cada tipo de dado em Clojure implementar uma avalanche de classes e interfaces Java, como podemos ver na figura, podemos utilizar três delas para descrever cada um dos tipos principais de coleção:,e. Na imagempodemos ver mais claramente essa classificação.</p>
<p class="text-justify">Uma coleção sequencial, ou simplesmente uma, é uma abstração que permite que você selecione tanto o primeiro item quanto o resto da sequencia sem o primeiro item, ou que você adicione um item na sequencia sem bagunçar a ordem que existe atualmente.</p>
<p class="text-justify">Uma coleção associativa permite que você acesse qualquer valor diretamente, bastando informar a sua posição ou a chave que faz referência àquela posição.</p>
<p class="text-justify">Finalmente, uma coleção pode serouse nos permite saber a quantidade de itens que ela contém.</p>
<p class="text-justify">Essa divisão é apenas uma forma de ajudar a entender quando e como você deve usar cada coleção do Clojure. Vamos entrar em mais detalhes em cada um dos tipos, deixando claro que você pode criar suas próprias coleções se for necessário.</p>
<p class="text-justify">Um código fonte escrito em Clojure é, basicamente, um conjunto de listas contendo operadores e operandos.</p>
<p class="text-justify">Por isso, a lista é a estrutura de dados mais comum, mas sua utilidade vai bem além das sequencias de instruções para o compilador.</p>
<p class="text-justify">Se você tentar trabalhar diretamente com uma lista, o compilador vai entender que estamos lidando com código fonte, e vai tentar executar o primeiro item como se fosse um operador.</p>
<p class="text-justify">Para que isso não aconteça, temos que informar ao compilador que o conteúdo da lista não deve ser avaliado. Para isso usamos o operador, conhecido como. A forma especialcausa o mesmo efeito.</p>
<p class="text-justify">Usarem uma lista faz com que ela seja transformada de código para dados.</p>
<p class="text-justify">É possível guardar código dentro de uma lista com. Para executar a lista, efetuamos a operação inversa através do operador. O operador, chamado devai ser muito útil quando aprendermos sobre macros.</p>
<p class="text-justify">Aqui nós criamos uma lista contendo uma instrução válida e fizemos o caminho oposto, transformando dados em código.</p>
<p class="text-justify">O operador, conhecido entre nós como acento grave, significa, e também será visto com mais atenção no capítulo sobre macros.</p>
<p class="text-justify">O Clojure oferece também um tipo chamado, que assim como uma lista, pode ter qualquer posição acessada através da função, começando por zero. Umé equivalente a umnas demais linguagens.</p>
<p class="text-justify">Um vetor também pode ser usado como função. Ao passar um valor numérico para um vetor, você obtém o valor contido naquela posição.</p>
<p class="text-justify">Assim você elimina a chamada aexplícita ao acessar alguma posição de um vetor. Internamente o vetor vai continuar usandopara acessar aquela posição, então usar ou não acaba sendo uma questão de estilo e legi bilidade.</p>
<p class="text-justify">Existem algumas diferenças importantes entre as listas e os vetores e que vale a pena conhecer.</p>
<p class="text-justify">A principal diferença é que vetores guardam apenas dados, diferente do que já aprendemos sobre listas e não é tão simples converter os itens de um vetor em uma expressão.</p>
<p class="text-justify">Vetores têm um tempo constante de acesso a qualquer posição, então uma lista leva mais tempo para acessar um item que está no meio do que um que está no começo.</p>
<p class="text-justify">Um vetor é alocado de uma única vez na memória, tornando impossível lidar com quantidades imensas de informação, enquanto com uma lista você pode alocar somente o que está sendo utilizado naquele momento. Veremos isso com detalhes ao tratar de.</p>
<p class="text-justify">Listas são úteis em situações em que é necessário processar itens em sequencia, e por isso são chamadas na documentação de. Já vetores são preferíveis quando é necessário acessar posições aleatórias.</p>
<p class="text-justify">Devido à forma como listas e vetores são armazenados internamente, você obtém resultados diferentes ao adicionar um item a uma lista existente. Em uma lista você adiciona um item na primeira posição, enquanto num vetor o item é adicionado sempre no final.</p>
<p class="text-justify">Isso acontece porque uma lista pode ser entendida como uma estrutura de dados chamada de, onde você armazena uma referência para o primeiro item, e cada item armazena a referência para o próximo.</p>
<p class="text-justify">Assim, é bem mais barato armazenar a referência para o item que está sendo adicionado e apontar o próximo item para a referência antiga, colocando o novo item como primeiro da lista.</p>
<p class="text-justify">Na figurapodemos ver a listacomo uma lista ligada, e empodemos entender melhor como um item é adicionado à lista.</p>
<p class="text-justify">Funções comoeaceitam tanto listas como vetores como parâmetros, mas retornam sempre uma sequencia como resultado. Caso você queira outro vetor como resposta, use as funçõese, respectivamente.</p>
<p class="text-justify">Uma fila é uma estrutura de dados onde o primeiro item inserido é o primeiro a ser retirado.</p>
<p class="text-justify">Vamos imaginar a fila do supermercado, onde a pessoa que chegou primeiro é a primeira a ser atendida. Ao ser atendida, a pessoa sai da fila e assim por diante até que a fila fique vazia, ou o supermercado encerre as atividades.</p>
<p class="text-justify">Apesar do Clojure ter uma implementação de fila, até a versão 1.6.0 ainda não estava disponível um conjunto de funções que nos permita criar essa estrutura de forma idiomática.</p>
<p class="text-justify">Felizmente, como já pudemos ver, Clojure e Java se conversam bem, então podemos usar a própria classe Java que implementa a fila do Clojure dentro do nosso código.</p>
<p class="text-justify">Para criarmos uma fila vazia, basta usarmos a classe Java, que já nos oferece uma instância de uma fila vazia, chamada.</p>
<p class="text-justify">Vamos guardar essa fila numchamado:</p>
<p class="text-justify">Usamos a funçãopara mostrar que a fila está vazia. Essa função retornasempre que uma coleção vazia qualquer for passada como parâmetro.</p>
<p class="text-justify">Vamos adicionar o valorna fila, de acordo com a figura. Como estamos lidando com uma estrutura imutável, ao adicionarmos um item em uma fila teremos outra fila. Vamos salvar essa fila nova em. Vamos usar a função, que é a mesma que já utilizamos para adicionar itens em listas e vetores.</p>
<p class="text-justify">A função, nossa conhecida de outras coleções, nos retorna a quantidade de itens contidos na fila. Já a funçãonos mostra quem é o primeiro item da fila. Como a fila é imutável, é necessário termos uma função que pegue o primeiro item da fila e outra que nos retorne a fila sem esse primeiro elemento.</p>
<p class="text-justify">Sem muita pressa, vamos adicionar dois itens de uma vez na nossa fila. Vamos chamar a nova fila de.</p>
<p class="text-justify">Agora a pilha pode ser representada conforme a figura. Perceba que o valorainda é o primeiro da fila, já que foi o primeiro a entrar nela.</p>
<p class="text-justify">Agora vamos retirar o primeiro item da fila e guardar o resultado em.</p>
<p class="text-justify">Para pegarmos o primeiro item da fila, usamos a nossa conhecida função, mas para devolvermos a função sem esse item, devemos usar a função.</p>
<p class="text-justify">Agora temos a fila da figura, com dois elementos e o valorcomo o primeiro da fila.</p>
<p class="text-justify">No início da explicação foi comentado que. Uma forma idiomática é aquela que está de acordo com o.</p>
<p class="text-justify">A forma idiomática de se criar uma fila em Clojure seria, ao invés de usarmos diretamente uma classe Java para isso, utilizarmos uma função, que podemos escrever facilmente enquanto a biblioteca padrão não nos fornece esse recurso.</p>
<p class="text-justify">Vamos criar uma funçãoque cria essa fila:</p>
<p class="text-justify">Nossa função retorna uma fila vazia. Mas, e se quisermos criar uma fila que já contenha quantos elementos quisermos? Basta adicionar mais uma assinatura à função e usar a funçãopara adicionar os valores passados por parâmetro.</p>
<p class="text-justify">Como podemos receber uma quantidade variável de parâmetros, os valores passados paraficam armazenados no vetor. Para convertermos esse vetor em uma lista de argumentos para a função, usamos a função, passando também uma lista vazia através da própria funçãosem parãmetros.</p>
<p class="text-justify">Para sabermos se um item é ou não uma fila, vamos criar uma função chamada, que simplesmente verifica se o valor informado é uma instância da classe. Para isso, vamos usar a função.</p>
<p class="text-justify">Mesmo quando o Clojure não te oferece algo por padrão, é fácil e rápido fazermos uma adaptação para que possamos trabalhar bem.</p>
<p class="text-justify">Isso acontece com a estrutura de dados conhecida como. O Clojure não nos fornece uma função nativa ou uma classe Java para lidarmos com pilhas, mas podemos adaptar uma lista para termos as mesmas funcionalidades.</p>
<p class="text-justify">Para entendermos uma pilha, podemos pensar em uma pilha de pratos para lavar. O primeiro prato que você colocar na pilha vai ser o último que você vai conseguir tirar. Da mesma forma, o último prato que você colocar, que é aquele que vai estar no topo, é o primeiro a ser retirado.</p>
<p class="text-justify">Para utilizarmos pilhas em Clojure, basta usarmos a nossa já conhecida. Como o último valor adicionado a uma lista fica sempre no começo, temos uma estrutura pronta para fazer o que queremos.</p>
<p class="text-justify">Vamos criar uma lista vazia e chamá-la de, para então adicionar o valor, conforme a figura, armazenando o resultado em.</p>
<p class="text-justify">Usando as mesmas funçõespara adicionar, epara saber qual é o primeiro item, não conseguimos ver ainda nenhum comportamento de pilha.</p>
<p class="text-justify">Vamos então adicionar os valorese, respectivamente, para termos a pilha da figurae entendermos melhor como ela funciona. Vamos chamar a nova pilha de.</p>
<p class="text-justify">Agora o primeiro item da pilha é o valor, que foi justamente o último a ser adicionado.</p>
<p class="text-justify">Vamos agora remover o primeiro item da pilha usando a função, para termos a pilha representada na figura. Vamos armazenar a nova pilha em.</p>
<p class="text-justify">Usandoagora nós vemos que o próximo valor da pilha é. O valor, que foi o primeiro a entrar na pilha, vai ser o último a sair.</p>
<p class="text-justify">Um mapa é uma coleção que relaciona uma chave a um valor. Em outras linguagens você pode encontrar a mesma estrutura com os nomes de.</p>
<p class="text-justify">Clojure oferece duas formas principais de mapas: um, que é o tipo mais comum e por padrão não garante a ordem dos itens, e, que ordena os dados conforme eles são adicionados.</p>
<p class="text-justify">Para criarmos um mapa, podemos utilizar os caractereseentre os pares de valores, sendo que o primeiro item do par é a chave, e o segundo é o valor.</p>
<p class="text-justify">Vamos voltar ao nosso mapa com os nomes dos estados:</p>
<p class="text-justify">Os,,esão as chaves e os nomes dos estados são os valores.</p>
<p class="text-justify">Para acessá-los, basta você informar o mapa e a respectiva chave.</p>
<p class="text-justify">Ou a chave e o respectivo mapa, nessa ordem, uma vez que umpode ser tratado como uma função. Lembra que comentamos isso lá no começo, ao apresentarmos o tipo?</p>
<p class="text-justify">Olhando assim, tanto faz uma forma como outra. Mas, e se ao invés de um mapa todo certinho e preenchido, como é o caso de, recebermos um valor nulo?</p>
<p class="text-justify">Ao tentar acessarcomo um mapa, nós vamos receber o famigerado, e provavelmente vamos derrubar nossa aplicação.</p>
<p class="text-justify">Para resolver isso, basta trocarmos a ordem, usando odo mapa. É aí que começa a fazer sentido umser tratado como função, e é por isso também que eu disse antes que é uma boa prática:</p>
<p class="text-justify">Essa segunda forma também auxilia muito ao acessarmos mapas dentro de mapas. Vamos imaginar que alguma função tenha convertido um arquivovindo de um sistema comercial em um mapa Clojure para podermos trabalhar melhor.</p>
<p class="text-justify">O nossooriginal teria essa estrutura:</p>
<p class="text-justify">Que convertido para um mapa Clojure ficaria com a seguinte estrutura:</p>
<p class="text-justify">Agora precisamos exibir um texto contendo a descrição do produto que foi comprado.</p>
<p class="text-justify">Podemos usar a forma comum, com o mapa antes da chave:</p>
<p class="text-justify">Ou podemos usar a forma em que a chave vem antes do mapa:</p>
<p class="text-justify">Vamos usar o que aprendemos até agora sobre mapas,e funções e vamos deixar essa expressão ainda mais simples e legível:</p>
<p class="text-justify">Comotambém são reconhecidos pelo compilados como funções, podemos usá-los sem problema algum com os.</p>
<p class="text-justify">A chave de um mapa pode ser qualquer valor válido em Clojure, e não apenas um.</p>
<p class="text-justify">Podemos usar um número como chave:</p>
<p class="text-justify">Podemos usar um texto, ou qualquer outro valor que quisermos:</p>
<p class="text-justify">Foi dito anteriormente que mapas, por padrão, não garantem a ordem dos itens. Isso acontece por conta da forma como os mapas são implementados internamente.</p>
<p class="text-justify">Ao criar um mapa vazio usando, estamos criando um. Essa forma de mapa é recomendada para pequenas quantidades de dados, já que mantem a ordem dos itens no momento de sua criação, mas aumenta o tempo de acesso a cada um deles conforme você vai avançando para o final da coleção.</p>
<p class="text-justify">A partir de um certo tamanho, que varia de acordo com a implementação, é recomendado trabalhar com, que já é otimizado para quantidades maiores de informação, mas não garante a ordem dos elementos.</p>
<p class="text-justify">As três formas,,ecriam um mapa. Internamente podemos perceber que as duas últimas formas armazenam os valores de formas diferentes.</p>
<p class="text-justify">Qual formas devemos utilizar então?</p>
<p class="text-justify">Quando você cria a formapara criar um mapa, o próprio Clojure seleciona a melhor estrutura de acordo com a quantidade de itens. O mesmo acontece com as funções que manipulam mapas, e é onde não podemos confiar que o mapa terá a ordem dos valores mantida.</p>
<p class="text-justify">Vamos criar um mapa usando, que manteve a ordem dos itens no nosso exemplo. Em seguida vamos usar a funçãopara criar um novo mapa com dois novos itens que queremos adicionar.</p>
<p class="text-justify">Note que a ordem do novo mapa já começa a ficar bagunçada. O fato de termos escolhido a funçãonão significa que os novos mapas que criarmos vão manter a ordem.</p>
<p class="text-justify">Caso a ordem seja realmente importante, você deve criar o mapa usando a função.</p>
<p class="text-justify">Agora podemos adicionar quantos itens quisermos e o mapa estará sempre ordenado.</p>
<p class="text-justify">Vamos bagunçar um pouco mais e criar um mapa que esteja ordenado de forma decrescente. Para isso vamos usar, que recebe uma função como primeiro parâmetros e os itens do mapa em seguida.</p>
<p class="text-justify">A nossa função vai comparar as chaves usando a função da biblioteca padrão chamada. Essa função retornase o segundo item for maior que o primeiro,se o primeiro for maior que o segundo ese os itens forem iguais.</p>
<p class="text-justify">Como queremos inverter o funcionamento da função, vamos multiplicar o resultado porem nossa função.</p>
<p class="text-justify">Agora passamoscomo parâmetro parae eis o nosso mapa ordenado decrescente.</p>
<p class="text-justify">Podemos adicionar quantos itens quisermos no nosso novo mapa e a ordem será mantida.</p>
<p class="text-justify">Quando manipulamos mapas, tanto faz se são ordenados ou não. As funções que tratam de um tipo também tratam de outro, tornando mais fácil memorizar ou pesquisar aquela que precisamos.</p>
<p class="text-justify">O nosso já conhecidotambém tem utilidade aqui. Como acontece com as demais coleção, essa função junta um mapa com outro, retornando um terceiro.</p>
<p class="text-justify">A diferença para a função, que conhecemos há pouco, é quejunta um mapa com outro, enquantoassocia um mapa a um ou mais pares de chave e valor.</p>
<p class="text-justify">É mais comum usarmos a funçãodo que a funçãopara unirmos dois mapas. Internamente a funçãousa, o que acaba nos dando o mesmo resultado. Isso acontece porque o termoé normalmente usado quando combinamos um conjunto de coisas com outro para formarmos um terceiro conjunto.</p>
<p class="text-justify">Se os dois mapas tiverem algum item com a mesma chave, será escolhido o item do mapa da direita.</p>
<p class="text-justify">É comum em Clojure termos duas funções que fazem praticamente a mesma coisa. Enquanto isso pode parecer desperdício ou redundância, acaba sendo uma forma de tornar o código mais expressivo e fácil de ler. Vamos ter outro exemplo disso mais adiante, ao estudarmos.</p>
<p class="text-justify">A funçãotem ainda uma irmã, chamadaque, além do mapa original, recebe também uma função como parâmetro e finalmente os dados a serem combinados ao mapa original.</p>
<p class="text-justify">Ao invés de simplesmente substituir o valor atual pelo valor novo, a funçãoaplica a função para os valores que tiverem a mesma chave.</p>
<p class="text-justify">Vamos aplicar os nossos mapas verduras e raizes, concatenando os textos contidos nas chaves repetidas.</p>
<p class="text-justify">Acho quenão fica legal. Podemos então escrever uma função que adicione vírgulas entre as palavras, para deixarmos o resultado mais legível.</p>
<p class="text-justify">Ficou bem melhor agora, certo?</p>
<p class="text-justify">Podemos também usarpara agregar resultados de inúmeros mapas em um único.</p>
<p class="text-justify">Considere que, passada a primeira fase de um campeonato de futebol você tenha a quantidade de gols que cada time marcou. Porém, como cada jogo acontece independente do outro, você terá um mapa para cada jogo, onde o time é a chave, e a quantidade de gols é o valor.</p>
<p class="text-justify">Como os jogos estão dentro de um vetor, vamos usar a nossa conhecida funçãopara transformá-lo em uma lista de parâmetros para. A funçãovai somar as quantidades de gols de cada time por jogo e pronto, temos o total de gols de cada um.</p>
<p class="text-justify">Agora sabemos que o Brasil marcou sete gols, enquanto Camarões marcou apenas um.</p>
<p class="text-justify">Se quisermos remover um item do mapa, usaremos o oposto de, que é a função. Enquanto uma, a outra.</p>
<p class="text-justify">Como já foi dito, um mapa é uma coleção que relaciona chaves com seus respectivos valores, sendo um valor para cada chave.</p>
<p class="text-justify">Podemos retornar sequencias contendo todas as chaves e também contendo todos os valores.</p>
<p class="text-justify">Para extrairmos as chaves, vamos usar a função, informando o mapa como parâmetro.</p>
<p class="text-justify">Vamos extrair a lista de times que participaram do campeonato que citamos, usando a funçãoe o nosso mapa, que contém a quantidade de gols marcados por cada time.</p>
<p class="text-justify">Agora vamos somar a quantidade de gols que tivemos naquela fase do campeonato extraindo os valores do mapaatravés da função.</p>
<p class="text-justify">Finalmente, vamos brincar um pouco com o que aprendemos, calculando a média de gols por partida. Para isso vamos somar a quantidade total de gols marcados e então dividir pela quantidade de jogos.</p>
<p class="text-justify">E eis que tivemos uma média de três gols por partida.</p>
<p class="text-justify">A operação oposta, de criarmos um mapa através de duas coleções, uma de chaves e outra de valores, também é possível se utilizarmos a função.</p>
<p class="text-justify">Como exemplo, vamos sortear uma cor para cada participante de um jogo de tabuleiros. Existem quatro cores e cinco amigos para jogar, mas um deles terá que ficar de fora.</p>
<p class="text-justify">Vamos usar a funçãopara embaralhar as listas de cores e de amigos, fazendo com que o sorteio seja realmente imprevisível.</p>
<p class="text-justify">Agora vamos usarpara associarmos cada cor a um jogador. Como são quatro cores para cinco amigos, o último vai ficar só assistindo.</p>
<p class="text-justify">E José vai esperar a próxima rodada para poder jogar.</p>
<p class="text-justify">Umé uma coleção de valores únicos. Podemos visualizar melhor o que é umse lembrarmos das aulas de teorias dos conjuntos. Cadaseria um conjunto, e temos à nossa disposição boa parte das operações matemáticas que usamos com conjuntos.</p>
<p class="text-justify">Como este não é um livro de matemática ou de teoria dos conjuntos, não vamos cobrir todas essas operações, mas usaremos o assunto como analogia sempre que necessário.</p>
<p class="text-justify">Podemos criar umusando a função, passando uma sequencia ou um vetor como argumento, ou delimitando os itens entre os caracteres.</p>
<p class="text-justify">Umé usado normalmente para verificar se um determinado item pertence a um conjunto. Aproveitando os exemplos acima, podemos usar a nossa já conhecida técnica de verificar se um caracter é uma vogal.</p>
<p class="text-justify">Podemos fazer isso usando a função, que vai retornarou, ou usando umcomo se fosse uma função, que vai retornar o próprio valor pesquisado caso ele pertença ao conjunto oucaso ele não pertença.</p>
<p class="text-justify">As funçõesetambém funcionam com.</p>
<p class="text-justify">Para criarmos uma partir de uma lista de argumentos, podemos usar as funçõese.</p>
<p class="text-justify">Da mesma maneira que acontece com os mapas, umnão garante a ordem dos elementos, mas é otimizado para encontrar rapidamente qualquer elemento.</p>
<p class="text-justify">Também como já vimos com os mapas, é possível criar uma função para ordenar ode acordo com as nossas necessidades.</p>
<p class="text-justify">Vamos criar uma função chamadapara podemos ordenar oem ordem descrescente e depois criar umordenado através da função.</p>
<p class="text-justify">Existe umapenas para lidar com. Com ele temos acesso a funções Clojure que reproduzem algumas operações da Teoria dos Conjuntos.</p>
<p class="text-justify">Vamos criar dois conjuntos e vamos chamá-los dee. Através depodemos exibir graficamente os conjuntos e suas respectivas interações.</p>
<p class="text-justify">Vamos declarar nossos conjuntos, conforme a figura, usandopara fazermos o paralelo com código Clojure.</p>
<p class="text-justify">A união de dois grupos acontece quando juntamos todos os elementos decom todos os elementos de, mantendo apenas uma ocorrência do elemento caso haja repetição, como ocorre na figura. Para isso podemos usar a função.</p>
<p class="text-justify">Já na intersecção só mantemos os elementos em comum entre os conjuntose, como podemos ver na figura. A funçãofaz esse trabalho.</p>
<p class="text-justify">Já na diferença entreevocê remove todos os itens deque pertençam a, como podemos ver na figura. Para isso usamos a função.</p>
<p class="text-justify">É importante perceber que a funçãonão é comutativa. Isso significa que a diferença entreeé diferente da diferença entree, como podemos ver na figura.</p>
<p class="text-justify">É possível também utilizar as operações dee, além de saber se um elemento pertence ou não ao. A diferença entre estar contido e pertencer, é que, enquanto.</p>
<p class="text-justify">Para saber se um elemento pertence a um grupo, usamos a função, como já vimos no início da explicação sobre. Já para ver se um conjunto está contido em outro, usamos a função.</p>
<p class="text-justify">Olhando a figura, podemos perceber que.</p>
<p class="text-justify">Podemos representar isso usando Clojure da seguinte forma:</p>
<p class="text-justify">Pela mesma figura podemos ver que.</p>
<p class="text-justify">Já a funçãofaz o oposto, verificando se.</p>
<p class="text-justify">Sabendo que, podemos afirmar que, e podemos afirmar também quenão o contém.</p>
<p class="text-justify">As estruturas persistentes são excelentes para lidarmos com ambientes com várias threads e para manter a consistência das informações mas, em casos em que a velocidade é importante, podemos fazer uma concessão e utilizar estruturas mutáveis para tornar o processamento mais rápido.</p>
<p class="text-justify">É aí que entram as, que permite que você modifique valores dentro da própria estrutura, sem a necessidade de criar uma nova para cada modificação.</p>
<p class="text-justify">Para manter as coisas organizadas, uma estrutura transiente é obrigada a trabalhar em uma única thread, evitando todos os problemas relacionados a mutabilidade eque temos de sobra no Java e nas demais linguagens imperativas.</p>
<p class="text-justify">O uso é bem simples. Primeiro pegamos uma estrutura persistente qualquer e a convertemos em transiente através da função, manipulamos da maneira que bem entendermos e criamos uma estrutura persistente através da função. Perceba o ponto de exclamação no final do nome da função. Isso indica que a função ou macro causa algum tipo de efeito colateral e deve ser usada com atenção.</p>
<p class="text-justify">Vamos apresentar um exemplo bem simples criando uma função que recebe um número e retorna um vetor contendo todos os valores inteiros entree o número informado.</p>
<p class="text-justify">Usando o que já sabemos sobree, vamos escrever a função desta maneira:</p>
<p class="text-justify">Os números de linha foram adicionados para facilitar a explicação e para entendermos melhor onde o código vai precisar ser alterado.</p>
<p class="text-justify">Criamos um vetor vazio chamado, e um contador que vai deaté. No meio do laço, verificamos seé maior que, retornandocom os números ou então adicionando o valor seguinte a um novo vetor, repetindo a operação.</p>
<p class="text-justify">Vamos agora usar a função. Vamos roubar um pouco no resultado e usar a formapara que onão exiba os milhões de números contidos na lista.</p>
<p class="text-justify">A formapermite que executemos uma série de instruções, retornando o resultado da última. Vamos retornarcomo última expressão e assim resumimos em muito o que vai ser apresentado na tela.</p>
<p class="text-justify">Na máquina que estou usando enquanto escrevo o livro o processo levou quase nove segundos.</p>
<p class="text-justify">Vamos ver agora o que podemos melhorar usando uma estrutura transiente.</p>
<p class="text-justify">Vamos alterar um pouco o código para poder usar uma estrutura transiente. Perceba que a aparência do código é a mesma, não perdendo a clareza.</p>
<p class="text-justify">Na linha 2 nós vamos atribuir um vetor vazio transiente para, ao invés de um vetor persistente do código original. Na linha 6 nós vamos utilizar a função, que altera o próprio vetor ao invés de retornar um novo. Isso só é possível com estruturas transientes, que não são imutáveis.</p>
<p class="text-justify">Finalmente, para retornarmos o vetor, utilizamos a função, que cria uma estrutura persistente com o conteúdo de.</p>
<p class="text-justify">Vamos executar agora o código usando, para medirmos o tempo gasto para retornar o vetor com os números. Note que externamente a função parece igual mas, usando mutabilidade de maneira controlada, tivemos um grande ganho de desempenho.</p>
<p class="text-justify">Agora tivemos o mesmo resultado em menos de um décimo do tempo.</p>
<p class="text-justify">Existem duas formas de evitar que informações sejam corrompidos ou alterados indevidamente em um ambiente com que várias.</p>
<p class="text-justify">A primeira forma é fazer com que a informação não possa ser alterada, e isso o Clojure já faz por padrão.</p>
<p class="text-justify">A segunda forma é permitir que a informação seja alterada, como acontece com as estruturas transientes, mas impedir que mais de umapossa modificá-la. E os criadores do Clojure tiveram o cuidado de fazer as duas coisas.</p>
<p class="text-justify">Vamos criar uma função chamada, que simplesmente retorna o nome daatual.</p>
<p class="text-justify">Essa função executa o método estáticoda classe, que retorna um objeto. Então pegamos esse objeto e acessamos o método. Veremos nos próximos capítulos como acessar objetos Java dentro do Clojure em detalhes, mas por enquanto é suficiente saber que o código acima faz o mesmo queem Java.</p>
<p class="text-justify">Vamos criar um vetor transiente chamadoe adicionar o nome daatual texto, para sabermos onde foi feita a alteração;</p>
<p class="text-justify">Agora vamos criar uma função chamada, que vai modificaradicionando ao vetor o nome daatual. Perceba o ponto de exclamação no nome da função, para deixarmos claro de que causaremos um efeito colateral em sua execução.</p>
<p class="text-justify">Vamos executar a funçãopara ver se tudo corre bem.</p>
<p class="text-justify">Aqui usamos um pouco de magia negra para termos certeza do que aconteceu. Como uma estrutura transiente não oferece meios limpos de lermos o seu conteúdo, utilizamos o métodoque está dentro da classe, tratanto a estrutura como um objeto Java. É feio, mas serve ao nosso propósito educativo.</p>
<p class="text-justify">Podemos ver que tanto a primeira posição quanto aatual retornam o texto. O nome pode variar de acordo com o momento em que você estiver utilizando oou a quantidade de sessões doque você já abriu.</p>
<p class="text-justify">Agora sabemos que nossa funçãofunciona, vamos à parte realmente interessante, que é ver como o Clojure se comporta ao tentarmos misturar mutabilidade e diferentes.</p>
<p class="text-justify">Você ainda não sabia, mas toda função Clojure pode ser passada para umapara que possa ser executada em paralelo. Relaxe, pois veremos isso em detalhes em um capítulo específico. O que você precisa saber agora é que pode jogar uma função numae fica tudo bem.</p>
<p class="text-justify">Vamos criar umausando novamente a classe Java, e então invocaremos o métododo objeto que tivermos em mãos. Nosso código vai ficar com essa cara:</p>
<p class="text-justify">Esse código Clojure é equivalente ao código Java abaixo:</p>
<p class="text-justify">Em Clojure fica bem mais bonito, não?</p>
<p class="text-justify">Voltando ao nosso código, ao tentarmos executardentro de outra, o Clojure vai puxar nossa orelha.</p>
<p class="text-justify">Mesmo que você tente fazer algo errado, o Clojure toma os cuidados possíveis para que as coisas continuem na linha.</p>
<p class="text-justify">, ou metadados são. Clojure permite que você adicione informações adicionais a, símbolos, coleções,,,,ou qualquer classe Java que implemente a interface. Numa comparação bem rasa, uma anotação do Java ou do C# é uma forma de de utilizarmos metadados, visto que a classe, método ou membro anotado passa a levar uma informação que não afeta diretamente o uso daquele código.</p>
<p class="text-justify">Esses metadados são utilizados pelo compilador, por ferramentas que analizam o código ou por funções e macros que auxiliam a utilização do, como as nossas conhecidase.</p>
<p class="text-justify">Podemos adicionar metadados a uma lista usando a função, que recebe como parâmetros o valor e um mapa contendo os metadados:</p>
<p class="text-justify">Para acessarmos os metadados que acabamos de adicionar a, usamos a função.</p>
<p class="text-justify">Os metadados ficam guardados em um mapa, e podemos acessá-los como um mapa qualquer. Vamos exibir apenas a descrição:</p>
<p class="text-justify">Agora sabemos que podemos adicionar qualquer informação que acharmos relevante a uma lista ou qualquer outra coleção do Clojure, e já sabíamos que a macrobusca o texto explicativo das funções em seus respectivos metadados.</p>
<p class="text-justify">Vamos experimentar extrair por conta própria a documentação da função. Escolhemos essa função aleatóriamente. Você pode tentar com qualquer outra que pertença à biblioteca padrão do Clojure.</p>
<p class="text-justify">Primeiro vamos exibir a documentação, para termos uma noção do que esperamos encontrar. Em seguida vamos acessar os metadados usando a funçãopara começarmos a vasculhar as informações que queremos.</p>
<p class="text-justify">Enquantoretornou um texto explicativo, a funçãoretornou apenas. O que fizemos de errado?</p>
<p class="text-justify">Vamos olhar como a função foi declarada para entendermos exatamente o que acontece. Vou adicionar novamente números de linhas para poder explicar todo o processo.</p>
<p class="text-justify">As linhaseforam quebradas para poderem caber na página do livro, mas isso não vai afetar a explicação. O código fonte, que fica entre as linhase, foi removido para mantermos o foco no que é importante para explicação.</p>
<p class="text-justify">Podemos ver que entre as linhaseestão sendo declarados o texto da documentação e mais duas informações em forma de mapa. Internamente isso vai ser adicionado aos metadados da função, também usando a função.</p>
<p class="text-justify">Mas, se internamente o Clojure também usa, como fizemos no exemplo, por que ao usarmosnão encontramos nada?</p>
<p class="text-justify">Primeiro precisamos entender como a linguagem trabalha com o código por baixo dos panos.</p>
<p class="text-justify">Em Clojure, como na maioria das linguagens, temos dois momentos distintos na execução de um programa: um chamadoe outro chamado.</p>
<p class="text-justify">No chamado, o código Clojure é lido, interpretado e as macros são expandidas. Veremos esse passo com detalhes num capítulo todinho sobre macros.</p>
<p class="text-justify">Nesse período deosdeclarados pelo operadorsão criados e o código que está dentro das macros é executado.</p>
<p class="text-justify">Em seguida, em, o conteúdo das funções e expressões que serão atribuídas aosserão executados.</p>
<p class="text-justify">Para fixar melhor como funciona, pense que emé criada a panela, emé feita a comida. Escrever com fome causa essas coisas.</p>
<p class="text-justify">Quando executamosno, estamos criando metadados em tempo de execução, já que estamos avaliando uma expressão. Com isso associamos o metadado à lista que foi criada. Se você passar essa lista como parâmetro para alguma função, o metadado vai junto.</p>
<p class="text-justify">Para demonstrar isso, vamos criar uma função chamadaque vai procurar dentro dos metadados do valor a chaveque adicionamos no exemplo anterior.</p>
<p class="text-justify">Como relembrar é viver, e ficar voltando página no livro é muito chato, vamos criar novamente a lista com a respectiva descrição.</p>
<p class="text-justify">Vamos juntar as partes.</p>
<p class="text-justify">Nesse caso,. Como o valor foi passado por parâmetro, o metadado foi junto.</p>
<p class="text-justify">Quando atribuimos o metadado em, o valor ainda não foi criado. Fica óbvio se você pensar que o valor só existirá quando a aplicação estiver sendo executada, ou seja, em.</p>
<p class="text-justify">Como o valor ainda não foi criado, o metadado é atribuido aoque vai armazená-lo. Lembre-se que oé criado em tempo de compilação.</p>
<p class="text-justify">Quando tentamos acessar os metadados de, estamos acessando o valor contido no, que é uma função. Esse valor, de fato, não tem metadado nenhum, e é onde recebemoscomo resposta.</p>
<p class="text-justify">Se quisermos acessar diretamente o, ao invés de acessarmos a função, precisamos utilizar a forma especial, que funciona de forma bem parecida com a funçãoque já conhecemos.</p>
<p class="text-justify">A formanos retornou o nome completo da função, incluindo oem que a função foi declarada.</p>
<p class="text-justify">Perceba que o retorno contém também os caracteresantes do nome completo da função. Esses dois caracteres são, ou atalhos da linguagem que são executados em tempo de compilação. Internamente avai ser substituido pore executado durante a compilação do código.</p>
<p class="text-justify">Usando a nossa recém apresentada forma, vamos tentar acessar novamente os metadados de.</p>
<p class="text-justify">Veja que agora conseguimos acessar os metadados de, que estão associados ao, e não ao corpo da função propriamente dita. Sendo assim, se passarmoscomo parâmetro para uma função, os metadados não irão junto.</p>
<p class="text-justify">Agora sim conseguimos extrair a documentação de.</p>
<p class="text-justify">Lembra quando foi dito quesão executadas eme funções são executadas em? Poissão tipos especias de macros e, como tal, são executadas durante a compilação.</p>
<p class="text-justify">Estou repetindo isso para poder deixar claro dois conceitos importantes aqui, antes de irmos para o próximo passo. Saber diferenciar quando seu código será executado em tempo de compilação ou de execução é importante. Saber que existemtambém vai tornar o conceito mais fácil de entender.</p>
<p class="text-justify">Assim como existe umque nos permite acessar diretamente um, também existe um que adiciona metadados em tempo de compilação.</p>
<p class="text-justify">O nossoda vez é o, que vai conter o mapa de metadados na declaração do.</p>
<p class="text-justify">Note que ao utilizar, os metadados foram informados antes do nome do.</p>
<p class="text-justify">Agora os metadados estão associados aoao invés do valor. Perceba que o próprio Clojure adiciona metadados que são utilizados para indicar onde ocorreu um erro ou por ferramentas de análise de código.</p>
<p class="text-justify">Se olharmos novamente os metadados de, veremos duas informações interessantes:e.</p>
<p class="text-justify">De acordo com os metadados, o código fonte da funçãoestá no arquivoe começa na linha.</p>
<p class="text-justify">Ao acessarmos http://git.io/rGpXXw, que vai nos direcionar para o código fonte da biblioteca padrão do Clojure, veremos que, a partir da linhado arquivotemos a função.</p>
<p class="text-justify">Note que é exatamente o mesmo conteúdo que teríamos ao usar, já que é assim que a macro faz para encontrar o código fonte.</p>
<p class="text-justify">Caso você esteja usando uma versão do Clojure diferente da versão do livro, o número da linha pode variar. Basta localizar os fontes da versão que você estiver usando e você vai ver o mesmo resultado.</p>
<p class="text-justify">E o que acontece se informarmos os metadados após o nome do?</p>
<p class="text-justify">Nada. Até a versão utilizada nesse livro, os metadados são simplesmente ignorados. Então, se você tentar adicionar metadados a ume nada acontecer, verifique se você não inverteu a ordem.</p>
<p class="text-justify">É possível também alterar os metadados já existentes. Isso pode ser útil caso você desenvolva alguma ferramenta de análise de código, por exemplo. Você poderia marcar os dados já observados com um metadado específico.</p>
<p class="text-justify">Vamos alterar uma função da biblioteca padrão do Clojure, por exemplo.</p>
<p class="text-justify">Para usarmos a funçãoprecisamos informar oa ser alterado e uma função que vai alterar oque contém os metadados. Entãoretorna os metadados alterados.</p>
<p class="text-justify">Já para desfazer uma modificação nos metadados ou mesmo para limpar qualquer metadado existe, devemos usar a função, que recebe como argumentos oa ser modificado e umcontendo os valores pelos quais você vai substituir o mapa de metadados atual.</p>
<p class="text-justify">Vamos alterar os metadados deno nosso exemplo.</p>
<p class="text-justify">Nenhuma função ou estrutura de dados fica solta no Clojure. Toda vez que você cria um, uma função ou uma estrutura de dados global, ou referencia uma biblioteca ou pacote externo, você tem que lidar com. E é isso que veremos em detalhes no próximo capítulo.</p>
</page>
</template>
<script>export default { name: 'CHANGEME' }</script>