["document",["chapter",["text"," Calculando o infinito com lazy sequences"]],["paragraph",["br"]],["quote",["text","\"The more you approach infinity, the deeper you penetrate terror\""],["text","  -- Gustave Flaubert, escritor francês"]],["paragraph",["br"]],["section",["text","Eager e lazy evaluation"]],["paragraph",["br"]],["paragraph",["text","Existem situações em que você precisará processar uma quantidade absurdamente grande de dados, ou então algum conjuntos de dados em que você simplesmente não sabe quando termina e nem mesmo se termina."],["br"]],["paragraph",["text","Por mais que pareça absurdo pensarmos em trabalhar com uma quantidade infinita de informação, a memória disponível para executarmos um software é limitada, e bem limitada."],["br"]],["paragraph",["text","Se você precisar processar um arquivo de log de 10GB, é bem possível que você não consiga carregá-lo todo em memória para então começar a trabalhar. Se os dados estão chegando pela rede, talvez vindos de uma comunicação entre aplicações, é possível também que a conexão dure dias ou meses sem interrupção. Esperar para carregar todos os dados na memória para então começar a trabalhar não faria o menor sentido."],["br"]],["paragraph",["text","Quando trabalhamos com vetores ou listas, todos os dados estão disponíveis em memória desde o início, o que limita bastante a quantidade de itens que podemos processar."],["br"]],["index",["text","range"]],["paragraph",["br"]],["paragraph",["text","Vamos começar com um exemplo absurdo e, usando a função "],["monospaced",["text","range"]],["text",", vamos tentar jogar uma lista infinita de números para dentro de um vetor."],["br"]],["index",["text","into"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(into [] (range))"],["br"],["code-text","; OutOfMemoryError Java heap space"],["br"],["code-text",";   um monte de linhas"],["br"],["code-text",";     clojure.core/seq (core.clj:133)"],["br"],["code-text",";     clojure.core/take-while/fn--4274 (core.clj:2636)"],["br"],["code-text","; Bye for now!"],["br"]],["paragraph",["br"]],["img",["text","images/capitulo_07/cpu.png label=cap07-cpu \"Muita memória e muito calor por nada\" w=60%"]],["paragraph",["br"]],["paragraph",["text","A função "],["monospaced",["text","range"]],["text"," sem parâmetros nos retorna uma lista de números que começa em zero e vai, teoricamente, até o infinito. É claro que uma hora ou outra vamos esbarrar nas limitações de memória da plataforma, mas isso não precisa acontecer tão depressa."],["br"]],["box",["text","Protegendo os próprios pés"],["paragraph",["br"]],["paragraph",["text","Trabalhar com sequencias infinitas ou muito grandes no "],["italic",["text","REPL"]],["text"," pode ser perigoso, uma vez que ele tentará exibir todos os itens na tela antes de retornar o comando para você."],["br"]],["paragraph",["text","Experimente executar o código abaixo para entender o que estou dizendo. Enquanto isso vou ali montar um quebra-cabeças de cinco mil peças e já volto."],["br"]],["code","clojure",["br"],["code-text","(range)"],["br"]],["paragraph",["br"]],["index",["text","*print-length*"]],["paragraph",["br"]],["paragraph",["text","Para evitar que acidentalmente tenhamos que esperar uma vida inteira até que a memória acabe ou alcancemos um "],["italic",["text","overflow"]],["text"," numérico, vamos dizer ao "],["italic",["text","REPL"]],["text"," que ele deve limitar a quantidade de informação exibida na tela. Para isso, vamos alterar um estado global chamado "],["monospaced",["text","*print-length*"]],["text",", que contém a quantidade de itens a serem exibidos."],["br"]],["code","clojure",["br"],["code-text","(set! *print-length* 100)"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos \"acidentalmente\" gerar uma sequencia infinita para ver como o "],["italic",["text","REPL"]],["text"," se comporta."],["br"]],["code","clojure",["br"],["code-text","(range)"],["br"],["code-text","; (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 "],["br"],["code-text","; ... mais um monte de números"],["br"],["code-text","; 95 96 97 98 99 ...)"],["br"]],["paragraph",["br"]],["paragraph",["text","Ufa, parou no centésimo item. Vamos prosseguir em segurança. As reticências indicam que existem mais itens depois daquele ponto."],["br"]]],["paragraph",["br"]],["paragraph",["text","Já a função "],["monospaced",["text","into"]],["text"," joga essa lista para dentro de um vetor vazio, que representamos com "],["monospaced",["text","▷ ◁"]],["text","."],["br"]],["paragraph",["text","Um vetor usa de "],["italic",["text","eager evaluation"]],["text",", ou como já dissemos, precisa estar com todos os dados na memória para que possamos usá-lo. "],["italic",["text","Eager"]],["text"," pode ser traduzido como "],["italic",["text","apressado"]],["text",", "],["italic",["text","afobado"]],["text","."],["br"]],["paragraph",["text","Felizmente, o Clojure tem um recurso chamado "],["italic",["text","lazy evaluation"]],["text",", onde só um pedaço da lista fica em memória para que possamos trabalhar, deixando para carregar o restante apenas quando for necessário. Já "],["italic",["text","lazy"]],["text"," significa "],["italic",["text","preguiçoso"]],["text",", o que não é algo negativo nesse contexto"],["ref",["text","lazy-dev"]],["text","."],["br"]],["paragraph",["text","Vamos usar o mesmo exemplo da lista infinita como exemplo."],["br"]],["code","clojure",["br"],["code-text","(def infinito (range))"],["br"],["code-text","(take 10 infinito)"],["br"],["code-text","; (0 1 2 3 4 5 6 7 8 9)"],["br"]],["paragraph",["br"]],["paragraph",["text","A função "],["monospaced",["text","range"]],["text"," retorna um tipo especial de lista chamada "],["italic",["text","lazy sequence"]],["text",". Os dados de uma "],["italic",["text","lazy sequence"]],["text"," não são computados até que alguém peça. É por isso que pudemos jogar o resultado de "],["monospaced",["text","(range)"]],["text"," em "],["monospaced",["text","infinito"]],["text"," sem que a máquina fique travada ou a memória acabe."],["br"]],["box",["text","O jeito Clojure"],["paragraph",["br"]],["paragraph",["italic",["text","Lazy sequences"]],["text"," são parte central do "],["italic",["text","jeito Clojure"]],["text"," de resolver problemas. Muitos problemas que podem ser resolvidos com recursão também podem ser resolvidos de forma "],["italic",["text","lazy"]],["text",", geralmente de forma mais rápida e elegante."],["br"]],["paragraph",["text","Pensar em soluções que façam uso de "],["italic",["text","lazy evaluation"]],["text"," leva algum tempo e exige treino mas, uma vez que você quebre essa barreira, os resultados são recompensadores."],["br"]]],["paragraph",["br"]],["index",["text","take"]],["paragraph",["br"]],["paragraph",["text","Na linha seguinte pedimos os dez primeiros itens de "],["monospaced",["text","infinito"]],["text"," através da função "],["monospaced",["text","take"]],["text",". Como resultado temos uma nova lista com dez números, gastando uma quantidade aceitável de memória e de processamento."],["br"]],["paragraph",["text","Boa parte das funções biblioteca padrão do Clojure que manipulam sequencias as tratam como "],["italic",["text","lazy"]],["text",". Isso significa que não precisamos aprender todo um novo conjunto de instruções para aproveitarmos as vantagens das "],["italic",["text","lazy sequences"]],["text","."],["br"]],["index",["text","map"]],["index",["text","filter"]],["index",["text","reduce"]],["paragraph",["br"]],["paragraph",["text","As nossas já conhecidas funções "],["monospaced",["text","map"]],["text"," e "],["monospaced",["text","filter"]],["text"," devolvem "],["italic",["text","lazy sequences"]],["text",", mesmo quando você passa um vetor para elas. Já a função "],["monospaced",["text","reduce"]],["text"," força a avaliação das sequências e nos retorna um valor escalar ao invés de uma "],["italic",["text","lazy sequence"]],["text","."],["br"]],["paragraph",["text","Vamos calcular a soma de todos os números pares, múltiplos de "],["italic",["text","3"]],["text",", entre "],["italic",["text","0"]],["text"," e "],["italic",["text","1000"]],["text",", inclusive. Porém, vamos usar um passo a mais no nosso processamento simplesmente porque eu quero usar essas três funções. Se fosse um código de verdade, eu usaria o mínimo de processamento possível, mas a ideia aqui é quebrar o problema em partes pequenas para que fique fácil de entender e explicar."],["br"]],["paragraph",["text","Primeiro vamos pegar uma lista de números entre "],["italic",["text","0"]],["text"," e "],["italic",["text","500"]],["text",", inclusive."],["br"]],["code","clojure",["br"],["code-text","(def lista-inicial (range 0 501))"],["br"]],["paragraph",["br"]],["paragraph",["text","Em seguida vamos multiplicar todos os itens da lista por dois, para termos todos os números pares entre "],["italic",["text","0"]],["text"," e "],["italic",["text","1000"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def lista-pares (map #(* 2 %) lista-inicial))"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos filtrar a lista para ficarmos apenas com os números que forem múltiplos de "],["italic",["text","3"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def lista-multiplos (filter #(= 0 (mod % 3)) lista-pares))"],["br"]],["paragraph",["br"]],["paragraph",["text","Até aqui nós criamos três "],["italic",["text","lazy sequences"]],["text",": uma quando usamos "],["monospaced",["text","range"]],["text",", outra quando usamos "],["monospaced",["text","map"]],["text"," e a terceira quando utilizamos "],["monospaced",["text","filter"]],["text",". Mas ainda assim não recebemos retorno nenhum."],["br"]],["paragraph",["text","Isso acontece simplesmente porque as "],["italic",["text","lazy sequences"]],["text"," só vão nos retornar algum dado quando isso for realmente necessário. No nosso exemplo apenas criamos as sequencias e não as usamos em momento algum. Se nosso programa terminasse agora, nós não teriamos usado as sequencias para nada. Como elas não são tontas, preferiram ficar quietinhas sem gastar memória nem processamento."],["br"]],["paragraph",["text","Agora, ao usarmos "],["monospaced",["text","reduce"]],["text",", cada um dos itens da lista vai ser solicitado, multiplicado, filtrado e então somado. No final de tudo teremos o resultado que procuramos."],["br"]],["code","clojure",["br"],["code-text","(def resultado (reduce + lista-multiplos))"],["br"],["code-text","resultado"],["br"],["code-text","; 83166"],["br"]],["paragraph",["br"]],["paragraph",["text","Perceba que o resultado só veio quando mandamos exibir o valor de "],["monospaced",["text","resultado"]],["text",". quando simplesmente atribuimos a expressão com "],["monospaced",["text","reduce"]],["text"," em "],["monospaced",["text","resultado"]],["text",", o processo continuou quietinho até que fosse necessário retornar um valor."],["br"]],["index",["text","->>"]],["paragraph",["br"]],["paragraph",["text","Podemos reescrever o nosso código usando o operador "],["monospaced",["text","->>"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def resultado (->> (range 0 501)"],["br"],["code-text","                    (map #(* 2 %))"],["br"],["code-text","                    (filter #(= 0 (mod % 3)))"],["br"],["code-text","                    (reduce +)))"],["br"],["code-text","; 83166"],["br"]],["paragraph",["br"]],["section",["text","Como uma lazy sequence funciona por dentro"]],["paragraph",["br"]],["paragraph",["text","Até aqui conseguimos ver o que faz a "],["italic",["text","lazy evaluation"]],["text",", mas estamos com algumas perguntas que estão sem respostas."],["br"]],["paragraph",["text","A primeira delas é "],["italic",["text","em que momento exatamente a sequencia é avaliada?"]],["text",". Depois eu perguntaria "],["italic",["text","mas não vou gastar mais processamento se eu tiver que avaliar de forma lazy a mesma sequencia duas vezes?"]],["text","."],["br"]],["paragraph",["text","Outra pergunta interessante é "],["italic",["text","como o Clojure sabe a hora de parar de calcular e trazer o resultado?"]],["text","."],["br"]],["paragraph",["text","E a pergunta mais importante de todas, e a que me atormentou por muito tempo: "],["italic",["text","como eu vou pensar de forma lazy se até agora isso tudo parece magia negra com o resultado automagicamente aparecendo para mim?"]],["text","."],["br"]],["paragraph",["text","Por isso é importante entendermos como uma "],["italic",["text","lazy sequence"]],["text"," funciona por dentro. É simples, rápido e relativamente indolor."],["br"]],["paragraph",["text","Antes de mais nada, devemos ter em mente que uma "],["italic",["text","lazy sequence"]],["text"," é uma lista ligada. Como em qualquer lista ligada, cada nó contém pelo menos duas propriedades, sendo a primeira contendo o valor do nó atual e o segundo contendo uma referência ao próximo nó. Um nó de uma "],["italic",["text","lazy sequence"]],["text"," contém ainda uma terceira propriedade, contendo uma função responsável por gerar o próximo item. Essa função é conhecida como "],["italic",["text","thunk"]],["ref",["text","thunk-paper"]],["text","."],["br"]],["todo",["text","desenhar diagrama"]],["paragraph",["br"]],["paragraph",["text","O uso de "],["italic",["text","thunk"]],["text"," já é nosso conhecido, apesar de não termos sidos apresentados a esse nome ainda. Quando aprendemos sobre "],["italic",["text","trampolines"]],["text",", no capítulo "],["ref-label",["text","capitulo-funcoes"]],["text",", vimos que as funções "],["italic",["text","trampoline"]],["text"," retornavam outra função ao invés de um valor qualquer. "],["br"]],["paragraph",["text","Essa outra função seria executada quando necessário, e também retornaria uma função. Dessa forma podemos fazer recursões mútuas sem consumir a pilha de chamadas da JVM."],["br"]],["paragraph",["text","Essa função que seria executada em outro momento é um "],["italic",["text","thunk"]],["text",", e o fato dela ser executada apenas quando necessário, e não imediatamente, foi nosso primeiro contato com "],["italic",["text","lazy loading"]],["text","."],["br"]],["paragraph",["text","Uma vez que o "],["italic",["text","thunk"]],["text"," é executado, o nó passa a ter um valor e outro nó é criado, com seu respectivo "],["italic",["text","thunk"]],["text"," e ainda sem um valor. Se você precisar acessar um nó que já foi avaliado, receberá imediatamente seu valor, sem a necessidade de um novo processamento."],["br"]],["paragraph",["text","Vamos ver isso funcionando na prática, passo a passo."],["br"]],["paragraph",["text","Primeiro, vamos criar uma sequencia chamada "],["monospaced",["text","lista"]],["text"," usando a nossa conhecida função "],["monospaced",["text","range"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def lista (range 1 101))"],["br"]],["paragraph",["br"]],["paragraph",["text","Em seguida, vamos criar outra sequencia chamada "],["monospaced",["text","multiplo-3"]],["text"," usando "],["monospaced",["text","map"]],["text",", com uma função que vai multiplicar cada item por "],["italic",["text","3"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def multiplo-3   (map #(do (print \"m\" % \" - \")"],["br"],["code-text","                            (* % 3))"],["br"],["code-text","                       lista))"],["br"]],["paragraph",["br"]],["paragraph",["text","O pulo do gato aqui está no fato da função usada para mapear causar efeitos colaterais, nos permitindo entender exatamente o que está acontecendo, passo a passo. Nossa função vai imprimir a letra "],["monospaced",["text","m"]],["text",", de "],["bold",["text","m"]],["text","apa, antes do número que está sendo processado."],["br"]],["paragraph",["text","Isso vai nos ajudar também a entender porque não devemos usar funções com efeitos colaterais para processar "],["italic",["text","lazy sequencies"]],["text","."],["br"]],["paragraph",["text","A mesma coisa acontece com a sequencia "],["monospaced",["text","pares"]],["text"," que vamos criar com a função "],["monospaced",["text","filter"]],["text",". Vamos imprimir um "],["monospaced",["text","f"]],["text",", de "],["bold",["text","f"]],["text","iltro, antes do número que está sendo filtrado. Nosso filtro vai manter apenas os números pares."],["br"]],["code","clojure",["br"],["code-text","(def pares (filter #(do (print \"f\" % \" - \")"],["br"],["code-text","                        (even? %))"],["br"],["code-text","                   mapped))"],["br"]],["paragraph",["br"]],["paragraph",["text","Antes de continuarmos, atenção para o fato de que tanto "],["monospaced",["text","multiplo-3"]],["text"," quanto "],["monospaced",["text","pares"]],["text"," já são "],["italic",["text","lazy sequences"]],["text","."],["br"]],["paragraph",["text","Nenhum resultado foi impresso ao criarmos essas três sequencias exatamente porque são "],["italic",["text","lazy"]],["text"," e não mandamos que elas fossem avaliadas ainda."],["br"]],["paragraph",["text","Vamos mandar avaliar as sequencias pedindo para recebermos apenas o primeiro item da sequencia."],["br"]],["code","clojure",["br"],["code-text","(first pares)"],["br"],["code-text","; m 1  - m 2  - m 3  - m 4  - m 5  - m 6  - m 7  - m 8  - m 9  -"],["br"],["code-text","; m 10  - m 11  - m 12  - m 13  - m 14  - m 15  - m 16  - m 17 -"],["br"],["code-text","; m 18  - m 19  - m 20  - m 21  - m 22  - m 23  - m 24  - m 25 -"],["br"],["code-text","; m 26  - m 27  - m 28  - m 29  - m 30  - m 31  - m 32  - f 3  -"],["br"],["code-text","; f 6  - f 9  - f 12  - f 15  - f 18  - f 21  - f 24  - f 27  - "],["br"],["code-text","; f 30  - f 33  - f 36  - f 39  - f 42  - f 45  - f 48  - f 51 -"],["br"],["code-text","; f 54  - f 57  - f 60  - f 63  - f 66  - f 69  - f 72  - f 75 -"],["br"],["code-text","; f 78  - f 81  - f 84  - f 87  - f 90  - f 93  - f 96  - 6"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos analizar o que foi impresso para entendermos como a "],["italic",["text","lazy sequence"]],["text"," funciona por dentro."],["br"]],["paragraph",["text","Primeiro, vamos olhar os números precedidos da letra m, que foram processados pelo map. Nossa sequencia original vai de 1 a 100, mas a função "],["monospaced",["text","map"]],["text"," recebeu apenas os números de 1 a 32. "],["br"]],["paragraph",["text","O número mágico "],["italic",["text","32"]],["text"," é o tamanho padrão de um "],["italic",["text","chunk"]],["text"," (não confunda com "],["italic",["text","thunk"]],["text",", já que cientistas da computação não têm a menor criatividade para nomes), que é um pedaço da sequencia que é pré-processada e armazenada em memória. Segundo o criador da linguagem, dessa forma você gasta o processamento uma única vez nesse pedaço de sequência e ganha em velocidade no resto dela, além de reduzir do trabalho do "],["italic",["text","garbage collector"]],["text"," do Java em sequencias com muitos itens. "],["br"]],["paragraph",["text","Lá na versão 1.1 do Clojure (estamos na versão 1.7), uma "],["italic",["text","lazy sequence"]],["text"," era processada item a item. Na versão seguinte ela passou a ser chamada também de 'chunked sequence' por conta desse bloco de dados processados de uma única vez."],["br"]],["paragraph",["text","Então nós temos em memória uma sequencia pré-processada com números de "],["italic",["text","1"]],["text"," a "],["italic",["text","32"]],["text"," multiplicados por "],["italic",["text","3"]],["text",". É aí que encontramos a continuação do processamento, dessa vez iniciando com a letra "],["monospaced",["text","f"]],["text",". Na tela temos "],["monospaced",["text","f 3"]],["text",", "],["monospaced",["text","f 6"]],["text",", "],["monospaced",["text","f 9"]],["text"," e assim por diante."],["br"]],["paragraph",["text","Aqui também são processados blocos de "],["italic",["text","32"]],["text"," itens de cada vez. Como a função "],["monospaced",["text","map"]],["text"," não modifica o tamanho da lista que é processada, não vemos acontecer nada de especial aqui, já que "],["monospaced",["text","filter"]],["text"," também acaba processando uma lista com "],["italic",["text","32"]],["text"," itens."],["br"]],["paragraph",["text","Finalmente, o último item da lista impressa na tela é o número "],["italic",["text","6"]],["text",", que é o retorno do processamento, já que é o primeiro número par múltiplo de "],["italic",["text","3"]],["text","."],["br"]],["paragraph",["text","Vamos ver agora o que acontece se quisermos receber novamente o primeiro item da lista, repetindo a instrução anterior:"],["br"]],["code","clojure",["br"],["code-text","(first pares)"],["br"],["code-text","; 6"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora recebemos apenas o valor "],["italic",["text","6"]],["text",", sem nenhum processamento por baixo dos panos. Como eu já havia dito, temos um pedaço da sequencia contendo os valores já processados, o que nos faz ganhar algum tempo já que não precisamos calcular novamente o valor. O valor do primeiro item foi "],["italic",["text","memoizado"]],["text",", sendo o processamento substituido pelo seu resultado."],["br"]],["paragraph",["text","Caso você use uma função que cause efeitos colaterais, como é o nosso caso, teremos a execução da função apenas na primeira vez, como já vimos acontecer ao estudarmos "],["italic",["text","memoização"]],["text",". Se você depende da execução da função toda vez que processar a lista, então "],["italic",["text","lazy sequence"]],["text"," não é o recurso mais adequado para a situação."],["br"]],["paragraph",["text","Vamos ver agora qual é o segundo item da sequencia. Para isso vamos criar uma nova sequencia contendo o resto da sequencia, ou seja, a sequencia sem o primeiro item. Em seguida vamos pegar o primeiro item dessa nova sequencia."],["br"]],["code","clojure",["br"],["code-text","(def resto (rest pares))"],["br"],["code-text","(first resto)"],["br"],["code-text","; 12"],["br"]],["paragraph",["br"]],["index",["text","rest"]],["index",["text","first"]],["paragraph",["br"]],["paragraph",["text","Aqui também nada foi processado ao criarmos a nova sequencia, já que "],["monospaced",["text","rest"]],["text"," também retorna uma "],["italic",["text","lazy sequence"]],["text",". Quando utilizamos "],["monospaced",["text","first"]],["text"," para pegar o primeiro item dessa nova sequencia novamente não houve processamento, já que temos até o número "],["italic",["text","96"]],["text"," guardado em memória."],["br"]],["paragraph",["text","E o que acontece se quisermos o que estiver do número 96 em diante?"],["br"]],["paragraph",["text","Nesse caso o Clojure vai processar mais 32 itens e armazená-los em memória, até que a sequencia original, que no nosso caso terá até "],["italic",["text","100"]],["text"," itens, se esgote."],["br"]],["paragraph",["text","Vamos forçar o processamento para além do número 96 para vermos o que acontece:"],["br"]],["code","clojure",["br"],["code-text","(take 32 pares)"],["br"],["code-text","; (6 12 18 24 30 36 42 48 54 60 66 72 78 84 90 m 33  - m 34  -"],["br"],["code-text","; m 35  - m 36  - m 37  - m 38  - m 39  - m 40  - m 41  - m 42 -"],["br"],["code-text","; m 43  - m 44  - m 45  - m 46  - m 47  - m 48  - m 49  - m 50 - "],["br"],["code-text","; m 51  - m 52  - m 53  - m 54  - m 55  - m 56  - m 57  - m 58 -"],["br"],["code-text","; m 59  - m 60  - m 61  - m 62  - m 63  - m 64  - f 99  - f 102 -"],["br"],["code-text","; f 105  - f 108  - f 111  - f 114  - f 117  - f 120  - f 123  - "],["br"],["code-text","; f 126  - f 129  - f 132  - f 135  - f 138  - f 141  - f 144  - "],["br"],["code-text","; f 147  - f 150  - f 153  - f 156  - f 159  - f 162  - f 165  -"],["br"],["code-text","; f 168  - f 171  - f 174  - f 177  - f 180  - f 183  - f 186  - "],["br"],["code-text","; f 189  - f 192  - 96 102 108 114 120 126 132 138 144 150 156 "],["br"],["code-text","; 162 168 174 180 186 192)"],["br"]],["paragraph",["br"]],["paragraph",["text","Analisando novamente o que foi impresso, vemos que os números pares e múltiplos de 3 entre 6 e 90 já estavam em memória. Quando pedimos o número seguinte, a função map processou o "],["italic",["text","chunk"]],["text"," seguinte da nossa lista original, que contém os números de 33 a 64, que foram multiplicados por 3 e então filtrados, sendo armazenados somente os números pares."],["br"]],["paragraph",["text","Se repetirmos a instrução, veremos que o processamento não ocorre novamente:"],["br"]],["code","clojure",["br"],["code-text","(take 32 pares)"],["br"],["code-text","; (6 12 18 24 30 36 42 48 54 60 66 72 78 84 90 96 102 108 114"],["br"],["code-text","; 120 126 132 138 144 150 156 162 168 174 180 186 192)"],["br"]],["paragraph",["br"]],["paragraph",["text","Os valores foram memoizados, e por conta disso as funções passadas por parâmetro para "],["monospaced",["text","map"]],["text"," e "],["monospaced",["text","filter"]],["text"," não foram executadas novamente."],["br"]],["paragraph",["text","No nosso exemplo, o Clojure vai pegar os "],["italic",["text","32"]],["text"," primeiros números de "],["monospaced",["text","lista"]],["text",", no segundo passo serão utilizados os números de "],["italic",["text","33"]],["text"," a "],["italic",["text","64"]],["text",", depois de "],["italic",["text","65"]],["text"," a "],["italic",["text","96"]],["text"," e, como nossa lista tinha "],["italic",["text","100"]],["text"," números, o último passo vai processar o que houver entre "],["italic",["text","97"]],["text"," e "],["italic",["text","100"]],["text",". É assim que o Clojure sabe a hora de parar."],["br"]],["paragraph",["text","Caso estivessemos lidando com uma lista infinita, o processamento só pararia ao matarmos o processo da aplicação ou ao encontrarmos um número grande o bastante para que o Clojure não consiga armazená-lo."],["br"]],["section",["text","Perdendo a cabeça"]],["paragraph",["br"]],["paragraph",["text","O nosso exemplo funciona muito bem com sequencias que caibam na memória, mas com uma sequência muito grande nós teríamos o mesmo problema de quando tentamos jogar uma sequencia infinita para dentro de um vetor."],["br"]],["paragraph",["text","Vamos escrever um código que conte a quantidade de itens múltiplos de "],["italic",["text","33"]],["text"," e "],["italic",["text","17"]],["text"," existentes entre "],["italic",["text","1"]],["text"," e "],["monospaced",["text","330.000.000.000"]],["text",", o que deve dar um número bem grande."],["br"]],["code","clojure",["br"],["code-text","(def lista-inteira (->> (range 1 1e10)"],["br"],["code-text","                        (map #(* % 33))"],["br"],["code-text","                        (filter #(= 0 (mod % 17)))))"],["br"],["code-text","(count lista-inteira)"],["br"],["code-text","; OutOfMemoryError GC overhead limit exceeded  "],["br"],["code-text","; java.lang.Long.valueOf (:-1)"],["br"]],["paragraph",["br"]],["paragraph",["text","O "],["italic",["text","garbage collector"]],["text"," do Java bem que tentou, mas mesmo com o poder das "],["italic",["text","lazy sequences"]],["text"," tivemos um estouro de memória."],["br"]],["img",["text","images/capitulo_07/memory_1.png label=cap07-memory-1 \"Consumo de memória da nossa contagem de itens\" w=40%"]],["paragraph",["br"]],["paragraph",["text","Existe uma forma de lidar com isso, e é onde "],["italic",["text","lazy evaluation"]],["text"," mostra a que veio."],["br"]],["paragraph",["text","Sabemos que, quando criamos uma sequencia gigantesca, que estamos chamando de infinita apenas para fins didáticos, apenas "],["italic",["text","32"]],["text"," itens são gerados de cada vez. Se usarmos os itens conforme eles forem aparecendo e em seguida descartarmos, teremos um consumo baixo e constante de memória, independente da quantidade de itens que forem processados."],["br"]],["index",["text","InputStream"]],["index",["text","OutputStream"]],["paragraph",["br"]],["paragraph",["text","Quando lemos uma sequencia do começo para o fim, sem voltar atrás na leitura e descartando o que já foi trabalhado, dizemos que temos um "],["italic",["text","stream"]],["text",". Se você acompanhou as novidades do Java 8, ou mesmo já trabalhou com os consagrados "],["monospaced",["text","InputStream"]],["text"," e "],["monospaced",["text","OutputStream"]],["text"," do Java, você já fez isso mesmo sem perceber."],["br"]],["paragraph",["text","Vamos criar uma função chamada "],["monospaced",["text","count-melhor"]],["text",", que conta os itens da sequencia e os descarta em seguida."],["br"]],["paragraph",["text","Como fazemos para descartar um item? Basta não ter ninguém olhando para ele que o próprio "],["italic",["text","garbage collector"]],["text"," da JVM faz o resto. Simples assim."],["br"]],["paragraph",["text","Vamos criar uma versão usando recursão. Sabemos que "],["italic",["text","tail call recursion"]],["text"," não consome a pilha de execução, então podemos lidar com sequencias realmente grandes sem medo de derrubarmos a aplicação."],["br"]],["code","clojure",["br"],["code-text","(defn count-melhor [lista]    ; 1"],["br"],["code-text","  (loop [lista lista          ; 2"],["br"],["code-text","         items 0]             ; 3"],["br"],["code-text","    (if (empty? lista)        ; 4"],["br"],["code-text","      items                   ; 5"],["br"],["code-text","      (recur (rest lista)     ; 6"],["br"],["code-text","             (inc items)))))  ; 7"],["br"]],["paragraph",["br"]],["paragraph",["text","Basicamente a função recebe uma sequencia como parâmetro e avança item a item adicionando "],["italic",["text","1"]],["text"," em "],["monospaced",["text","items"]],["text",". Se a sequencia estiver vazia, o processo para e recebemos a quantidade de itens que foram contados."],["br"]],["paragraph",["text","Trabalhando dessa forma estamos descartando o primeiro item da sequencia a cada iteração, enquanto a própria "],["italic",["text","lazy sequence"]],["text"," se encarrega de só gerar o "],["italic",["text","chunk"]],["text"," seguinte quando for necessário. No pior caso, teremos "],["italic",["text","32"]],["text"," itens da sequencia em memória, ao invés de milhões deles."],["br"]],["paragraph",["text","Vamos comparar o funcionamento da nossa função com a "],["monospaced",["text","count"]],["text"," padrão do Clojure para ver se está tudo de acordo com o planejado."],["br"]],["code","clojure",["br"],["code-text","(count '())"],["br"],["code-text","; 0"],["br"],["code-text","(count-melhor '())"],["br"],["code-text","; 0"],["br"],["code-text","(count (range 1 11))"],["br"],["code-text","; 10"],["br"],["code-text","(count-melhor (range 1 11))"],["br"],["code-text","; 10"],["br"]],["paragraph",["br"]],["paragraph",["text","Tudo em conformidade, vamos ao teste final. Apenas como um alerta, esse processo vai demorar muito, então deixe o computador de lado um pouco e vá correr uma maratona."],["br"]],["code","clojure",["br"],["code-text","(def lista-inteira (->> (range 1 1e10)"],["br"],["code-text","                        (map #(* % 33))"],["br"],["code-text","                        (filter #(= 0 (mod % 17)))))"],["br"],["code-text","(count-melhor lista-inteira)"],["br"],["code-text","; OutOfMemoryError GC overhead limit exceeded"],["br"]],["paragraph",["br"]],["paragraph",["text","Opa, continuamos com o mesmo erro, mesmo tendo alterado a abordagem. Hora de usarmos o que aprendemos até aqui para descobrir a causa do problema."],["br"]],["index",["text","pst"]],["paragraph",["br"]],["paragraph",["text","Primeiro, vamos executar a função "],["monospaced",["text","pst"]],["text"," para analisarmos a pilha de chamadas no momento do erro e vermos onde exatamente ocorreu o problema."],["br"]],["code","clojure",["br"],["code-text","java.lang.OutOfMemoryError: GC overhead limit exceeded"],["br"],["code-text","  (Unknown Source) java.lang.Long.valueOf"],["br"],["code-text"," Numbers.java:1661 clojure.lang.Numbers.num"],["br"],["code-text","  Numbers.java:447 clojure.lang.Numbers$LongOps.add"],["br"],["code-text","  Numbers.java:126 clojure.lang.Numbers.add"],["br"],["code-text","     core.clj:2746 clojure.core/range[fn]"],["br"],["code-text","   LazySeq.java:40 clojure.lang.LazySeq.sval"],["br"],["code-text","   LazySeq.java:49 clojure.lang.LazySeq.seq"],["br"],["code-text","       RT.java:484 clojure.lang.RT.seq"],["br"],["code-text","      core.clj:133 clojure.core/seq"],["br"],["code-text","     core.clj:2551 clojure.core/map[fn]"],["br"],["code-text","   LazySeq.java:40 clojure.lang.LazySeq.sval"],["br"],["code-text","   LazySeq.java:49 clojure.lang.LazySeq.seq"],["br"],["code-text","       RT.java:484 clojure.lang.RT.seq"],["br"],["code-text","      core.clj:133 clojure.core/seq"],["br"],["code-text","     core.clj:2595 clojure.core/filter[fn]"],["br"],["code-text","   LazySeq.java:40 clojure.lang.LazySeq.sval"],["br"],["code-text","   LazySeq.java:49 clojure.lang.LazySeq.seq"],["br"],["code-text","       RT.java:484 clojure.lang.RT.seq"],["br"],["code-text","      core.clj:133 clojure.core/seq"],["br"],["code-text","     core.clj:5706 clojure.core/empty?"],["br"],["code-text","  NO_SOURCE_FILE:4 user/count-melhor"],["br"]],["paragraph",["br"]],["index",["text","empty?"]],["paragraph",["br"]],["paragraph",["text","Começando sempre de baixo para cima, temos a chamada à função "],["monospaced",["text","count-melhor"]],["text",", e em seguida temos a chamada a "],["monospaced",["text","empty?"]],["text","."],["br"]],["index",["text","count"]],["paragraph",["br"]],["paragraph",["text","A primeira coisa que podemos pensar ao ver que o problema começa com "],["monospaced",["text","empty?"]],["text"," é que essa função força a avaliação da sequencia inteira. Afinal de contas, poderíamos dizer que um coleção é vazia se "],["monospaced",["text","count"]],["text"," for igual a zero, concorda? Sabendo que usar o "],["monospaced",["text","count"]],["text"," padrão não está dando certo, vamos investigar o motivo olhando o código fonte de "],["monospaced",["text","empty?"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(source empty?)"],["br"],["code-text",";; removidos os metadados e a documentação"],["br"],["code-text","; (defn empty? [coll]"],["br"],["code-text",";    (not (seq coll)))"],["br"]],["paragraph",["br"]],["index",["text","nil"]],["paragraph",["br"]],["paragraph",["text","Não há nenhuma ocorrência de "],["monospaced",["text","count"]],["text"," dentro de "],["monospaced",["text","empty"]],["text",". Ao passarmos uma sequencia vazia para "],["monospaced",["text","seq"]],["text",", temos de volta "],["monospaced",["text","nil"]],["text",". Usando "],["italic",["text","nil punning"]],["text"," com o operador "],["monospaced",["text","not"]],["text"," temos uma forma elegante de saber se a sequencia está vazia ou não."],["br"]],["index",["text","seq"]],["paragraph",["br"]],["paragraph",["text","A única coisa que podemos sublinhar aqui é que "],["monospaced",["text","seq"]],["text"," força a avaliação do primeiro item da sequencia, assim como acontece com "],["monospaced",["text","first"]],["text",", o que não causaria um estouro de memória."],["br"]],["paragraph",["text","Tudo indica que o problema não está no uso de "],["monospaced",["text","empty?"]],["text","."],["br"]],["paragraph",["text","Olhando o código como um todo, incluindo a parte onde usamos "],["monospaced",["text","map"]],["text"," e "],["monospaced",["text","filter"]],["text",", vamos perceber que estamos guardando a coleção dentro de "],["monospaced",["text","lista-inteira"]],["text","."],["br"]],["paragraph",["text","Isso significa que "],["monospaced",["text","lista-inteira"]],["text"," está apontando para o início da sequencia. Por mais que nossa função "],["monospaced",["text","count-melhor"]],["text"," seja recheada de boas intenções, lembre-se que estamos lidando com uma "],["italic",["text","lazy sequence"]],["text",", que é uma estrutura persistente de dados."],["br"]],["paragraph",["text","Voltando um pouco no que aprendemos, lembre-se que uma estrutura persistente de dados é imutável e compartilha partes dos dados para que não seja necessário processar e copiar novamente dados que nunca serão alterados."],["br"]],["paragraph",["text","É uma estratégia bem inteligente se você não tiver nenhuma referência ao início da sequencia. Ao fazer isso, o "],["italic",["text","garbage collector"]],["text"," da JVM não vai fazer a limpeza por entender que alguém vai usar aqueles dados."],["br"]],["paragraph",["text","Voltando ao nosso código, o que acontece é que, enquanto nossa função "],["monospaced",["text","count-melhor"]],["text"," descarta o começo da sequencia a cada recursão, o "],["italic",["text","var"]],["text"," "],["monospaced",["text","lista-inteira"]],["text"," faz exatamente o que o nome diz, guardando em memória a lista inteira. Um joga água para fora do barco enquanto o outro faz um buraco maior no casco."],["br"]],["paragraph",["text","Guardar uma referência para o início da sequencia, em inglês "],["italic",["text","retain the head"]],["text",", é o erro mais comum que pode acontecer quando lidamos com "],["italic",["text","lazy sequences"]],["text","."],["br"]],["box",["text","Cabeça e rabo"],["paragraph",["br"]],["paragraph",["text","Uma sequencia pode ser dividida em duas partes distintas. A "],["italic",["text","cabeça"]],["text"," é formada pelo primeiro elemento, e o "],["italic",["text","rabo"]],["text"," contém todo o resto da sequencia."],["br"]],["paragraph",["text","Tanto que inglês é comum vermos os termos "],["italic",["text","head"]],["text"," e "],["italic",["text","tail"]],["text"," ao separarmos o primeiro item de uma sequencia do resto. "],["italic",["text","Head"]],["text"," e "],["italic",["text","tail"]],["text"," também são, respectivamente, os nomes em inglês da "],["italic",["text","cara"]],["text"," e da "],["italic",["text","coroa"]],["text"," de uma moeda."],["br"]]],["paragraph",["br"]],["paragraph",["text","A solução para isso costuma ser simples: livre-se de quem está apontando para o início da sequencia."],["br"]],["paragraph",["text","Sem mexer em uma linha de código da nossa função, vamos reescrever a nossa contagem."],["br"]],["code","clojure",["br"],["code-text",";; o código aqui continua o mesmo"],["br"],["code-text","(defn count-melhor [lista]    ; 1"],["br"],["code-text","  (loop [lista lista          ; 2"],["br"],["code-text","         items 0]             ; 3"],["br"],["code-text","    (if (empty? lista)        ; 4"],["br"],["code-text","      items                   ; 5"],["br"],["code-text","      (recur (rest lista)     ; 6"],["br"],["code-text","             (inc items)))))  ; 7"],["br"],["code-text",";; e aqui vamos guardar a contagem, e não a lista"],["br"],["code-text","(def contagem (->> (range 1 1e10)"],["br"],["code-text","                   (map #(* % 33))"],["br"],["code-text","                   (filter #(= 0 (mod % 17)))"],["br"],["code-text","                   count-melhor))"],["br"],["code-text","contagem"],["br"],["code-text","; 588235294"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora "],["monospaced",["text","count-melhor"]],["text"," recebe pedaços da sequencia gigante gerada por "],["monospaced",["text","range"]],["text"," e vai descartando o que já foi computado, mantendo o consumo de memória constante e não fazendo a aplicação cair por exaustão."],["br"]],["img",["text","images/capitulo_07/memory_2.png label=cap07-memory-1 \"Consumo constante de memória\" w=40%"]],["paragraph",["br"]],["paragraph",["text","No início do capítulo eu disse que muitos problemas que podem ser resolvidos com recursão também podem ser resolvidos de forma "],["italic",["text","lazy"]],["text",", geralmente de forma mais rápida e elegante."],["br"]],["paragraph",["text","Para demonstrar isso, vamos criar outra função chamada "],["monospaced",["text","count-melhor-ainda"]],["text"," que efetua a contagem de forma "],["italic",["text","lazy"]],["text"," através da função "],["monospaced",["text","reduce"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn count-melhor-ainda [lista]"],["br"],["code-text","  (reduce (fn [contagem _] "],["br"],["code-text","            (inc contagem)) "],["br"],["code-text","          0 "],["br"],["code-text","          lista))"],["br"]],["paragraph",["br"]],["paragraph",["text","Sabemos que "],["monospaced",["text","reduce"]],["text"," recebe uma função que vai processar cada um dos itens da sequencia."],["br"]],["paragraph",["text","Essa função recebe dois parâmetros, sendo o primeiro com o valor acumulado até aquele momento e o segundo com o valor da sequencia que está sendo processado. No final do processo temos um valor escalar resultante do processamento de todos os itens da sequencia."],["br"]],["paragraph",["text","O terceiro argumento passado para "],["monospaced",["text","reduce"]],["text"," é o valor inicial a ser acumulado. Nós vamos usar "],["italic",["text","0"]],["text"," para que uma sequencia vazia retorne um tamanho "],["italic",["text","0"]],["text",". Finalmente, o último parâmetro contém a sequencia propriamente dita."],["br"]],["paragraph",["text","A nossa função passada para "],["monospaced",["text","reduce"]],["text"," tem dois parâmetros, um chamado "],["monospaced",["text","contagem"]],["text",", que contém realmente o valor da contagem dos itens, e o segundo chamado "],["monospaced",["text","_"]],["text","."],["br"]],["paragraph",["text","Demos esse nome sem graça para o parâmetro para indicar "],["italic",["text","ao programador"]],["text"," que aquele parâmetro não vai ser usado para nada. Você poderia dar qualquer nome que quisesse, incluindo "],["monospaced",["text","atual"]],["text"," ou "],["monospaced",["text","item"]],["text",". O que importa é que o programador vai olhar para o código e ver de cara que aquele parâmetro não vai ser utilizado. Para o Clojure tanto faz o nome que você estiver usando, desde que seja um identificador válido."],["br"]],["code","clojure",["br"],["code-text","(def contagem-2 (->> (range 1 1e10)"],["br"],["code-text","                     (map #(* % 33))"],["br"],["code-text","                     (filter #(= 0 (mod % 17)))"],["br"],["code-text","                     count-ainda-melhor))"],["br"],["code-text","contagem-2"],["br"],["code-text","; 588235294"],["br"]],["paragraph",["br"]],["index",["text","time"]],["paragraph",["br"]],["paragraph",["text","Chegamos ao mesmo resultado com um código bem menos e mais simples de entender. Agora vamos ver se ficou mais rápido mesmo. Para isso vamos usar a macro "],["monospaced",["text","time"]],["text"," para exibir o tempo decorrido no processamento."],["br"]],["code","clojure",["br"],["code-text","(time (->> (range 1 1e10)"],["br"],["code-text","         (map #(* % 33))"],["br"],["code-text","         (filter #(= 0 (mod % 17)))"],["br"],["code-text","         count-melhor))"],["br"],["code-text","; \"Elapsed time: 936001.099613 msecs\""],["br"],["code-text","(time (->> (range 1 1e10)"],["br"],["code-text","         (map #(* % 33))"],["br"],["code-text","         (filter #(= 0 (mod % 17)))"],["br"],["code-text","         count-melhor-ainda))"],["br"],["code-text","; \"Elapsed time: 877925.917591 msecs\""],["br"]],["paragraph",["br"]],["paragraph",["text","Na forma recursiva o processo levou "],["italic",["text","15"]],["text"," minutos e meio para retornar um valor, enquanto na forma "],["italic",["text","lazy"]],["text",", com a função "],["monospaced",["text","count-melhor-ainda"]],["text"," esperamos "],["italic",["text","14"]],["text"," minutos e meio. Tivemos quase um minuto de diferença entre as duas implementações."],["br"]],["section",["text","Laziness no mundo real"]],["paragraph",["br"]],["paragraph",["text","Até agora vimos que é muito legal fazer cálculos gigantescos que não levam a nada prático usando "],["italic",["text","lazy sequences"]],["text",", "],["italic",["text","streams"]],["text"," e também como não ficar com a cabeça presa num processamento."],["br"]],["paragraph",["text","Mas como é que podemos aplicar isso num problema de verdade?"],["br"]],["paragraph",["text","Vamos pegar um problema realmente grande para estudarmos."],["br"]],["paragraph",["text","A "],["italic",["text","Wikipedia"]],["text"," é a maior enciclopedia online e gratuito disponível atualmente com mais de quatro milhões e meio de artigos na sua versão em língua inglesa, que é a mais extensa. "],["br"]],["paragraph",["text","A "],["italic",["text","Wikimedia Foundation"]],["text",", empresa responsável pela estrutura por trás da "],["italic",["text","Wikipedia"]],["text"," disponibiliza arquivos compactados contendo todo o conteúdo da enciclopédia, para que seja possível fazer pesquisas específicas sem sobrecarregar os servidores."],["br"]],["paragraph",["text","O arquivo contendo todos os artigos em inglês ocupa "],["italic",["text","10 GB"]],["text"," quando compactado, e mais de "],["italic",["text","44 GB"]],["text"," quando descompactado. A menos que você tenha um computador com uma quantidade absurda de memória disponível, é improvável que você queira carregar todos esses dados em memória de uma vez só para efetuar qualquer tipo de processamento."],["br"]],["paragraph",["text","Vamos criar um projeto para contarmos quantos artigos temos no arquivo mais atualizado. Só que vamos adicionar um nível de dificuldade ao dizer que você não pode descompactar o arquivo para processá-lo."],["br"]],["paragraph",["text","Primeiro, faça o download da Wikipedia em inglês, compactada."],["br"]],["paragraph",["text","http://goo.gl/cWDmRV"],["br"]],["paragraph",["text","Como o arquivo tem 10GB, dependendo da velocidade da sua conexão com a Internet, isso pode demorar um pouco. Aqui em casa isso costuma demorar uma noite inteira."],["br"]],["paragraph",["text","Enquanto isso, vamos criar um novo projeto usando o "],["italic",["text","Leiningen"]],["text","."],["br"]],["paragraph",["text","Na linha de comando do seu sistema operacional, digite o comando"],["br"]],["code","javascript",["br"],["code-text","lein new wiki"],["br"]],["paragraph",["br"]],["paragraph",["text","Dentro do diretório "],["monospaced",["text","wiki"]],["text",", edite o arquivo "],["monospaced",["text","project.clj"]],["text"," e adicione as dependencias que estão listadas abaixo. Não se esqueça de adicionar a configuração "],["monospaced",["text",":main"]],["text"," para apontar para o "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","wiki.core"]],["text","."],["br"]],["code","clojure",["code-text"," "],["br"],["code-text","(defproject wiki \"0.1.0-SNAPSHOT\""],["br"],["code-text","  :dependencies [[org.clojure/clojure \"1.7.0\"] ; a versão pode variar"],["br"],["code-text","                 [org.apache.commons/commons-compress \"1.8.1\"]"],["br"],["code-text","                 [org.clojure/data.xml \"0.0.8\"]]"],["br"],["code-text","  :main wiki.core)"],["br"]],["paragraph",["br"]],["paragraph",["text","Dentro do diretorio "],["monospaced",["text","src"]],["text",", vamos editar o arquivo "],["monospaced",["text","core.clj"]],["text",", que é onde ficará o nosso código fonte."],["br"]],["index",["text","clojure.java.io"]],["paragraph",["br"]],["index",["text","clojure.java.xml"]],["paragraph",["br"]],["paragraph",["text","Vamos precisar das funções dos "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.java.io"]],["text",", que empacota os objetos de "],["monospaced",["text","java.io"]],["text"," de uma forma que fique mais fácil usá-los dentro do Clojure, e também do "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.data.xml"]],["text",", para podermos usar os recursos da biblioteca "],["monospaced",["text","clojure/data.xml"]],["text",", que nos permite ler e manipular arquivos "],["italic",["text","XML"]],["text"," dentro do Clojure de forma "],["italic",["text","lazy"]],["text","."],["br"]],["index",["text","BZip2CompressorInputStream"]],["paragraph",["br"]],["paragraph",["text","De dentro da biblioteca "],["monospaced",["text","commons-compress"]],["text"," vamos precisar usar o objeto "],["monospaced",["text","BZip2CompressorInputStream"]],["text",", que nos oferece recursos para manipular arquivos compactados no formato "],["italic",["text","BZip2"]],["text"," também de forma "],["italic",["text","lazy"]],["text","."],["br"]],["paragraph",["text","Como podemos trabalhar de forma "],["italic",["text","lazy"]],["text"," se "],["monospaced",["text","commons-compress"]],["text"," é uma biblioteca Java, sem qualquer código Clojure?"],["br"]],["paragraph",["text","Como já foi dito nesse capítulo, um "],["italic",["text","stream"]],["text"," funciona exatamente como uma "],["italic",["text","lazy sequence"]],["text"," que é lida do começo para o fim, sem se preocupar com o que já foi processado."],["br"]],["paragraph",["text","Então podemos trabalhar com "],["monospaced",["text","InputStream"]],["text"," do Java de forma transparente. E, como o próprio nome da classe diz, "],["monospaced",["text","BZip2CompressorInputStream"]],["text"," é uma implementação de "],["monospaced",["text","InputStream"]],["text","."],["br"]],["paragraph",["text","Vamos à nossa declaração de "],["italic",["text","namespace"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(ns wiki.core"],["br"],["code-text","  (:require [clojure.java.io :as io]"],["br"],["code-text","            [clojure.data.xml :as xml]"],["br"],["code-text","  (:import  [org.apache.commons.compress.compressors.bzip2 "],["br"],["code-text","             BZip2CompressorInputStream]))"],["br"]],["paragraph",["br"]],["paragraph",["text","A nossa aplicação vai receber o nome do arquivo pela linha de comando e passar para uma função que retorna uma "],["italic",["text","lazy sequence"]],["text"," contendo cada página como se fosse um item."],["br"]],["paragraph",["text","Por "],["italic",["text","página"]],["text"," a Wikipedia entende não só os tópicos de enciclopédia, mas também páginas de usuários, discussões, categorias e qualquer outra informação que tenha um endereço específico."],["br"]],["paragraph",["text","Vamos criar uma função chamada "],["monospaced",["text","xml-reader"]],["text"," que receba esse nome de arquivo e devolva a "],["italic",["text","lazy sequence"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn xml-reader [filename]"],["br"],["code-text","  (-> filename "],["br"]],["paragraph",["br"]],["paragraph",["text","Primeiro vamos abrir o arquivo e, em seguida, criar um "],["monospaced",["text","InputStream"]],["text"," para podemos lê-lo."],["br"]],["code","clojure",["br"],["code-text","      io/file "],["br"],["code-text","      io/input-stream "],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos passar o "],["monospaced",["text","InputStream"]],["text"," que criamos como parâmetro para a criação de um objeto "],["monospaced",["text","BZip2CompressorInputStream"]],["text",", que é quem vai ler o arquivo compactado e nos retornar o conteúdo em formato texto. Como podemos ter mais de um arquivo "],["italic",["text","XML"]],["text"," dentro do arquivo compactado, vamos passar também a opção "],["monospaced",["text","true"]],["text"," para o "],["italic",["text","constructor"]],["text"," do objeto."],["br"]],["code","clojure",["br"],["code-text","      (BZip2CompressorInputStream. true)"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos usar o "],["italic",["text","stream"]],["text"," que criamos para gerar um objeto "],["monospaced",["text","Reader"]],["text",", que é o formato esperado pela função "],["monospaced",["text","parse"]],["text"," da biblioteca "],["monospaced",["text","clojure/data.xml"]],["text","."],["br"]],["code","clojure",["br"],["code-text","      io/reader"],["br"],["code-text","      xml/parse"],["br"]],["paragraph",["br"]],["paragraph",["text","A função "],["monospaced",["text","parse"]],["text"," nos retorna um "],["italic",["text","hashmap"]],["text"," contendo o conteúdo do arquivo. A parte que nos interessa fica dentro da chave "],["monospaced",["text",":content"]],["text","."],["br"]],["code","clojure",["br"],["code-text","      :content))"],["br"]],["paragraph",["br"]],["paragraph",["text","Pronto, temos a nossa função que abre um arquivo compactado muito grande e nos devolve uma "],["italic",["text","lazy sequence"]],["text"," com uma página por item."],["br"]],["paragraph",["text","Agora precisamos filtrar as páginas e extrair somente os artigos."],["br"]],["paragraph",["text","A estrutura de uma página é, de forma simplificada, a que temos a seguir."],["br"]],["code",["text","xml"],["br"],["code-text","<page>"],["br"],["code-text","  <title>Clojure</title>"],["br"],["code-text","  <ns>0</ns>"],["br"],["code-text","  <id>12345</id>"],["br"],["code-text","  <revision>"],["br"],["code-text","    <id>445283</id>"],["br"],["code-text","    <parentid>445256</parentid>"],["br"],["code-text","    <timestamp>2014-03-31T12:33:49Z</timestamp>"],["br"],["code-text","    <contributor>"],["br"],["code-text","      <username>Clojurian</username>"],["br"],["code-text","      <id>9016</id>"],["br"],["code-text","    </contributor>"],["br"],["code-text","    <text>O texto da página</text>"],["br"],["code-text","    <sha1>aep0xqjml9aphc1nq9fk69vodyg9wjr</sha1>"],["br"],["code-text","    <model>wikitext</model>"],["br"],["code-text","    <format>text/x-wiki</format>"],["br"],["code-text","  </revision>"],["br"],["code-text","</page>"],["br"]],["paragraph",["br"]],["paragraph",["text","Toda página tem uma "],["italic",["text","tag"]],["text"," "],["monospaced",["text","ns"]],["text",", cujo valor é sempre "],["italic",["text","0"]],["text"," quando estamos olhando um artigo. Existem vários outros valores para cada um dos tipos de página, mas para o exemplo só nos interessam os artigos."],["br"]],["paragraph",["text","Nosso filtro vai extrair o conteúdo da "],["italic",["text","tag"]],["text"," "],["monospaced",["text","ns"]],["text"," e verificar se é "],["italic",["text","0"]],["br"]],["paragraph",["text","Vamos chamar nosso filtro de "],["monospaced",["text","article?"]],["text",", já que é um predicado que retorna "],["monospaced",["text","true"]],["text"," caso estejamos analisando um artigo."],["br"]],["index",["text","clojure.data.xml/parse"]],["paragraph",["br"]],["paragraph",["text","Ao ler o "],["italic",["text","XML"]],["text",", a função "],["monospaced",["text","parse"]],["text"," nos retorna um "],["italic",["text","hashmap"]],["text"," contendo o nome da "],["italic",["text","tag"]],["text"," que está sendo lida e seu respectivo conteúdo. Dentro do conteúdo você encontra a "],["italic",["text","tag"]],["text"," que estiver aninhada com seu respectivo conteúdo, e assim por diante."],["br"]],["paragraph",["text","De maneira simplificada, teremos um "],["italic",["text","hashmap"]],["text"," parecido com esse ao ler a nossa página de exemplo."],["br"]],["code","clojure",["br"],["code-text","{:tag :page,"],["br"],["code-text"," :attrs {},"],["br"],["code-text"," :content {:tag :ns, "],["br"],["code-text","           :attrs {},"],["br"],["code-text","           :content \"0\"}}"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos criar a função e separar os valores da "],["italic",["text","tag"]],["text"," e do conteúdo. Com esses dois valores, vamos extrair o valor de "],["monospaced",["text","ns"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn article? [item]"],["br"],["code-text","  (let [tag     (:tag item)"],["br"],["code-text","        content (:content item)"],["br"],["code-text","        nspace  (->> content"],["br"],["code-text","                     (filter #(= (:tag %) :ns))"],["br"],["code-text","                     first"],["br"],["code-text","                     :content"],["br"],["code-text","                     first)]"],["br"]],["paragraph",["br"]],["paragraph",["text","Finalmente, vamos verificar se estamos lendo uma página, quando a "],["italic",["text","tag"]],["text"," for igual a "],["monospaced",["text",":page"]],["text",", e se seu respectivo valor de "],["monospaced",["text","ns"]],["text"," é igual a "],["italic",["text","0"]],["text","."],["br"]],["code","clojure",["br"],["code-text","    (and (= tag :page)"],["br"],["code-text","         (= nspace \"0\"))))"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos à ultima parte, onde escrevemos a função "],["monospaced",["text","-main"]],["text"," e passamos o nome do arquivo passado por parâmetro para o nosso processamento."],["br"]],["code","clojure",["br"],["code-text","(defn -main [& args]"],["br"],["code-text","  (let [file     (first args)"],["br"],["code-text","        xml-seq  (->> file"],["br"],["code-text","                      xml-reader"],["br"],["code-text","                      (filter article?))]"],["br"],["code-text","    (println (count xml-seq))))"],["br"]],["paragraph",["br"]],["code","javascript",["br"],["code-text","lein run enwiki-latest-pages-articles-multistream.xml.bz2"],["br"],["code-text","> 10891925"],["br"]],["paragraph",["br"]],["paragraph",["text","Mas por que recebemos um valor tão grande se a Wikipedia tem \"apenas\" quatro milhões e meio de artigos? Porque na nossa conta estão incluídos os redirecionamentos, que são artigos que existem apenas para direcionar o leitor para o artigo principal."],["br"]],["paragraph",["text","Como desafio, estude o código e altere-o para que não sejam considerados os redirecionamentos."],["br"]],["section",["text","Forçando a execução da sequencia"]],["paragraph",["br"]],["paragraph",["text","Existem situações em que é necessário forçar a execução da sequencia. No nosso exemplo, em que processamos o arquivo da "],["italic",["text","Wikipedia"]],["text",", isso aconteceu ao utilizarmos "],["monospaced",["text","count"]],["text",", que vai contar cada um dos itens da sequencia para retornar seu tamanho. "],["br"]],["paragraph",["text","Outra situação comum é quando testamos um código no "],["italic",["text","REPL"]],["text"," e obtemos o resultado, mas ao executar a aplicaçao, nada acontece."],["br"]],["paragraph",["text","Isso acontece porque durante a execução do "],["italic",["text","P"]],["text"," do "],["italic",["text","REPL"]],["text",", que é a parte onde são exibidos os resultados na tela, a "],["italic",["text","lazy sequence"]],["text"," é completamente avaliada antes da exibição. Caso você use "],["monospaced",["text","println"]],["text"," ou qualquer outra função do Clojure que exiba dados na tela, a sequencia será executada do começo ao fim."],["br"]],["paragraph",["text","Para exemplificar, criei um projeto bem simples chamado "],["monospaced",["text","lazyfail"]],["text",", que pode ser encontrado no repositório do livro."],["br"]],["paragraph",["text","Além do arquivo de configuração, teremos apenas um "],["italic",["text","namespace"]],["text"," contendo duas funções."],["br"]],["paragraph",["text","A primeira chama-se "],["monospaced",["text","crunch-data"]],["text",", e serve apenas para simularmos um processamento qualquer que demore para terminar. Vamos fazer o processamento esperar dez milissegundos e retornar o quadrado do valor que foi passado como parâmetro."],["br"]],["paragraph",["text","Vamos também mandar imprimir pontos apenas para sinalizar quando a função está sendo executada."],["br"]],["code","clojure",["br"],["code-text","(defn crunch-data [value]"],["br"],["code-text","  (Thread/sleep 10)"],["br"],["code-text","  (print \".\")"],["br"],["code-text","  (* value value))"],["br"]],["paragraph",["br"]],["paragraph",["text","Temos também a função "],["monospaced",["text","-main"]],["text",", que é o ponto inicial da nossa aplicação."],["br"]],["paragraph",["text","Nela vamos executar "],["monospaced",["text","map"]],["text",", que já sabemos que retorna uma "],["italic",["text","lazy sequence"]],["text",", processando números de "],["italic",["text","0"]],["text"," a "],["italic",["text","999"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn -main [& args]"],["br"],["code-text","  (map crunch-data (range 1000)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos entrar no "],["italic",["text","REPL"]],["text",", digitando "],["monospaced",["text","lein repl"]],["text"," no terminal, dentro do diretório "],["monospaced",["text","lazyfail"]],["text",", e executar a função "],["monospaced",["text","-main"]],["text"," para ver nossa aplicação ser executada."],["br"]],["paragraph",["text","Note que o "],["italic",["text","namespace"]],["text"," dessa vez será "],["monospaced",["text","lazyfail.core"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(-main)"],["br"],["code-text","; (0 1 4 9 16 25 36 49 64 81 100 121 144 ... 998001)"],["br"],["code-text","; e mais um monte de pontos"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos sair do "],["italic",["text","REPL"]],["text"," e executar o comando "],["monospaced",["text","lein run"]],["text",", para que a aplicação seja executada."],["br"]],["paragraph",["text","O sinal de "],["monospaced",["text","$"]],["text"," aqui apenas indica que estamos no terminal e não deve ser digitado."],["br"]],["code",["br"],["code-text","$ lein run"],["br"],["code-text","$"],["br"]],["paragraph",["br"]],["paragraph",["text","Nada aconteceu, nenhum pontinho apareceu, justamente porque na execução da aplicação ninguém forçou a execução da "],["italic",["text","lazy sequence"]],["text"," retornada por "],["monospaced",["text","map"]],["text","."],["br"]],["paragraph",["text","A situação fica ainda pior se adicionarmos um "],["monospaced",["text","print"]],["text",", no final da função "],["monospaced",["text","-main"]],["text",", nos informando que o processamento acabou."],["br"]],["paragraph",["text","Vamos alterar a função "],["monospaced",["text","-main"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(defn -main [& args]"],["br"],["code-text","  (map crunch-data (range 1000))"],["br"],["code-text","  (println \"Acabou\"))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos entrar no "],["italic",["text","REPL"]],["text"," novamente e executar a função "],["monospaced",["text","-main"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(-main)"],["br"],["code-text","; Acabou"],["br"]],["paragraph",["br"]],["paragraph",["text","Acabou? Acabou nada. Onde estão os pontinhos na tela? Se você executar a aplicação pelo terminal vai receber o mesmo resultado. Pelo menos agora não faz o que esperávamos igualmente nos dois casos."],["br"]],["code",["br"],["code-text","$ lein run"],["br"],["code-text"," Acabou"],["br"],["code-text","$"],["br"]],["paragraph",["br"]],["paragraph",["text","Relembrando, isso acontece porque "],["monospaced",["text","map"]],["text"," retornou uma "],["italic",["text","lazy sequence"]],["text"," que ninguém quis usar. Se ninguém usou, ela ficou quietinha até o final da aplicação, sem calcular um item que seja."],["br"]],["index",["text","doall"]],["paragraph",["br"]],["paragraph",["text","Para forçar a execução da sequencia, sem apelar para um "],["monospaced",["text","print"]],["text"," e sujar a tela, vamos usar a função "],["monospaced",["text","doall"]],["text",", que obriga que a sequencia seja avaliada até o final e só então a retorna como resultado."],["br"]],["paragraph",["text","Vamos editar "],["monospaced",["text","-main"]],["text"," novamente."],["br"]],["code","clojure",["br"],["code-text","(defn -main [& args]"],["br"],["code-text","  (doall"],["br"],["code-text","    (map crunch-data (range 1000)))"],["br"],["code-text","  (println \"Acabou\"))"],["br"]],["paragraph",["br"]],["paragraph",["text","Executando nosso código pelo "],["italic",["text","REPL"]],["text",", temos:"],["br"]],["code","clojure",["br"],["code-text","(-main)"],["br"],["code-text","; ......... (e mais um monte de pontinhos) ....Acabou"],["br"]],["paragraph",["br"]],["paragraph",["text","Ótimo, nossa função mastigou os mil números. E executando a aplicação, tivemos o mesmo resultado?"],["br"]],["code",["br"],["code-text","$ lein run"],["br"],["code-text","; ......... (e mais um monte de pontinhos) ....Acabou"],["br"],["code-text","$"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora sim. A aplicação faz o que esperávamos dela."],["br"]],["paragraph",["text","Existe uma forma melhor, e mais idiomática, de forçarmos o processamento de uma lista, especialmente quando são esperados efeitos colaterais e não nos importa a lista que é retornada."],["br"]],["index",["text","doseq"]],["index",["text","for"]],["paragraph",["br"]],["paragraph",["text","Para isso podemos usar "],["monospaced",["text","doseq"]],["text",", que funciona de forma parecida como o "],["monospaced",["text","for"]],["text"," do Java. Já existe um outro operador chamado "],["monospaced",["text","for"]],["text"," em Clojure, que vamos mostrar mais adiante, e não faz o que estamos querendo agora."],["br"]],["paragraph",["text","Com "],["monospaced",["text","doseq"]],["text"," o nosso código ficaria assim:"],["br"]],["code","clojure",["br"],["code-text","(defn -main [& args]"],["br"],["code-text","  (doseq [num (range 1000)]"],["br"],["code-text","    (crunch-data num))"],["br"],["code-text","  (println \"Acabou\"))"],["br"]],["paragraph",["br"]],["paragraph",["text","Cada item da sequencia gerada por "],["monospaced",["text","range"]],["text"," é atribuido a "],["monospaced",["text","num"]],["text",", que é usado como um "],["italic",["text","local binding"]],["text",", como se fosse um "],["monospaced",["text","let"]],["text","."],["br"]],["paragraph",["text","Ao executarmos nossa aplicação temos o resultado esperado, sem medo de deixar uma "],["italic",["text","lazy sequence"]],["text"," dormindo no meio do caminho."],["br"]],["code","clojure",["br"],["code-text","$ lein run"],["br"],["code-text","; ......... (e mais um monte de pontinhos) ....Acabou"],["br"]],["paragraph",["br"]],["paragraph",["text","Você deve usar "],["monospaced",["text","doseq"]],["text",", e não "],["monospaced",["text","map"]],["text",", sempre que estiver lendo dados de um arquivo, da rede ou de qualquer fonte externa à sua aplicação, de forma "],["italic",["text","lazy"]],["text",". Assim como a impressão de qualquer coisa na tela, essas também são formas de efeito colateral."],["br"]],["section",["text","List comprehensions"]],["paragraph",["br"]],["paragraph",["text","Mas eu comentei também sobre o Clojure ter "],["monospaced",["text","for"]],["text",", que não funciona como o "],["monospaced",["text","for"]],["text"," do Java."],["br"]],["paragraph",["text","No Clojure, o "],["monospaced",["text","for"]],["text"," é usado para trabalharmos com "],["italic",["text","list comprehension"]],["text","."],["br"]],["box",["text","O problema com as traduções"],["paragraph",["br"]],["paragraph",["text","Eu realmente não consegui encontrar uma tradução aceitável para "],["italic",["text","list comprehension"]],["text",", já que "],["italic",["text","compreensão de listas"]],["text"," não faz o menor sentido."],["br"]],["paragraph",["text","O mesmo aconteceu com "],["italic",["text","lazy sequences"]],["text",", onde dizer "],["italic",["text","sequências preguiçosas"]],["text"," não ajudaria muito."],["br"]],["paragraph",["text","Vamos deixar o termo em Inglês mesmo, até para facilitar as suas pesquisas quando você precisar, já que esses são os termos amplamente aceitos pela comunidade."],["br"]]],["paragraph",["br"]],["paragraph",["text","Para quem vem do Python, esse assunto já é mais do que conhecido. Os demais desenvolvedores ficam sabendo agora que "],["italic",["text","list comprehension"]],["text"," é uma forma de gerar sequencias a partir de outras sequencias usando uma sintaxe própria."],["br"]],["paragraph",["text","Mas gerar sequencias a partir de outras sequencias não é exatamente o que "],["monospaced",["text","map"]],["text",", "],["monospaced",["text","filter"]],["text"," e "],["monospaced",["text","reduce"]],["text"," já fazem?"],["br"]],["paragraph",["text","Exatamente, mas com "],["italic",["text","list comprehension"]],["text"," você pode chegar ao mesmo resultado usando um código mais expressivo e conciso."],["br"]],["paragraph",["text","Na prática, tudo o que você consegue fazer com "],["monospaced",["text","for"]],["text"," é possível de ser feito usando o nosso trio de funções. Cabe a você decidir quando o código fica mais legível de uma forma ou de outra."],["br"]],["paragraph",["text","A forma mais simples de usar "],["italic",["text","list comprehension"]],["text"," nós já conhecemos. A função "],["monospaced",["text","doseq"]],["text"," funciona de forma bem parecida com o "],["monospaced",["text","for"]],["text"," nesse ponto."],["br"]],["paragraph",["text","Vamos gerar uma lista de números de "],["italic",["text","1"]],["text"," a "],["italic",["text","10"]],["text"," e retornar uma nova lista com o dobro de cada item."],["br"]],["paragraph",["text","Com "],["monospaced",["text","map"]],["text"," basta fazer:"],["br"]],["code","clojure",["br"],["code-text","(map #(* % 2) "],["br"],["code-text","     (range 1 11))"],["br"],["code-text","; (2 4 6 8 10 12 14 16 18 20)"],["br"]],["paragraph",["br"]],["paragraph",["text","Com "],["monospaced",["text","for"]],["text"," ficaria:"],["br"]],["code","clojure",["br"],["code-text","(for [x (range 1 11)]"],["br"],["code-text","  (* x 2))"],["br"],["code-text","; (2 4 6 8 10 12 14 16 18 20)"],["br"]],["paragraph",["br"]],["paragraph",["text","Não há mistério algum aqui. Internamente a macro "],["monospaced",["text","for"]],["text"," faz uso pesado de "],["monospaced",["text","if"]],["text",", "],["monospaced",["text","map"]],["text",", "],["monospaced",["text","reduce"]],["text"," para que o nosso código fique limpinho e cheiroso."],["br"]],["paragraph",["text","Podemos usar filtros também, através da opção "],["monospaced",["text",":when"]],["text",". Vamos pegar nosso exemplo anterior e exibir apenas os múltiplos de cinco."],["br"]],["code","clojure",["br"],["code-text","(for [x (range 1 11)"],["br"],["code-text","      :when (= 0 (mod x 5))]"],["br"],["code-text","  (* x 2))"],["br"],["code-text","; (10 20)"],["br"]],["paragraph",["br"]],["paragraph",["text","Que poderíamos escrever da forma clássica com "],["monospaced",["text","map"]],["text"," e "],["monospaced",["text","filter"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(filter #(= 0 (mod % 5))"],["br"],["code-text","        (map #(* % 2) "],["br"],["code-text","             (range 1 11)))"],["br"],["code-text","; (10 20)"],["br"]],["paragraph",["br"]],["paragraph",["text","Apesar do resultado ter sido o mesmo, podemos notar que no "],["monospaced",["text","for"]],["text"," estamos multiplicando depois de filtrar, e no código com "],["monospaced",["text","map"]],["text"," estamos multiplicando primeiro."],["br"]],["paragraph",["text","Sem problemas. Vamos usar a opção "],["monospaced",["text",":let"]],["text"," para criar um "],["italic",["text","local binding"]],["text"," dentro da nossa "],["italic",["text","list comprehension"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(for [x (range 1 11)"],["br"],["code-text","      :let [y (* x 2)]"],["br"],["code-text","      :when (= 0 (mod y 5))]"],["br"],["code-text","  y)"],["br"],["code-text","; (10 20)"],["br"]],["paragraph",["br"]],["paragraph",["text","Podemos também escrever nosso código de forma diferente, usando a opção "],["monospaced",["text",":while"]],["text",", que informa quando a sequencia deve parar de gerar itens. Note que agora a função "],["monospaced",["text","range"]],["text"," vai nos retornar uma sequencia infinita:"],["br"]],["code","clojure",["br"],["code-text","(for [x (range)"],["br"],["code-text","      :while (<= x 10)"],["br"],["code-text","      :let [y (* x 2)]"],["br"],["code-text","      :when (= 0 (mod y 5))]"],["br"],["code-text","  y)"],["br"],["code-text","; (0 10 20)"],["br"]],["paragraph",["br"]],["paragraph",["text","Uma boa prática é a de utilizar "],["monospaced",["text",":while"]],["text"," ao invés de "],["monospaced",["text",":when"]],["text"," quando quisermos estabelecer uma condição de parada para a geração de sequencias."],["br"]],["index",["text","dorun"]],["paragraph",["br"]],["paragraph",["text","Vamos usar a função "],["monospaced",["text","dorun"]],["text"," para forçar a execução da "],["italic",["text","lazy sequence"]],["text"," retornada por "],["monospaced",["text","for"]],["text","."],["br"]],["paragraph",["text","A diferença entre "],["monospaced",["text","doall"]],["text"," e "],["monospaced",["text","dorun"]],["text"," é que "],["monospaced",["text","doall"]],["text"," retorna a sequencia completamente avaliada, enquanto "],["monospaced",["text","dorun"]],["text"," retorna "],["monospaced",["text","nil"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(time"],["br"],["code-text","  (dorun"],["br"],["code-text","    (for [x (range 1000) y (range 10000) :when (> x y)] [x y])))"],["br"],["code-text","; \"Elapsed time: 532.527616 msecs\""],["br"],["code-text","(time"],["br"],["code-text","  (dorun"],["br"],["code-text","    (for [x (range 1000) y (range 10000) :while (> x y)] [x y])))"],["br"],["code-text","; \"Elapsed time: 65.411137 msecs\""],["br"]],["paragraph",["br"]],["paragraph",["text","Perceba que em ambos os casos estamos lidando com sequencias do mesmo tamanho."],["br"]],["code","clojure",["br"],["code-text","(count (for [x (range 1000) y (range 10000) :when (> x y)] [x y]))"],["br"],["code-text","; 499500"],["br"],["code-text","(count (for [x (range 1000) y (range 10000) :while (> x y)] [x y]))"],["br"],["code-text","; 499500"],["br"]],["paragraph",["br"]],["paragraph",["text","Como exercício, reescreva o código a seguir usando "],["monospaced",["text","map"]],["text"," e "],["monospaced",["text","filter"]],["text",". As quebras de linhas foram adicionadas por minha conta para facilitar a visualização do resultado."],["br"]],["code","clojure",["br"],["code-text","(for [x (range 1 11) "],["br"],["code-text","      y (range 1 11) "],["br"],["code-text","      :while (< y x)] "],["br"],["code-text","  [x y])"],["br"],["code-text",";([2 1]"],["br"],["code-text","; [3 1]  [3 2]"],["br"],["code-text","; [4 1]  [4 2]  [4 3]"],["br"],["code-text","; [5 1]  [5 2]  [5 3]  [5 4]"],["br"],["code-text","; [6 1]  [6 2]  [6 3]  [6 4]  [6 5]"],["br"],["code-text","; [7 1]  [7 2]  [7 3]  [7 4]  [7 5]  [7 6]"],["br"],["code-text","; [8 1]  [8 2]  [8 3]  [8 4]  [8 5]  [8 6]  [8 7] "],["br"],["code-text","; [9 1]  [9 2]  [9 3]  [9 4]  [9 5]  [9 6]  [9 7]  [9 8]"],["br"],["code-text",";[10 1] [10 2] [10 3] [10 4] [10 5] [10 6] [10 7] [10 8] [10 9])"],["br"]],["paragraph",["br"]],["paragraph",["text","Brinque bastante com "],["italic",["text","list comprehension"]],["text",", note as diferenças de "],["italic",["text","performance"]],["text"," e no resultado conforme você troca os parâmetros de posição e compare com o código equivalente usando apenas funções. Com o tempo vai ficar bem claro onde fica melhor usar uma forma e onde é melhor usar outra."]]]