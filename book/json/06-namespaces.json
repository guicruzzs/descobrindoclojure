["document",["chapter",["text"," Namespaces para organizar o código"]],["paragraph",["br"]],["quote",["text","\"Don't build frameworks; build small, composable libraries.\""],["text","  -- Craig Andera\""]],["paragraph",["br"]],["section",["text","Organizando o código com namespaces"]],["paragraph",["br"]],["index",["text","namespace"]],["paragraph",["br"]],["paragraph",["text","Em Java, todo código que escrevemos fica encapsulado em uma "],["italic",["text","classe"]],["text",". Em Clojure não temos os conceitos de classes e objetos, mas de uma forma parecida, todo nosso código fica dentro de algum "],["italic",["text","namespace"]],["text","."],["br"]],["paragraph",["text","Um "],["italic",["text","namespace"]],["text"," é um recurso que o Clojure utiliza para evitar colisões de funções e símbolos que tenham o mesmo nome."],["br"]],["index",["text","user"]],["paragraph",["br"]],["paragraph",["text","Quando você abre o "],["italic",["text","REPL"]],["text",", por padrão é exibido o texto "],["monospaced",["text","user=>"]],["text"," imediatamente antes do cursor. Isso indica que, no momento, estamos no "],["italic",["text","namespace"]],["text"," chamado "],["monospaced",["text","user"]],["text","."],["br"]],["img",["text","images/capitulo_06/cap06_lein_repl.png \"REPL do Clojure\" w=70% label=lein-repl"]],["paragraph",["br"]],["paragraph",["text","Toda função ou "],["italic",["text","var"]],["text"," que declararmos, será adicionado ao "],["italic",["text","namespace"]],["text"," atual. Vamos criar uma função qualquer chamada, adivinhe só, "],["monospaced",["text","funcao-qualquer"]],["text",", para demonstrarmos essa dependência entre função e "],["italic",["text","namespace"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(defn funcao-qualquer [x]"],["br"],["code-text","  (+ x 1))"],["br"],["code-text","; #'user/funcao-qualquer"],["br"]],["paragraph",["br"]],["index",["text","package"]],["paragraph",["br"]],["index",["text","java.lang.String"]],["paragraph",["br"]],["paragraph",["text","Perceba que foi criado um "],["italic",["text","var"]],["text"," chamado "],["monospaced",["text","user/funcao-qualquer"]],["text",". Chamamos esse nome completo, com "],["italic",["text","namespace"]],["text"," e "],["italic",["text","var"]],["text"," de "],["italic",["text","nome qualificado"]],["text",", ou em inglês "],["italic",["text","fully qualified name"]],["text"," ou "],["italic",["text","FQN"]],["text",". Um nome completo de uma classe Java também é chamado de "],["italic",["text","FQN"]],["text",", como acontece por exemplo com "],["monospaced",["text","java.lang.String"]],["text",", onde "],["monospaced",["text","java.lang"]],["text"," é um "],["italic",["text","package"]],["text"," e "],["monospaced",["text","String"]],["text"," é o nome da classe."],["br"]],["paragraph",["text","Caso estejamos no mesmo "],["italic",["text","namespace"]],["text"," em que a função foi criada, basta chamar a função sem informar o nome completo:"],["br"]],["code","clojure",["br"],["code-text","(funcao-qualquer 3)"],["br"],["code-text","; 4"],["br"]],["paragraph",["br"]],["index",["text","/"]],["paragraph",["br"]],["paragraph",["text","Ou podemos usar também o nome qualificado, separando o namespace do nome da função através do caracter "],["monospaced",["text","/"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(user/funcao-qualquer 10)"],["br"],["code-text","; 11"],["br"]],["paragraph",["br"]],["index",["text","*ns*"]],["paragraph",["br"]],["paragraph",["text","E como sabemos qual o nosso "],["italic",["text","namespace"]],["text"," atual, além do prompt que aparece para digitarmos no "],["italic",["text","REPL"]],["text","? Basta acessar o "],["italic",["text","var"]],["text"," "],["monospaced",["text","*ns*"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","*ns*"],["br"],["code-text","; #<Namespace user>"],["br"]],["paragraph",["br"]],["section",["text","Namespaces e arquivos"]],["paragraph",["br"]],["paragraph",["text","Assim como também acontece no Java, onde o nome de um "],["italic",["text","package"]],["text"," obedece a uma estrutura de diretórios em disco, um "],["italic",["text","namespace"]],["text"," em Clojure também segue essa lógica."],["br"]],["paragraph",["text","Vamos pegar um projeto Java para entender melhor como isso funciona."],["br"]],["paragraph",["text","Os livros da "],["italic",["text","Casa do Código"]],["text"," são escritos utilizando uma "],["italic",["text","linguagem de markup"]],["text"," chamada Tubaína. Sem entrar no mérito de como funciona e de como é a linguagem, vamos dar uma olhada em seu repositório no GitHub, que está em:"],["br"]],["paragraph",["text","https://github.com/caelum/tubaina"],["br"]],["paragraph",["text","Por conta da ferramenta utilizada para gerenciar dependências, os arquivos de código fonte ficam no diretório "],["monospaced",["text","src/main/java"]],["text","."],["br"]],["paragraph",["text","A classe principal do Tubaina chama-se "],["monospaced",["text","br.com.caelum.tubaina.Tubaina"]],["text",", e fica no arquivo "],["monospaced",["text","br/com/caelum/tubaina/Tubaina.java"]],["text",". Note que existe uma relação direta entre o diretório em que o código fonte se encontra e o nome completo da classe. Pois é dessa forma hierárquica que o Java organiza seus pacotes. Cada item do nome do pacote é um diretório, e a classe é um arquivo."],["br"]],["paragraph",["text","O Clojure trata os "],["italic",["text","namespaces"]],["text"," de forma bem parecida, com exceção de que não temos aqui o conceito de classes."],["br"]],["paragraph",["text","Vamos observar um projeto Clojure de verdade para ilustrar melhor."],["br"]],["index",["text","friend"]],["paragraph",["br"]],["paragraph",["text","A biblioteca "],["monospaced",["text","friend"]],["text",", desenvolvida originalmente por Chas Emerick, que permite que você utilize os serviços de autenticação de Google, Facebook ou qualquer outro que você precisar."],["br"]],["paragraph",["text","Vamos dar uma olhada na organização do código fonte. O repositório do GitHub está em:"],["br"]],["paragraph",["text","https://github.com/cemerick/friend"],["br"]],["paragraph",["text","Nesse caso, devido ao fato do projeto estar usando "],["italic",["text","Leiningen"]],["text"," para gerenciar suas dependências, o código fonte está no diretório "],["monospaced",["text","src"]],["text","."],["br"]],["paragraph",["text","O "],["italic",["text","namespace"]],["text"," principal da biblioteca é "],["monospaced",["text","cemerick.friend"]],["text",", e seu respectivo código fonte está no arquivo "],["monospaced",["text","cemerick/friend.clj"]],["text",". Muito parecido com o modo como o Java trabalha."],["br"]],["paragraph",["text","Adiante vamos aplicar isso na prática em nosso próprio projeto."],["br"]],["section",["text","O namespace por dentro"]],["paragraph",["br"]],["paragraph",["text","Por enquanto, vamos brincar com o "],["italic",["text","REPL"]],["text",". Inicie um "],["italic",["text","REPL"]],["text"," com o comando "],["monospaced",["text","lein repl"]],["text"," para que possamos acompanhar os exemplos."],["br"]],["paragraph",["text","Internamente, cada "],["italic",["text","namespace"]],["text"," mantém um mapa relacionando um símbolo a uma função do Clojure, classe ou membro de classe do Java. Esse símbolo nada mais é do que o nome do "],["italic",["text","var"]],["text"," que vamos utilizar no nosso código para invocar a função, classe ou membro de classe. Podemos chamar esse mapa de "],["italic",["text","mapa de referências"]],["text","."],["br"]],["index",["text","+"]],["index",["text","clojure.core/+"]],["paragraph",["br"]],["paragraph",["text","Por padrão, quando você usa o operador "],["monospaced",["text","+"]],["text",", o Clojure procura o símbolo "],["monospaced",["text","+"]],["text"," no mapa do "],["italic",["text","namespace"]],["text"," atual. Não encontrando, a busca será feita nos "],["italic",["text","namespaces"]],["text"," que foram referenciados através de "],["monospaced",["text","require"]],["text",", "],["monospaced",["text","use"]],["text"," ou "],["monospaced",["text","import"]],["text",", e então, no nosso exemplo, é retornada uma referência à função "],["monospaced",["text","clojure.core/+"]],["text",". Se você criar uma função chamada "],["monospaced",["text","+"]],["text"," dentro do "],["italic",["text","namespace"]],["text"," atual, essa nova entrada no mapa passará a ter precedência sobre os outros, e na próxima chamada a "],["monospaced",["text","+"]],["text",", você receberá a função que você acabou de criar."],["br"]],["index",["text","`"]],["paragraph",["br"]],["paragraph",["text","Vamos usar o operador "],["monospaced",["text","`"]],["text",", que a partir de um símbolo retorna com seu nome completo, incluindo o "],["italic",["text","namespace"]],["text",". Para conseguir isso, ele consulta o mapa de referências do "],["italic",["text","namespace"]],["text","."],["br"]],["code","clojure",["br"],["code-text",";; vamos acessar o operador + padrão"],["br"],["code-text","`+"],["br"],["code-text","; clojure.core/+"],["br"],["code-text",";; agora vamos criar uma função chamada +"],["br"],["code-text","(defn + [a b]"],["br"],["code-text","  (clojure.core/+ a b))"],["br"],["code-text","; WARNING: + already refers to: #'clojure.core/+ in"],["br"],["code-text",";  namespace: user, being replaced by: #'user/+"],["br"],["code-text",";; veja que o operador + agora aponta para a nova função"],["br"],["code-text","`+"],["br"],["code-text","; user/+"],["br"],["code-text",";; ainda podemos usar o + original através do nome completo"],["br"],["code-text","`clojure.core/+"],["br"],["code-text","; clojure.core/+"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que o Clojure nos avisa quando essa referência é sobrescrita. Normalmente fazer isso é uma má prática e deve ser evitada, mas para os nossos propósitos, serve bem para ilustrar como o "],["italic",["text","namespace"]],["text"," funciona. Perceba também que continuamos acessando a função "],["monospaced",["text","+"]],["text"," original informando seu nome completo com o "],["italic",["text","namespace"]],["text"," em que ela foi criada."],["br"]],["paragraph",["text","O fato do "],["italic",["text","var"]],["text"," "],["monospaced",["text","+"]],["text"," do nosso "],["italic",["text","namespace"]],["text"," apontar para a função "],["monospaced",["text","clojure.core/+"]],["text"," ou para a função "],["monospaced",["text","user/+"]],["text"," é chamado de "],["italic",["text","fazer referência a uma função"]],["text",", apontar para uma função, ou simplesmente "],["italic",["text","refer"]],["text"," no original em inglês."],["br"]],["paragraph",["text","Já o ato de criarmos um "],["italic",["text","var"]],["text"," "],["monospaced",["text","+"]],["text"," que é adicionado no mapa do "],["italic",["text","namespace"]],["text"," é chamado de "],["italic",["text","intern"]],["text"," ou, em tradução livre, "],["italic",["text","tornar o var interno ao nosso namespace"]],["text","."],["br"]],["section",["text","Internalizando e referenciando funções"]],["paragraph",["br"]],["paragraph",["text","Em algum momento você vai se perguntar como é que o Clojure sabe que o operador "],["monospaced",["text","+"]],["text"," aponta para a função "],["monospaced",["text","clojure.core/+"]],["text",", sendo que você nem ao menos suspeitou que existisse um "],["italic",["text","namespace"]],["text"," chamado "],["monospaced",["text","clojure.core"]],["text","."],["br"]],["paragraph",["text","Todas os "],["italic",["text","vars"]],["text"," declarados no "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.core"]],["text"," são incluidos por padrão no seu namespace atual."],["br"]],["index",["text","ns"]],["paragraph",["br"]],["paragraph",["text","Vamos criar um "],["italic",["text","namespace"]],["text"," chamado "],["monospaced",["text","capitulo-06"]],["text"," para podermos brincar com essa característica. Para isso, vamos usar o operador "],["monospaced",["text","ns"]],["text",", que cria um novo "],["italic",["text","namespace"]],["text"," caso ele ainda não exista e muda o contexto atual para dentro dele."],["br"]],["code","clojure",["br"],["code-text","(ns capitulo-06)"],["br"],["code-text","; nil"],["br"]],["paragraph",["br"]],["paragraph",["text","Perceba que o prompt mudou de "],["monospaced",["text","user=>"]],["text"," para "],["monospaced",["text","capitulo-06=>"]],["text","."],["br"]],["paragraph",["text","Vamos voltar ao operador "],["monospaced",["text","+"]],["text",". Se você bem se lembra, ele é incluído automaticamente em nosso "],["italic",["text","namespace"]],["text",", assim como todo o resto de "],["monospaced",["text","clojure.core"]],["text",". Quando tentamos criar nossa própria função "],["monospaced",["text","+"]],["text",", recebemos uma mensagem de aviso."],["br"]],["paragraph",["text","E se quisermos criar nossa própria função "],["monospaced",["text","+"]],["text",", ignorando as funções que já existem em "],["monospaced",["text","clojure.core"]],["text","?"],["br"]],["index",["text","ns :refer-clojure"]],["paragraph",["br"]],["paragraph",["text","Felizmente o Clojure permite que você controle os "],["italic",["text","vars"]],["text"," de "],["monospaced",["text","clojure.core"]],["text"," que serão incluidos no nosso "],["italic",["text","namespace"]],["text"," através da opção "],["monospaced",["text",":refer-clojure"]],["text"," do operador "],["monospaced",["text","ns"]],["text","."],["br"]],["paragraph",["text","Vamos repetir o exemplo do operador "],["monospaced",["text","+"]],["text",", mas dessa vez dizendo ao Clojure que não queremos a função "],["monospaced",["text","clojure.core/+"]],["text"," em nosso "],["italic",["text","namespace"]],["text","."],["br"]],["box",["text","Reinicie o REPL"],["paragraph",["br"]],["paragraph",["text","Antes de executar cada um dos exemplos a seguir, onde for indicado, saia do REPL, entre novamente e só então digite o código. A chateação nesse caso é intencional e será explicada em breve."],["br"]],["paragraph",["text","Caso tenha curiosidade, experimente executar os exemplos sem reiniciar o REPL para ver as mensagens de erro que ocorrem."],["br"]]],["paragraph",["br"]],["code","clojure",["br"],["code-text","; Reinicie o REPL"],["br"],["code-text","(ns capitulo-06"],["br"],["code-text","    (:refer-clojure :exclude [+]))"],["br"],["code-text","`+"],["br"],["code-text","; capitulo-06/+"],["br"]],["paragraph",["br"]],["paragraph",["text","Note aqui aqui já não recebemos mais "],["monospaced",["text","clojure.core/+"]],["text"," como resposta. Isso indica que "],["monospaced",["text","+"]],["text"," não está mapeado para o operador padrão de soma do Clojure."],["br"]],["code","clojure",["br"],["code-text","(defn + [a b]"],["br"],["code-text","  (clojure.core/+ a b))"],["br"],["code-text","; e não recebemos nenhum warning aqui"],["br"],["code-text","(+ 1 2)"],["br"],["code-text","; 3"],["br"]],["paragraph",["br"]],["paragraph",["text","Apesar de não temos incluido a função "],["monospaced",["text","clojure.core/+"]],["text"," em nosso "],["italic",["text","namespace"]],["text",", note que podemos continuar acessando-a através de seu nome completo."],["br"]],["paragraph",["text","Então você se pergunta por que motivos seria necessário criar uma função com o mesmo nome de outra que já existe na biblioteca padrão da linguagem?"],["br"]],["paragraph",["text","Vamos escrever um código que substitua as letras de um texto por seus correspondentes "],["monospaced",["text","1337"]],["text",". A escrita "],["monospaced",["text","1337"]],["text"," é uma forma de se fazer passsar por hacker entre seus amigos do Facebook quando você tem menos de quinze anos. Basicamente trocam-se os caracteres normais de uma palavra por números e símbolos para que a linguagem pareça cifrada."],["br"]],["box",["text","1337"],["paragraph",["br"]],["paragraph",["monospaced",["text","1337"]],["text",", lê-se 'lit', é o resultado da substituição das letras de "],["italic",["text","leet"]],["text",", forma corrompida de se escrever "],["italic",["text","elite"]],["text",". O termo é usado como sinônimo para algo ou alguém que seja bem visto num grupo de hackers"],["ref",["text","leetspeak"]],["text","."],["br"]],["paragraph",["text","O termo pode ser usado também de forma irônica, dependendo do contexto."],["br"]]],["paragraph",["br"]],["index",["text","String.replace"]],["paragraph",["br"]],["index",["text","clojure.core/replace"]],["paragraph",["br"]],["paragraph",["text","No Java usaríamos o método "],["monospaced",["text","String.replace"]],["text"," para substituir caracteres dentro de um texto. No "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.core"]],["text"," também temos uma função "],["monospaced",["text","replace"]],["text",", mas ela não faz necessariamente o que estamos esperando."],["br"]],["code","clojure",["br"],["code-text","(replace \"eu sou ráquer\" \"e\" \"3\")"],["br"],["code-text","; ArityException Wrong number of args (3) passed to:"],["br"],["code-text",";   core/replace  clojure.lang.AFn.throwArity (AFn."],["br"],["code-text",";   java:429)"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos ver o que essa função "],["monospaced",["text","replace"]],["text"," faz."],["br"]],["code","clojure",["br"],["code-text","(doc replace)"],["br"],["code-text","; -------------------------"],["br"],["code-text","; clojure.core/replace"],["br"],["code-text","; ([smap coll])"],["br"],["code-text",";   Given a map of replacement pairs and a vector/collection,"],["br"],["code-text","; returns a vector/seq with any elements = a key in smap"],["br"],["code-text","; replaced with the corresponding val in smap"],["br"]],["paragraph",["br"]],["paragraph",["text","Traduzindo, a função "],["monospaced",["text","clojure.core/replace"]],["text"," espera receber como parâmetros um mapa com os valores a serem substituidos e uma coleção onde a substituição será executada."],["br"]],["paragraph",["text","Vamos passar um mapa substituindo os caracteres que encontrarmos com os equivalentes "],["monospaced",["text","1337"]],["text",". Existem muito mais combinações, mas para o que precisamos isso vai ser suficiente."],["br"]],["code","clojure",["br"],["code-text","user=> (replace {\\a \\4, \\e \\3, \\l \\1, \\o \\0} \"eu sou raquer\")"],["br"],["code-text","; (\\3 \\u \\space \\s \\0 \\u \\space \\r \\4 \\q \\u \\3 \\r)"],["br"]],["paragraph",["br"]],["paragraph",["text","Podemos converter a lista que obtivemos como resultado de volta para a forma de texto."],["br"]],["code","clojure",["br"],["code-text","(->> \"eu sou raquer\""],["br"],["code-text","     (replace {\\a \\4, \\e \\3, \\l \\1, \\o \\0})"],["br"],["code-text","     (apply str))"],["br"],["code-text","; \"3u s0u r4qu3r\""],["br"]],["paragraph",["br"]],["paragraph",["text","Funciona, mas é feio. Tivemos que passar um mapa, que não é lá a coisa mais legível que você vai encontrar, e depois converter o resultado de volta para texto. Será que existe uma forma mais simples de resolvermos isso?"],["br"]],["index",["text","clojure.string/replace"]],["paragraph",["br"]],["paragraph",["text","Existe sim, dentro do "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.string"]],["text",". O problema é que a função também se chama "],["monospaced",["text","replace"]],["text",", então temos que lançar mão de uma das diferentes formas de utilizá-la sem que isso crie uma bagunça no nosso código."],["br"]],["paragraph",["text","A forma básica de utilizarmos a função é usarmos seu nome completo."],["br"]],["code","clojure",["br"],["code-text","(clojure.string/replace \"eu sou raquer\" \\e \\3)"],["br"],["code-text","; \"3u sou raqu3r\""],["br"]],["paragraph",["br"]],["paragraph",["text","Ficou melhor, já que agora trabalhamos com texto o tempo todo."],["br"]],["paragraph",["text","Para substituirmos as quatro combinações, podemos fazer da seguinte forma:"],["br"]],["code","clojure",["br"],["code-text","(-> \"eu sou raquer\""],["br"],["code-text","    (clojure.string/replace \\a \\4)"],["br"],["code-text","    (clojure.string/replace \\e \\3)"],["br"],["code-text","    (clojure.string/replace \\l \\1)"],["br"],["code-text","    (clojure.string/replace \\o \\0))"],["br"],["code-text","; \"3u s0u r4qu3r\""],["br"]],["paragraph",["br"]],["paragraph",["text","Agora o problema aqui é termos que escrever "],["monospaced",["text","clojure.string/replace"]],["text"," a cada nova combinação."],["br"]],["paragraph",["text","E se fizermos o "],["italic",["text","var"]],["text"," "],["monospaced",["text","replace"]],["text"," apontar para "],["monospaced",["text","clojure.string/replace"]],["text"," ao invés de "],["monospaced",["text","clojure.core/replace"]],["text","?"],["br"]],["index",["text","ns :use"]],["paragraph",["br"]],["paragraph",["text","Vamos usar então a opção "],["monospaced",["text",":use"]],["text"," no operador "],["monospaced",["text","ns"]],["text"," para referenciarmos as funções de "],["monospaced",["text","clojure.string"]],["text"," em nosso namespace."],["br"]],["code","clojure",["br"],["code-text","; Reinicie o REPL"],["br"],["code-text","`replace"],["br"],["code-text","; clojure.core/replace"],["br"],["code-text","(ns capitulo-06"],["br"],["code-text","   (:use [clojure.string]))"],["br"],["code-text","; WARNING: reverse already refers to: #'clojure.core/reverse"],["br"],["code-text",";   in namespace: capitulo-06, being replaced by: #'clojure."],["br"],["code-text",";   string/reverse"],["br"],["code-text","; WARNING: replace already refers to: #'clojure.core/replace"],["br"],["code-text",";   in namespace: capitulo-06, being replaced by: #'clojure."],["br"],["code-text",";   string/replace"],["br"],["code-text","`replace"],["br"],["code-text","; clojure.string/replace"],["br"]],["paragraph",["br"]],["paragraph",["text","Ops, sobrescrevemos coisas a mais. E ainda por cima temos que conviver com as mensagens de aviso do Clojure."],["br"]],["code","clojure",["br"],["code-text","(-> \"eu sou raquer\""],["br"],["code-text","    (replace \\a \\4)"],["br"],["code-text","    (replace \\e \\3)"],["br"],["code-text","    (replace \\l \\1)"],["br"],["code-text","    (replace \\o \\0))"],["br"],["code-text","; \"3u s0u r4qu3r\""],["br"]],["paragraph",["br"]],["paragraph",["text","Funcionou, mas seu código vai ficar emitindo avisos e sobreescrevendo funções que não precisamos, como aconteceu com "],["monospaced",["text","replace"]],["text","."],["br"]],["index",["text","clojure.core/reverse"]],["paragraph",["br"]],["index",["text","clojure.string/reverse"]],["paragraph",["br"]],["paragraph",["text","Vamos então unir o que aprendemos com "],["monospaced",["text","refer-clojure"]],["text"," e deixar de referenciar as funções "],["monospaced",["text","reverse"]],["text"," e "],["monospaced",["text","replace"]],["text","."],["br"]],["code","clojure",["br"],["code-text","; Reinicie o REPL"],["br"],["code-text","(ns capitulo-06"],["br"],["code-text","   (:refer-clojure :exclude [reverse replace])"],["br"],["code-text","   (:use [clojure.string]))"],["br"],["code-text","; sem nenhuma mensagem de aviso"],["br"],["code-text","(-> \"eu sou raquer\""],["br"],["code-text","    (replace \\a \\4)"],["br"],["code-text","    (replace \\e \\3)"],["br"],["code-text","    (replace \\l \\1)"],["br"],["code-text","    (replace \\o \\0))"],["br"],["code-text","; \"3u s0u r4qu3r\""],["br"]],["paragraph",["br"]],["paragraph",["text","Muito bom, agora não o Clojure não emitiu nenhuma mensagem de aviso e o nosso código funcionou."],["br"]],["paragraph",["text","Mas, pense comigo. Toda vez que você precisar de uma função de um "],["italic",["text","namespace"]],["text"," qualquer você terá que referenciar tudo o que existe nesse "],["italic",["text","namespace"]],["text"," e excluir as funções de mesmo nome de "],["monospaced",["text","clojure.core"]],["text","? Não me parece prático nem inteligente."],["br"]],["paragraph",["text","Primeiro vamos limitar as referências para usarmos apenas a função que precisamos."],["br"]],["code","clojure",["br"],["code-text","; Reinicie o REPL"],["br"],["code-text","(ns capitulo-06"],["br"],["code-text","   (:use [clojure.string :only [replace]]))"],["br"],["code-text","; WARNING: replace already refers to: #'clojure.core/replace"],["br"],["code-text",";   in namespace: capitulo-06, being replaced by: #'clojure."],["br"],["code-text",";   string/replace"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora estamos referenciando apenas a função "],["monospaced",["text","replace"]],["text",", mas o conflito continua."],["br"]],["paragraph",["text","Existem discussões sobre tornar a opção "],["monospaced",["text",":use"]],["text"," obsoleta pelo fato dela, por padrão, referenciar todo o "],["italic",["text","namespace"]],["text"," de uma única vez, causando conflitos de nomes e lentidão. Como o processo de "],["italic",["text","internalizar"]],["text"," os novos "],["italic",["text","vars"]],["text"," não é barato, você pode notar uma lentidão ao iniciar sua aplicação. Já trabalhei em projetos em que "],["monospaced",["text",":use"]],["text"," foi substituido por "],["monospaced",["text",":require"]],["text"," e a aplicação passou a levar muito menos tempo para ser iniciada."],["br"]],["paragraph",["text","Então o leitor mais atento se pergunta, já que a entrada no mapa do "],["italic",["text","namespace"]],["text"," é apenas um apelido, não podemos simplesmente referenciar a função que tem o nome repetido com um apelido diferente?"],["br"]],["paragraph",["text","Felizmente, podemos sim. Vamos fazer isso usando "],["monospaced",["text","replace"]],["text","."],["br"]],["code","clojure",["br"],["code-text","; Reinicie o REPL"],["br"],["code-text","(ns capitulo-06"],["br"],["code-text","   (:use [clojure.string :only [replace]"],["br"],["code-text","                         :rename {replace replace-text}]))"],["br"],["code-text","; sem nenhuma mensagem de aviso"],["br"],["code-text","(-> \"eu sou raquer\""],["br"],["code-text","    (replace-text \\a \\4)"],["br"],["code-text","    (replace-text \\e \\3)"],["br"],["code-text","    (replace-text \\l \\1)"],["br"],["code-text","    (replace-text \\o \\0))"],["br"],["code-text","; \"3u s0u r4qu3r\""],["br"],["code-text","`replace"],["br"],["code-text","; clojure.core/replace"],["br"],["code-text","`replace-text"],["br"],["code-text","; clojure.string/replace"],["br"]],["paragraph",["br"]],["paragraph",["text","A vantagem dessa abordagem é que não precisamos mexer com "],["monospaced",["text",":refer-clojure"]],["text"," e não temos nenhuma mensagem de aviso sujando a saída do código. A desvantagem é que cada programador em cada "],["italic",["text","namespace"]],["text"," pode criar um apelido diferente para uma mesma função, tornando o código mais difícil de entender."],["br"]],["index",["text","ns :require"]],["paragraph",["br"]],["paragraph",["text","Vamos alterar novamente nosso código para usar uma outra opção chamada "],["monospaced",["text",":require"]],["text","."],["br"]],["paragraph",["text","A principal diferença de "],["monospaced",["text",":require"]],["text"," é que os "],["italic",["text","vars"]],["text"," do "],["italic",["text","namespace"]],["text"," que está sendo referenciado não são internalizados por padrão. De quebra, você pode criar um apelido para o namespace, tornando seu código mais expressivo."],["br"]],["paragraph",["text","Vamos aprender a trabalhar das duas formas."],["br"]],["paragraph",["text","Primeiro, vamos substituir "],["monospaced",["text",":use"]],["text"," por "],["monospaced",["text",":require"]],["text"," e vamos receber o mesmo aviso de conflito de nomes."],["br"]],["code","clojure",["br"],["code-text","; Reinicie o REPL"],["br"],["code-text","(ns capitulo-06"],["br"],["code-text","  (:require [clojure.string :refer [replace]]))"],["br"],["code-text","; WARNING: replace already refers to: #'clojure.core/replace"],["br"],["code-text",";  in namespace: capitulo-06, being replaced by: #'clojure."],["br"],["code-text",";  string/replace"],["br"]],["paragraph",["br"]],["paragraph",["text","Perceba que usamos a opção "],["monospaced",["text",":refer"]],["text"," para informar a função que queremos referenciar."],["br"]],["paragraph",["text","Na segunda forma simplesmente atribuimos um apelido a "],["monospaced",["text","clojure.string"]],["text",", resolvendo de uma vez por todas o problema da colisão de nomes."],["br"]],["code","clojure",["br"],["code-text","; Reinicie o REPL"],["br"],["code-text","(ns capitulo-06"],["br"],["code-text","  (:require [clojure.string :as str]))"],["br"],["code-text","; sem nenhuma mensagem de aviso"],["br"],["code-text","(-> \"eu sou raquer\""],["br"],["code-text","    (str/replace \\a \\4)"],["br"],["code-text","    (str/replace \\e \\3)"],["br"],["code-text","    (str/replace \\l \\1)"],["br"],["code-text","    (str/replace \\o \\0))"],["br"],["code-text","; \"3u s0u r4qu3r\""],["br"]],["paragraph",["br"]],["paragraph",["text","Funcionou, não tivemos conflitos de nomes e o código não ficou tão grande quanto no primeiro exemplo. Essa é a forma mais aceita entre os desenvolvedores Clojure, e é a que você vai acabar encontrando em projetos por aí."],["br"]],["paragraph",["text","Para finalizar, vamos usar uma característica da função "],["monospaced",["text","clojure.string/replace"]],["text"," para que ela fique ainda menor. O segundo parâmetro pode ser um caracter, um texto ou uma expressão regular. Vamos usar uma expressão regular para capturar todas as opções de letras que vamos substituir. Já o terceiro parâmetro pode ser um texto ou um mapa, como já vimos em "],["monospaced",["text","clojure.core/replace"]],["text","."],["br"]],["code","clojure",["br"],["code-text","; Reinicie o REPL"],["br"],["code-text","(ns capitulo-06"],["br"],["code-text","  (:require [clojure.string :as str]))"],["br"],["code-text","(str/replace \"eu sou um raquer\""],["br"],["code-text","             #\"a|e|l|o\""],["br"],["code-text","             {\"a\" \"4\", \"e\" \"3\", \"l\" \"1\", \"o\" \"0\"})"],["br"],["code-text","; \"3u s0u um r4qu3r\""],["br"]],["paragraph",["br"]],["paragraph",["text","Pronto. Temos o nosso código sem conflito de nomes, sem a necessidade de informarmos o nome completo do "],["italic",["text","namespace"]],["text"," e ainda por cima transformando o nosso texto em "],["monospaced",["text","1337"]],["text","."],["br"]],["title",["text","Mas é um tal de reiniciar o REPL..."]],["paragraph",["br"]],["paragraph",["text","Quando você usa o operador "],["monospaced",["text","ns"]],["text"," com um "],["italic",["text","namespace"]],["text"," que ainda não existe, ele é criado com o tal mapa contendo os "],["italic",["text","vars"]],["text"," que referenciam funções de outros "],["italic",["text","namespaces"]],["text",". Quando você usa o operador "],["monospaced",["text","ns"]],["text"," pela com um "],["italic",["text","namespace"]],["text"," que já existe, é utilizado o mesmo mapa de referências que também já existe."],["br"]],["paragraph",["text","Se você usou "],["monospaced",["text",":refer-clojure"]],["text"," para deixar de referenciar algum "],["italic",["text","var"]],["text"," da biblioteca padrão, esse "],["italic",["text","var"]],["text"," não vai ser carregado automaticamente e você terá que fazer isso explicitamente."],["br"]],["paragraph",["text","Se você já referenciou um "],["italic",["text","var"]],["text"," e tenta fazer isso de novo com o "],["italic",["text","namespace"]],["text"," que já existe, o Clojure irá lançar uma exceção dizendo que você está fazendo algo que já foi feito antes."],["br"]],["code","clojure",["br"],["code-text","; Reinicie o REPL"],["br"],["code-text","; vamos declarar o namespace a primeira vez"],["br"],["code-text","(ns capitulo-06"],["br"],["code-text","  (:require [clojure.string :refer [replace]]))"],["br"],["code-text","; WARNING: replace already refers to: #'clojure.core/replace"],["br"],["code-text",";  in namespace: capitulo-06, being replaced by: #'clojure."],["br"],["code-text",";  string/replace"],["br"],["code-text","; Sem reiniciar o REPL, vamos declarar o namespace de novo"],["br"],["code-text","(ns capitulo-06"],["br"],["code-text","  (:require [clojure.string :refer [replace]]))"],["br"],["code-text","; IllegalStateException replace already refers to:"],["br"],["code-text","; #'clojure.string/replace in namespace: capitulo-06"],["br"],["code-text","; clojure.lang.Namespace.warnOrFailOnReplace (Namespace.java:88)"],["br"]],["paragraph",["br"]],["paragraph",["text","É esperado que isso aconteça, uma vez que o operador "],["monospaced",["text","ns"]],["text"," deve ser usado apenas uma vez em cada arquivo, logo no início, para que o "],["italic",["text","namespace"]],["text"," seja criado uma única vez."],["br"]],["paragraph",["text","Só que, quando utilizamos o "],["italic",["text","REPL"]],["text",", isso se torna uma limitação um tanto irritante. Muitas vezes precisamos recarregar um "],["italic",["text","namespace"]],["text"," após alterá-lo, e sendo o "],["italic",["text","REPL"]],["text"," um ambiente tão dinâmico, esse tipo de limitação acaba nos atrapalhando."],["br"]],["paragraph",["text","O que fazer então?"],["br"]],["paragraph",["text","Mais uma vez, existe solução para esse problema."],["br"]],["paragraph",["text","Quando estamos trabalhando no "],["italic",["text","REPL"]],["text",", o "],["italic",["text","namespace"]],["text"," deve ser criado apenas uma vez, se ele já não existir, e devemos usar operadores diferentes de "],["monospaced",["text","ns"]],["text"," para fazer referência a funções de outras bibliotecas ou de outros pontos da nossa aplicação."],["br"]],["paragraph",["text","Vamos reescrever nossos exemplos sem ter que reiniciar o REPL e usando "],["monospaced",["text","ns"]],["text"," apenas uma vez."],["br"]],["paragraph",["text","Mas antes, saia do "],["italic",["text","REPL"]],["text"," e entre novamente. Vai ser só dessa vez, eu prometo."],["br"]],["paragraph",["text","Primeiro, vamos criar o "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","capitulo-06"]],["text",". Nada de especial até aqui. Em seguida vamos dar uma olhada na função "],["monospaced",["text","replace"]],["text"," para saber qual está sendo referenciada no momento."],["br"]],["code","clojure",["br"],["code-text","(ns capitulo-06)"],["br"],["code-text","`replace"],["br"],["code-text","; clojure.core/replace"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos referenciar todo o "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.string"]],["text"," em nosso "],["italic",["text","namespace"]],["text"," atual."],["br"]],["code","clojure",["br"],["code-text","(use 'clojure.string)"],["br"],["code-text","; WARNING: reverse already refers to: #'clojure.core/reverse"],["br"],["code-text",";   in namespace: capitulo-06, being replaced by: #'clojure."],["br"],["code-text",";   string/reverse"],["br"],["code-text","; WARNING: replace already refers to: #'clojure.core/replace"],["br"],["code-text",";   in namespace: capitulo-06, being replaced by: #'clojure."],["br"],["code-text",";   string/replace"],["br"]],["paragraph",["br"]],["paragraph",["text","Tivemos aqui a mesma colisão de nomes. Vamos então referenciar apenas a função "],["monospaced",["text","clojure.string/replace"]],["text",", dizendo que não queremos referenciar "],["monospaced",["text","clojure.core/replace"]],["text",", evitando a colisão de nomes."],["br"]],["index",["text","remove-ns"]],["paragraph",["br"]],["paragraph",["text","Ao invés de reiniciarmos o "],["italic",["text","REPL"]],["text",", vamos limpar o "],["italic",["text","namespace"]],["text"," da memória através da função "],["monospaced",["text","remove-ns"]],["text"," e passar para o próximo passo."],["br"]],["code","clojure",["br"],["code-text","; voltamos para o user apenas para"],["br"],["code-text","; evitar um monte de mensagens de erro chatas"],["br"],["code-text","(ns user)"],["br"],["code-text","(remove-ns 'capitulo_06)"],["br"],["code-text","; #<Namespace capitulo-06>"],["br"]],["paragraph",["br"]],["paragraph",["text","Pronto, você tem um "],["italic",["text","REPL"]],["text"," limpinho e pronto para ser bagunçado a vontade."],["br"]],["img",["text","images/capitulo_06/cap06_branch.png \"Cuidado ao apagar o namespace atual\" w=40%"]],["paragraph",["br"]],["paragraph",["text","Então você está acompanhando os exemplos do livro, tudo vai funcionando direitinho e você resolve se levantar um pouco para tomar uma água ou um café. Aí, pensando nas coisas que você acabou de aprender, você se pergunta: "],["italic",["text","\"Peraí, é sério mesmo que eu tenho que excluir todo um namespace só para sumir com uma ou duas referências? Será que Clojure tem tão pouco recurso assim para eu ter que apelar para essa violência toda?\""]],["text","."],["br"]],["index",["text","ns-unmap"]],["paragraph",["br"]],["paragraph",["text","Clojure é paz e amor, você pode resolver as coisas sem violência. Sem violência e com alguma função bacana que resolva nossos problemas."],["br"]],["paragraph",["text","A função da vez se chama "],["monospaced",["text","ns-unmap"]],["text",". Com ela podemos excluir uma referência do mapa do "],["italic",["text","namespace"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(ns capitulo-06)"],["br"],["code-text","`replace"],["br"],["code-text","; clojure.core/replace"],["br"],["code-text","(ns-unmap *ns* (symbol \"replace\"))"],["br"],["code-text","`replace"],["br"],["code-text","; capitulo-06/replace"],["br"]],["paragraph",["br"]],["paragraph",["text","A função "],["monospaced",["text","ns-unmap"]],["text"," recebeu "],["monospaced",["text","*ns*"]],["text",", que contém o "],["italic",["text","namespace"]],["text"," atual e um símbolo contendo o nome da função a ser removida do mapa de referências."],["br"]],["index",["text","require"]],["paragraph",["br"]],["paragraph",["text","Dentro do "],["italic",["text","REPL"]],["text"," não é uma boa utilizar "],["monospaced",["text","ns"]],["text"," num mesmo "],["italic",["text","namespace"]],["text"," mais de uma vez, por todos os motivos que já vimos. Por conta disso existem alternativas para as opções "],["monospaced",["text",":require"]],["text"," e "],["monospaced",["text",":use"]],["text"," que são, respectivamente, "],["monospaced",["text","require"]],["text"," e "],["monospaced",["text","use"]],["text","."],["br"]],["paragraph",["text","Para referenciar o "],["italic",["text","namespace"]],["text",", podemos usar diretamente o operador "],["monospaced",["text","require"]],["text",":"],["br"]],["paragraph",["text","As duas formas a seguir são válidas"],["br"]],["code","clojure",["br"],["code-text","(require '[clojure.string :refer [replace]])"],["br"],["code-text","(require '(clojure [string :refer [split]]))"],["br"]],["paragraph",["br"]],["paragraph",["text","Caso você precise referenciar mais de um "],["italic",["text","namespace"]],["text"," ao mesmo tempo, você pode fazer da seguintes forma:"],["br"]],["code","clojure",["br"],["code-text","(require '(clojure [set :as set]"],["br"],["code-text","                   [string :refer [split]]))"],["br"]],["paragraph",["br"]],["paragraph",["text","Assim você está criando um "],["italic",["text","alias"]],["text"," para "],["monospaced",["text","clojure.set"]],["text"," e está internalizando o método "],["monospaced",["text","split"]],["text"," do "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.string"]],["br"]],["paragraph",["text","Ou caso queira apenas referenciar os "],["italic",["text","namespaces"]],["text",", existem ainda mais formas possíveis."],["br"]],["code","clojure",["br"],["code-text","(require 'clojure.string"],["br"],["code-text","         'clojure.set)"],["br"],["code-text","(require '(clojure string set))"],["br"]],["paragraph",["br"]],["paragraph",["text","Particularmente sou da opinião de que muitas opções sem padronização para fazer exatamente a mesma coisa leva a erros, inconsistência no código e dificuldade em dominar a ferramenta. Escolha uma forma, ou combine com sua equipe qual forma será usada, e se atenha a ela."],["br"]],["paragraph",["text","Caso você altere o conteúdo do seu "],["italic",["text","namespace"]],["text"," atual fora do "],["italic",["text","REPL"]],["text",", você pode recarregá-lo utilizando a opção "],["monospaced",["text",":reload-all"]],["text","."],["br"]],["paragraph",["text","Isso é útil quando você, por exemplo, atualiza o código fonte de uma função, salva o arquivo e quer que essa alteração seja refletida no "],["italic",["text","REPL"]],["text"," sem que seja necessário fechá-lo e abrir de novo. É uma alternativa interessante para quando seu editor de textos não tem uma boa integração com o "],["italic",["text","REPL"]],["text",", como é o caso do "],["italic",["text","Sublime"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(use capitulo-06 :reload-all)"],["br"]],["paragraph",["br"]],["paragraph",["text","Em editores que tem uma boa integração, como é o caso de "],["italic",["text","Emacs"]],["text"," e "],["italic",["text","ViM"]],["text",", você pode simplesmente executar seu código modificado dentro do "],["italic",["text","REPL"]],["text"," e fica tudo certo."],["br"]],["paragraph",["text","Finalmente, você pode ver em detalhes o que está acontecendo ao utilizar a opção "],["monospaced",["text",":verbose"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(require '[clojure.string :as string] :verbose)"],["br"],["code-text","; (clojure.core/in-ns 'capitulo-06)"],["br"],["code-text","; (clojure.core/alias 'string 'clojure.string)"],["br"]],["paragraph",["br"]],["index",["text","in-ns"]],["index",["text","alias"]],["paragraph",["br"]],["paragraph",["text","Nesse exemplo, "],["monospaced",["text","in-ns"]],["text"," informa ao Clojure que o "],["italic",["text","namespace"]],["text"," atual é "],["monospaced",["text","capitulo-06"]],["text",". Em seguida é criado um "],["italic",["text","alias"]],["text",", um apelido, chamado "],["monospaced",["text","string"]],["text"," para o "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.string"]],["text",", que é exatamente o que a opção "],["monospaced",["text",":as"]],["text"," faz."],["br"]],["code","clojure",["br"],["code-text","(use 'clojure.set)"],["br"],["code-text","; (clojure.core/in-ns 'capitulo-06)"],["br"],["code-text","; (clojure.core/refer 'clojure.set)"],["br"]],["paragraph",["br"]],["paragraph",["text","Já nesse exemplo, é usado o operador "],["monospaced",["text","refer"]],["text"," para referenciar todos os "],["italic",["text","vars"]],["text"," públicos do "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.set"]],["text"," para dentro do "],["italic",["text","namespace"]],["text"," atual."],["br"]],["section",["text","Importando código Java"]],["paragraph",["br"]],["paragraph",["text","Para utilizar uma classe já existente do Java na sua aplicação, o funcionamento é bem parecido com o uso de "],["monospaced",["text","require"]],["text","."],["br"]],["paragraph",["text","Considerando que você já tenha adicionado a biblioteca Java no "],["italic",["text","classpath"]],["text"," da sua aplicação, o que é feito geralmente informando-a como dependência no "],["italic",["text","Leiningen"]],["text"," ou no "],["italic",["text","Maven"]],["text",", existem duas formas de informarmos ao Clojure que vamos usar uma classe Java em nosso namespace."],["br"]],["paragraph",["text","Enquanto em Java é permitido utilizar um operador "],["monospaced",["text","*"]],["text"," para fazer referência a todas as classes que estão dentro de um "],["italic",["text","package"]],["text"," específico, no Clojure temos que informar um a um."],["br"]],["code","java",["br"],["code-text","// No Java você faria isso"],["br"],["code-text","import java.sql.*;"],["br"],["code-text","import java.util.*;"],["br"],["code-text","// ou isso"],["br"],["code-text","import java.sql.Connection;"],["br"],["code-text","import java.util.Date;"],["br"],["code-text","import java.util.Calendar;"],["br"]],["paragraph",["br"]],["paragraph",["text","A primeira forma é recomendada no código fonte e utiliza a opção "],["monospaced",["text",":import"]],["text"," no operador "],["monospaced",["text","ns"]],["text","."],["br"]],["code","clojure",["br"],["code-text",";; tanto faz uma forma"],["br"],["code-text","(ns capitulo-06"],["br"],["code-text","  (:import [java.sql Connection]"],["br"],["code-text","           [java.util Date Calendar]))"],["br"],["code-text",";; como outra"],["br"],["code-text","(ns capitulo-06"],["br"],["code-text","  (:import (java.sql Connection)"],["br"],["code-text","           (java.util Date Calendar)))"],["br"],["code-text","(Date.)"],["br"],["code-text","; #inst \"2014-10-23T18:31:59.278-00:00\""],["br"]],["paragraph",["br"]],["index",["text","Instant literals"]],["paragraph",["br"]],["box",["text","Instant literals"],["paragraph",["br"]],["paragraph",["text","Esse "],["monospaced",["text","#inst"]],["text"," antes da data é um "],["italic",["text","instant literal"]],["text",", um recurso adicionado na versão "],["italic",["text","1.4"]],["text"," do Clojure."],["br"]],["paragraph",["text","Sempre que você utilizar "],["monospaced",["text","#inst"]],["text"," seguido de uma data em formato texto, o próprio "],["italic",["text","reader"]],["text"," do Clojure vai transformar para o tipo "],["monospaced",["text","java.util.Date"]],["text","."],["br"]],["code","clojure",["br"],["code-text","#inst \"2014-10-23T12:00\""],["br"],["code-text","; #inst \"2014-10-23T12:00:00.000-00:00\""],["br"],["code-text","(type #inst \"2014-10-23T12:00\")"],["br"],["code-text","; java.util.Date"],["br"]],["paragraph",["br"]]],["paragraph",["br"]],["index",["text","import"]],["paragraph",["br"]],["paragraph",["text","A outra forma é recomendada para o uso dentro do "],["italic",["text","REPL"]],["text",", e não é uma boa prática para se adicionar no código fonte da sua aplicação, consiste em utilizar o operador "],["monospaced",["text","import"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(import '(java.sql Connection)"],["br"],["code-text","        '(java.util Date Calendar)))"],["br"]],["paragraph",["br"]],["paragraph",["text","É possível também referenciar classes do Java sem utilizar a opção "],["monospaced",["text",":import"]],["text",", mas você terá que usar o nome qualificado da classe para isso."],["br"]],["code","clojure",["br"],["code-text","(java.util.Calendar/getInstance)"],["br"],["code-text","; #inst \"2014-10-24T00:06:33.145-02:00\""],["br"]],["paragraph",["br"]],["paragraph",["text","O mesmo acontece se você utilizar o nome qualificado de uma função ao invés de referenciar seu namespace com "],["monospaced",["text","require"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(clojure.string/split \"Sabe, tchurururu\" #\" \")"],["br"],["code-text","; [\"Sabe,\" \"tchurururu\"]"],["br"]],["paragraph",["br"]],["section",["text","Funções públicas e privadas"]],["paragraph",["br"]],["paragraph",["text","No capítulo "],["ref-label",["text","capitulo-funcoes"]],["text"," nós aprendemos a criar uma função utilizando o operador "],["monospaced",["text","defn"]],["text","."],["br"]],["paragraph",["text","Toda função criada com "],["monospaced",["text","defn"]],["text"," ou "],["italic",["text","var"]],["text"," criado com "],["monospaced",["text","def"]],["text"," fica visível ao referenciarmos o "],["italic",["text","namespace"]],["text"," onde ela se encontra."],["br"]],["paragraph",["text","O problema é que é bem comum criarmos funções auxiliares ou "],["italic",["text","vars"]],["text"," contendo valores que devem ser acessadas apenas dentro do próprio "],["italic",["text","namespace"]],["text","."],["br"]],["paragraph",["text","Para evitar o uso indiscriminado dessas funções auxiliares, que deveriam ficar escondidas do resto do sistema, ou de valores armazenados em "],["italic",["text","vars"]],["text"," que não devem ser modificados em outros lugares da aplicação, existe a possibilidade de criarmos membros privados."],["br"]],["paragraph",["text","O conceito de "],["italic",["text","privacidade"]],["text"," no Clojure é tão estrito quanto no Java, onde você só pode acessar um membro privado de outra classe através de introspecção e metaprogramação"],["ref",["text","jvm8-spec"]],["text","."],["br"]],["paragraph",["text","Quando você marca um membro como privado, você está sinalizando ao Clojure que aquele "],["italic",["text","var"]],["text"," ou função não deve ser referenciado ou executado por outro "],["italic",["text","namespace"]],["text","."],["br"]],["title",["text","O Pensador Profundo"]],["paragraph",["br"]],["paragraph",["text","O escritor Douglas Adams, no obrigatório "],["italic",["text","Guia do Mochileiro das Galáxias"]],["ref",["text","thhgttg"]],["text",", conta a história de seres ultrainteligentes que criaram um computador que calculasse "],["italic",["text","A Resposta para a Questão Fundamental sobre a Vida, o Universo e Tudo o Mais"]],["text","."],["br"]],["paragraph",["text","Esse computador, do tamanho de uma cidade pequena, foi batizado de "],["italic",["text","Pensador Profundo"]],["text"," e, ao ser ativado, pediu sete milhões e meio de anos para pensar. Passado esse tempo, para surpresa geral, o "],["italic",["text","Pensador Profundo"]],["text"," apresentou a Resposta como sendo "],["italic",["text","42"]],["text","."],["br"]],["paragraph",["text","Para quem não estava envolvido na criação do superultracomputador, não é relevante como ele chegou à resposta nem como ele funciona por dentro. A mesma ideia se aplica quando resolvemos "],["italic",["text","esconder"]],["text"," funções ou valores dentro de um namespace."],["br"]],["paragraph",["text","Vamos criar um "],["italic",["text","namespace"]],["text"," para simular o processamento do Pensador Profundo. Ao invés de esperarmos sete milhões e meio de anos, vamos acelerar um pouco e esperar apenas dois segundos. Esse "],["italic",["text","namespace"]],["text"," vai se chamar "],["monospaced",["text","pensador-profundo"]],["text","."],["br"]],["paragraph",["text","Vamos criar um "],["italic",["text","var"]],["text"," privado contendo um valor numérico. Para marcarmos um "],["italic",["text","var"]],["text"," como privado, precisamos utilizar metadados, já que não existe um "],["monospaced",["text","def-"]],["text"," na biblioteca padrão do Clojure."],["br"]],["code","clojure",["br"],["code-text","(ns pensador-profundo)"],["br"],["code-text","(def ^:private vinte-e-um 21)"],["br"]],["paragraph",["br"]],["paragraph",["text","O metadado "],["monospaced",["text","^:private"]],["text"," é a forma curta para "],["monospaced",["text","^{:private true}"]],["text",". Prefira a forma curta."],["br"]],["index",["text","defn"]],["paragraph",["br"]],["index",["text","defn-"]],["paragraph",["br"]],["paragraph",["text","Vamos criar também uma função privada chamada "],["monospaced",["text","dobro"]],["text",", e para isso vamos usar a forma "],["monospaced",["text","defn-"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn- dobro [valor] (* 2 valor))"],["br"]],["paragraph",["br"]],["paragraph",["text","Finalmente, vamos criar a função que calcula a Resposta Para a Pergunta Fundamental, em maiúsculas mesmo, porque a coisa é séria."],["br"]],["code","clojure",["br"],["code-text","(defn a-resposta []"],["br"],["code-text","  (Thread/sleep 2000)"],["br"],["code-text","  (dobro vinte-e-um))"],["br"],["code-text","(a-resposta)"],["br"],["code-text","; 42"],["br"]],["paragraph",["br"]],["paragraph",["text","Perceba que "],["monospaced",["text","a-resposta"]],["text"," foi declarada usando "],["monospaced",["text","defn"]],["text",", sem hífen, e trata-se de uma função pública. A função privada "],["monospaced",["text","dobro"]],["text"," foi declarada através de "],["monospaced",["text","defn-"]],["text",", com hífen."],["br"]],["paragraph",["text","Agora nós temos um "],["italic",["text","namespace"]],["text"," chamado "],["monospaced",["text","pensador-profundo"]],["text"," com dois membros privados, o "],["italic",["text","var"]],["text"," "],["monospaced",["text","vinte-e-um"]],["text"," e a função "],["monospaced",["text","dobro"]],["text",", e um membro público."],["br"]],["paragraph",["text","Vamos voltar ao nosso velho conhecido "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","capitulo-06"]],["text"," para podermos utilizar a biblioteca do Pensador Profundo."],["br"]],["code","clojure",["br"],["code-text","(ns capitulo-06"],["br"],["code-text","  (:require [pensador-profundo [:as pp]]))"],["br"],["code-text","(println \"A resposta fundamental é\" (pp/a-resposta))"],["br"],["code-text","; A resposta fundamental é 42"],["br"]],["paragraph",["br"]],["paragraph",["text","Até aqui não vimos nenhuma novidade. Referenciamos o "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","pensador-profundo"]],["text"," e o chamamos de "],["monospaced",["text","pp"]],["text",". Então chamamos a função "],["monospaced",["text","a-resposta"]],["text"," e exibimos a mensagem na tela."],["br"]],["paragraph",["text","Porém, se tentarmos forçar a barra e exibir os membros "],["monospaced",["text","vinte-e-um"]],["text"," e "],["monospaced",["text","dobro"]],["text",", seremos presenteados com uma simpática e informativa mensagem de erro:"],["br"]],["code","clojure",["br"],["code-text","pp/vinte-e-um"],["br"],["code-text","; CompilerException java.lang.IllegalStateException:"],["br"],["code-text",";  var: pp/vinte-e-um is not public,"],["br"],["code-text","; compiling:(NO_SOURCE_PATH:0:0)"],["br"],["code-text","(pp/dobro)"],["br"],["code-text","; CompilerExcption java.lang.IllegalStateException:"],["br"],["code-text",";  var: #'pensador-profundo/dobro is not public,"],["br"],["code-text",";  compiling:(NO_SOURCE_PATH:1:1)"],["br"]],["paragraph",["br"]],["paragraph",["text","Perceba que a mensagem não diz que "],["monospaced",["text","vinte-e-um"]],["text"," e "],["monospaced",["text","dobro"]],["text"," não existem, mas sim que eles não são públicos."],["br"]],["paragraph",["text","Mesmo que você informe o nome qualificado do membro, a mensagem será a mesma."],["br"]],["code","clojure",["br"],["code-text","pensador-profundo/vinte-e-um"],["br"],["code-text","; blablabla pensador-profundo/vinte-e-um is not public, etc etc"],["br"]],["paragraph",["br"]],["section",["text","Juntando tudo num projeto"]],["paragraph",["br"]],["paragraph",["text","Vamos aproveitar a oportunidade e encerrar o capítulo de uma forma bem interessante. Vamos desenvolver um pequeno projeto, do início ao fim, utilizando tudo o que aprendemos até aqui."],["br"]],["paragraph",["text","Vamos criar uma pequena aplicação que retorna a documentação dos membros do "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.core"]],["text"," e vamos chamá-la de "],["monospaced",["text","cljhelp"]],["text","."],["br"]],["paragraph",["text","Para isso, vamos utilizar quatro "],["italic",["text","namespaces"]],["text",". O principal, chamado "],["monospaced",["text","cljhelp.core"]],["text",", contém a função "],["monospaced",["text","-main"]],["text",", executada ao iniciarmos a aplicação, e também vai invocar as funções dos demais "],["italic",["text","namespaces"]],["text","."],["br"]],["paragraph",["text","A ideia é que somente este "],["italic",["text","namespace"]],["text"," tenha conhecimento dos demais, fazendo com que a nossa aplicação tenha baixo acoplamento, permitindo que possamos substituir toda a implementação de um "],["italic",["text","namespace"]],["text"," sem afetar o restante da aplicação, desde que a parte pública do "],["italic",["text","namespace"]],["text"," alterado não seja modificada."],["br"]],["paragraph",["text","Os outros três "],["italic",["text","namespaces"]],["text"," vão cuidar de áreas bem específicas da aplicação. É interessante que você agrupe as funções de acordo com suas utilidades e responsabilidades. São eles:"],["br"]],["list",["br"],["text","  * "],["monospaced",["text","cljhelp.ns-data"]],["text"," é responsável por extrair a documentação dos membros de "],["monospaced",["text","clojure.core"]],["text"," e nos retornar as informações como uma estrutura de dados. Assim podemos fazer o que bem entender com os dados que são retornados."],["br"],["text","  * "],["monospaced",["text","cljhelp.db"]],["text"," é responsável pela emulação de um banco de dados onde a documentação de cada membro pode ser incluída e acessada. Tente implementar também formas de atualizar os dados e excluir informação."],["br"],["text","  * "],["monospaced",["text","cljhelp.ui"]],["text"," é responsável pela interface com o usuário. No nosso exemplo usaremos apenas texto, mas fique a vontade para melhorar a interface da forma que achar melhor."],["br"]],["paragraph",["br"]],["paragraph",["text","Primeiro vamos criar o projeto "],["monospaced",["text","cljhelp"]],["text"," através do comando "],["monospaced",["text","lein new"]],["text"," na linha de comando do seu sistema operacional preferido."],["br"]],["code","clojure",["br"],["code-text","lein new app cljhelp"],["br"]],["paragraph",["br"]],["paragraph",["text","Dessa vez estamos utilizando uma opção nova antes do nome da aplicação. Esse "],["monospaced",["text","app"]],["text"," é um "],["italic",["text","template"]],["text",", uma receita pronta, para criarmos uma aplicação com Clojure. Dessa forma o próprio "],["italic",["text","Leiningen"]],["text"," cria uma função "],["monospaced",["text","-main"]],["text"," e adiciona as configurações necessárias no arquivo "],["monospaced",["text","project.clj"]],["text"," para que nossa aplicação seja executável. Experimente editá-lo para ver as opções que foram adicionadas."],["br"]],["title",["text","Extraindo os dados"]],["paragraph",["br"]],["paragraph",["text","O primeiro passo da aplicação é extrair o texto de documentação de cada "],["italic",["text","var"]],["text"," público de "],["monospaced",["text","clojure.core"]],["text",". Em seguida vamos retornar toda essa documentação em uma "],["italic",["text","lazy sequence"]],["text",", que será gravada num "],["italic",["text","banco de dados"]],["text","."],["br"]],["paragraph",["text","Bom, não um banco de dados de verdade, mas um arremedo de banco em memória que vai nos fornecer operações básicas como gravar e pesquisar. Fica como desafio a você aumentar a quantidade de recursos dessa nossa tentativa de banco."],["br"]],["paragraph",["text","A parte de extração dos dados vai ficar dentro do namespace "],["monospaced",["text","cljhelp.ns-data"]],["text",". O nome "],["monospaced",["text","ns-data"]],["text"," foi escolhido por indicar que estamos lidando com os "],["italic",["text","dados do namespace"]],["text",", e também porque eu quis colocar esse separador "],["monospaced",["text","-"]],["text"," de propósito, para aprendermos uma pegadinha do Clojure."],["br"]],["paragraph",["text","Dentro do diretório "],["monospaced",["text","src/cljhelp"]],["text"," da nossa aplicação, vamos criar um arquivo chamado "],["monospaced",["text","ns_data.clj"]],["text"," e vamos declarar o "],["italic",["text","namespace"]],["text"," da forma a seguir:"],["br"]],["code","clojure",["br"],["code-text","(ns cljhelp.ns-data)"],["br"]],["paragraph",["br"]],["paragraph",["text","Note as partes do nome do "],["italic",["text","namespace"]],["text",". Temos um diretório "],["monospaced",["text","src"]],["text",", que é o diretório raiz de todo o nosso código fonte, e dentro dele temos um diretório "],["monospaced",["text","cljhelp"]],["text",", que não por coincidência é o nome do nosso projeto. Todos os arquivos contendo os "],["italic",["text","namespaces"]],["text"," de nossa aplicação ficarão dentro deste diretório."],["br"]],["paragraph",["text","Então criamos um arquivo chamado "],["monospaced",["text","ns_data.clj"]],["text",", com o sinal de "],["italic",["text","underscore"]],["text"," ao invés de um hífen, contendo o "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","ns-data"]],["text",", com hífen."],["br"]],["paragraph",["text","Eis a pegadinha: nomes de arquivo usam "],["italic",["text","underscore"]],["text",", enquanto "],["italic",["text","namespaces"]],["text"," usam hífen. Se você se confundir e trocar, a aplicação não vai compilar."],["br"]],["paragraph",["text","Caso você nomeie o arquivo como "],["monospaced",["text","ns-data.clj"]],["text",", vai receber uma mensagem de erro parecida com essa:"],["br"]],["code",["br"],["code-text","Exception in thread \"main\" java.io.FileNotFoundException:"],["br"],["code-text","Could not locate cljhelp/ns_data__init.class or"],["br"],["code-text","cljhelp/ns_data.clj on classpath: , compiling:(cljhelp/core.clj:"],["br"],["code-text","1:1)"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que o próprio Clojure dá a dica do nome do arquivo que está sendo esperado e não foi encontrado."],["br"]],["box",["text","Não tenha medo de ler as mensagens de erro"],["paragraph",["br"]],["paragraph",["text","Quando você estiver usando a linguagem na selva de um projeto real, com toda aquela pressão aumentando e o tempo acabando, elas podem ser suas únicas amigas."],["br"]],["paragraph",["text","Isso serve não só para o Clojure, mas para qualquer outra ferramenta que você use."],["br"]]],["paragraph",["br"]],["paragraph",["text","Vamos escrever o código no "],["italic",["text","REPL"]],["text"," para testar passo a passo o que nossa função de extração de documentação faz."],["br"]],["index",["text","ns-publics"]],["paragraph",["br"]],["paragraph",["text","Vamos começar usando a função "],["monospaced",["text","ns-publics"]],["text"," para extrair todos os "],["italic",["text","vars"]],["text"," públicos de um determinado "],["italic",["text","namespace"]],["text",". O "],["italic",["text","namespace"]],["text"," deve ser passado usando o operador "],["italic",["text","quote"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(ns-publics 'clojure.core)"],["br"],["code-text","; {primitives-classnames #'clojure.core/primitives-classnames,"],["br"],["code-text","; +' #'clojure.core/+', decimal? #'clojure.core/decimal?,"],["br"],["code-text","; restart-agent #'clojure.core/restart-agent,"],["br"],["code-text","; ... vários outros membros ..."],["br"],["code-text","; refer-clojure #'clojure.core/refer-clojure}"],["br"]],["paragraph",["br"]],["paragraph",["text","Perceba que "],["monospaced",["text","ns-publics"]],["text"," nos retornou um "],["italic",["text","hashmap"]],["text"," contendo pares de símbolos e "],["italic",["text","vars"]],["text","."],["br"]],["paragraph",["text","Vamos nos aproveitar disso e utilizar os símbolos como identificador de registro no nosso banco de dados, e também para acessar os "],["italic",["text","vars"]],["text"," retornados por "],["monospaced",["text","ns-publics"]],["text",". Para extrair as chaves de cada par chave-valor, vamos usar a função "],["monospaced",["text","keys"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(let [vars (ns-publics 'clojure.core)"],["br"],["code-text","      ks   (keys vars)]"],["br"],["code-text","  ks)"],["br"],["code-text","; (primitives-classnames +' decimal? restart-agent sort-by macro"],["br"],["code-text","; ... centenas de itens ..."],["br"],["code-text","; fnext denominator bytes refer-clojure)"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora temos uma lista com centenas de símbolos em "],["monospaced",["text","ks"]],["text",". Cada símbolo equivale ao nome do "],["italic",["text","var"]],["text"," contido em "],["monospaced",["text","clojure.core"]],["text"," e vai servir como item a ser pesquisado quando o usuário quiser ler a documentação de qualquer função desse "],["italic",["text","namespace"]],["text","."],["br"]],["paragraph",["text","Vamos agora utilizar "],["monospaced",["text","for"]],["text"," para retornarmos uma "],["italic",["text","lazy sequence"]],["text"," que vai conter "],["italic",["text","hashmaps"]],["text"," formados por "],["monospaced",["text",":id"]],["text",", que será o identificador do registro, e "],["monospaced",["text",":doc"]],["text",", que vai armazenar o texto contendo a documentação."],["br"]],["paragraph",["text","Vamos guardar esse código dentro de uma função chamada "],["monospaced",["text","extract-doc"]],["text",", que vai justamente extrair a documentação."],["br"]],["code","clojure",["br"],["code-text","(defn extract-doc []"],["br"],["code-text","  (let [vars (ns-publics 'clojure.core)"],["br"],["code-text","        ks   (keys vars)]"],["br"],["code-text","    (for [k ks]"],["br"],["code-text","      {:id  k,"],["br"],["code-text","       :doc (:doc (meta (k vars)))})))"],["br"]],["paragraph",["br"]],["paragraph",["text","Esse será todo o código do "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","cljhelp.ns-data"]],["text","."],["br"]],["title",["text","Um banco de dados simplificado"]],["paragraph",["br"]],["paragraph",["text","Vamos agora criar um arquivo chamado "],["monospaced",["text","db.clj"]],["text"," no diretório "],["monospaced",["text","src/cljhelp"]],["text",". Vamos chamar esse "],["italic",["text","namespace"]],["text"," de "],["monospaced",["text","cljhelp.db"]],["text","."],["br"]],["paragraph",["text","Vamos criar três funções nesse "],["italic",["text","namespace"]],["text",". Uma para inserir os dados, que vamos chamar de "],["monospaced",["text","insert!"]],["text",", uma para contar a quantidade de registros, que vamos chamar de "],["monospaced",["text","count"]],["text"," e uma para pesquisar a informação que queremos, que vamos chamar de "],["monospaced",["text","search"]],["text","."],["br"]],["paragraph",["text","Como já existe uma função "],["monospaced",["text","count"]],["text"," na biblioteca padrão do Clojure, vamos ter que dizer ao nosso "],["italic",["text","namespace"]],["text"," para ignorar a função padrão, e para isso vamos usar o nosso já conhecido "],["monospaced",["text",":refer-clojure"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(ns cljhelp.db"],["br"],["code-text","  (:refer-clojure :exclude [count]))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos criar um membro privado chamado "],["monospaced",["text","data"]],["text",", que vai conter um "],["italic",["text","hashmap"]],["text"," encapsulado por uma estrutura chamada "],["monospaced",["text","atom"]],["text","."],["br"]],["paragraph",["text","Um "],["monospaced",["text","atom"]],["text"," é uma estrutura que assegura que a informação seja alterada de forma atômica e segura, ou seja, ou toda a alteração é feita e concluída, ou toda a alteração é descartada."],["br"]],["paragraph",["text","Ela nos permite também que os dados não sejam corrompidos quando duas "],["italic",["text","threads"]],["text"," tentarem ler ou alterar os dados ao mesmo tempo."],["br"]],["code","clojure",["br"],["code-text","(def ^:private data (atom {}))"],["br"]],["paragraph",["br"]],["box",["text","Devagar e sempre"],["paragraph",["br"]],["paragraph",["text","Veremos com toda a calma e tranquilidade sobre como manipular dados em ambientes concorrentes, quando duas ou mais "],["italic",["text","threads"]],["text"," estão acessando a mesma informação, no capítulo "],["ref-label",["text","capitulo-concorrencia"]],["text","."],["br"]],["paragraph",["text","Não se preocupe em entender agora como um "],["monospaced",["text","atom"]],["text"," funciona, e não se sinta perdido quanto a isso. Vamos chegar lá."],["br"]]],["paragraph",["br"]],["paragraph",["text","A função "],["monospaced",["text","insert!"]],["text",", como o nome diz, insere um registro em nosso banco improvisado, recebendo como parâmetro um dos itens da "],["italic",["text","lazy sequence"]],["text"," gerada por "],["monospaced",["text","extract-doc"]],["text",". Vamos utilizar "],["italic",["text","destructuring"]],["text",", que já vimos no capítulo "],["ref-label",["text","capitulo-funcoes"]],["text"," para separar os membros do "],["italic",["text","hashmap"]],["text"," em dois "],["italic",["text","bindings"]],["text"," locais."],["br"]],["paragraph",["text","Note que o nome da função termina com um ponto de exclamação. Isso porque estamos alterando um estado global, presente no "],["italic",["text","atom"]],["text"," "],["monospaced",["text","data"]],["text","."],["br"]],["paragraph",["text","Para inserir o registro no nosso "],["italic",["text","atom"]],["text",", vamos usar a função "],["monospaced",["text","swap!"]],["text",". Note que ela também termina com um ponto de exclamação, justamente por alterar um valor global."],["br"]],["paragraph",["text","A função "],["monospaced",["text","swap!"]],["text"," pode parecer confusa num primeiro momento, mas não se preocupe com isso agora. Ela recebe como parâmetros o "],["italic",["text","atom"]],["text"," a ser modificado, a função a ser aplicada no "],["italic",["text","hashmap"]],["text"," contido no "],["italic",["text","atom"]],["text"," e os parâmetros que essa função deve receber."],["br"]],["paragraph",["text","Como vamos associar um novo item ao "],["italic",["text","hashmap"]],["text",", vamos utilizar a função "],["monospaced",["text","assoc"]],["text",", passando os valores de "],["monospaced",["text","id"]],["text"," e "],["monospaced",["text","doc"]],["text"," como parâmetros."],["br"]],["paragraph",["text","Depois de toda essa conversa, nossa função vai ter essa cara:"],["br"]],["index",["text","swap!"]],["index",["text","assoc"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(defn insert! [{id :id doc :doc}]"],["br"],["code-text","  (swap! data assoc id doc))"],["br"]],["paragraph",["br"]],["paragraph",["text","Para contar a quantidade de itens em uma coleção não tem segredo. Vamos usar a função "],["monospaced",["text","count"]],["text"," da biblioteca padrão."],["br"]],["paragraph",["text","Como dissemos para nosso "],["italic",["text","namespace"]],["text"," ignorar a função "],["monospaced",["text","count"]],["text"," padrão, teremos que invocá-la usando o nome qualificado."],["br"]],["paragraph",["text","Se você tentar executar a função "],["monospaced",["text","count"]],["text"," diretamente no "],["italic",["text","atom"]],["text",", vai receber uma mensagem de erro:"],["br"]],["code","clojure",["br"],["code-text","(count data)"],["br"],["code-text","; UnsupportedOperationException count not supported on this type"],["br"],["code-text","; Atom"],["br"]],["paragraph",["br"]],["paragraph",["text","Lembre-se que foi dito que o "],["italic",["text","atom"]],["text"," encapsula o "],["italic",["text","hashmap"]],["text",", então não podemos contar a quantidade de itens de um "],["italic",["text","atom"]],["text",", mas sim da estrutura de dados que está contido nele."],["br"]],["index",["text","@"]],["index",["text","deref"]],["paragraph",["br"]],["paragraph",["text","Para isso, vamos usar o operador "],["monospaced",["text","@"]],["text",", conhecido como "],["monospaced",["text","deref"]],["text",", que de maneira segura retorna o valor que está contido no "],["italic",["text","atom"]],["text",". Note que usaremos "],["monospaced",["text","@"]],["text"," toda vez que quisermos acessar o valor do "],["italic",["text","hashmap"]],["text"," que está em "],["monospaced",["text","data"]],["text","."],["br"]],["paragraph",["text","Fechando nossa função "],["monospaced",["text","count"]],["text",", teremos o seguinte código:"],["br"]],["code","clojure",["br"],["code-text","(defn count []"],["br"],["code-text","  (clojure.core/count @data))"],["br"]],["paragraph",["br"]],["paragraph",["text","Uma lida mais atenta vai levantar a seguinte pergunta: "],["italic",["text","mas se a nossa função "],["monospaced",["text","count"]],["text"," apenas invoca a função "],["monospaced",["text","count"]],["text"," padrão da linguagem, por que não usar diretamente a "],["monospaced",["text","count"]],["text"," padrão na nossa aplicação?"]],["br"]],["paragraph",["text","Simples, caro gafanhoto. Para usarmos a função "],["monospaced",["text","count"]],["text"," padrão, precisaríamos ter acesso a "],["monospaced",["text","data"]],["text",", que não poderia ter sido declarado como privado. Isso abriria espaço para que o nosso banco de dados fosse manipulado por fora de nossas funções, rompendo o encapsulamento dos dados."],["br"]],["paragraph",["text","Não estou dizendo aqui que dessa forma seria pior do que a que estou apresentando, mas sim que isso é uma escolha de "],["italic",["text","design"]],["text"," da aplicação. Ao desenvolver suas aplicações, considere os prós e contras de cada maneira de implementar, de acordo com as necessidades do projeto e a experiência profissional da sua equipe."],["br"]],["paragraph",["text","A função "],["monospaced",["text","search"]],["text"," não tem segredo algum. Como o item a ser pesquisado é um "],["italic",["text","symbol"]],["text"," e o parâmetros que vamos receber é do tipo "],["italic",["text","String"]],["text",", basta converter de um tipo para outro e utilizar o próprio retorno de valor do "],["italic",["text","hashmap"]],["text"," para termos o texto da documentação em mãos."],["br"]],["code","clojure",["br"],["code-text","(defn search [item]"],["br"],["code-text","  (@data (symbol item)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Nosso trabalho com os dados acabou por aqui. Agora vamos dar uma olhada rápida na interface com o usuário."],["br"]],["title",["text","A interface com o usuário"]],["paragraph",["br"]],["paragraph",["text","Nossa interface com o usuário vai ser a mais simples possível. Você pode ficar a vontade para incrementá-la ou mesmo adicionar uma interface gráfica."],["br"]],["paragraph",["text","No diretório "],["monospaced",["text","src/cljhelp"]],["text",", vamos criar um arquivo chamado "],["monospaced",["text","ui.clj"]],["text",", onde criaremos nosso "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","ui"]],["text","."],["br"]],["code","clojure",["text"," label=\"ui\""],["br"],["code-text","(ns cljhelp.ui)"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos começar com uma função simples, que limpa a tela. É uma prática interessante para não deixar os dados todos amontoados na tela."],["br"]],["paragraph",["text","Para limpar a tela, vamos imprimir cem linhas em branco, empurrando o texto anterior para fora da parte visível. Podem ser duzentas, ou podem ser cinquenta, ficando a seu critério."],["br"]],["code","clojure",["br"],["code-text","(defn- clear-screen []"],["br"],["code-text","  (doseq [x (range 100)]"],["br"],["code-text","    (println)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos precisar de uma tela inicial, com menu, para que o usuário possa escolher se quer pesquisar a documentação de uma função ou sair da aplicação."],["br"]],["paragraph",["text","Vamos manter duas opções: "],["italic",["text","1"]],["text"," para pesquisar e "],["italic",["text","2"]],["text"," para sair."],["br"]],["code","clojure",["br"],["code-text","(defn menu []"],["br"],["code-text","  (clear-screen)"],["br"],["code-text","  (println \"Menu principal\")"],["br"],["code-text","  (println \"==============\")"],["br"],["code-text","  (println \"[1] Pesquisar \")"],["br"],["code-text","  (println \"[2] Sair      \"))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos escrever mais duas telas: uma para inserirmos a informação a ser pesquisa e outra que exibe o resultado."],["br"]],["index",["text","print"]],["index",["text","println"]],["paragraph",["br"]],["paragraph",["text","Note que na última linha da função de pesquisa, que vamos chamar de "],["monospaced",["text","search"]],["text",", estamos usando "],["monospaced",["text","print"]],["text"," ao invés de "],["monospaced",["text","println"]],["text",". Isso vai fazer com que o cursor permaneça na mesma linha do texto "],["monospaced",["text","Operador: "]],["text",". A função "],["monospaced",["text","println"]],["text"," faria o cursor pular para a linha seguinte."],["br"]],["code","clojure",["br"],["code-text","(defn search []"],["br"],["code-text","  (clear-screen)"],["br"],["code-text","  (println \"Pesquisar\")"],["br"],["code-text","  (println \"==============\")"],["br"],["code-text","  (print \"Operador: \"))"],["br"],["code-text","(defn result [result]"],["br"],["code-text","  (println result))"],["br"]],["paragraph",["br"]],["paragraph",["text","E temos todas as nossas telas concluídas. Vamos agora escrever o código do "],["italic",["text","namespace"]],["text"," principal, que junta todas as partes e faz a aplicação funcionar."],["br"]],["title",["text","Juntando tudo e executando"]],["paragraph",["br"]],["paragraph",["text","Já existe um arquivo chamado "],["monospaced",["text","core.clj"]],["text"," na nossa aplicação. Ele foi criado pelo próprio "],["italic",["text","Leiningen"]],["text"," ao criarmos o projeto."],["br"]],["paragraph",["text","Apague a função "],["italic",["text","-main"]],["text"," e substitua a declaração do "],["italic",["text","namespace"]],["text"," pelo código abaixo, onde referenciamos os três "],["italic",["text","namespaces"]],["text"," que acabamos de criar."],["br"]],["code","clojure",["br"],["code-text","(ns cljhelp.core"],["br"],["code-text","  (:require [cljhelp.ns-data :as data]"],["br"],["code-text","            [cljhelp.db      :as db]"],["br"],["code-text","            [cljhelp.ui      :as ui]))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos criar uma função privada chamada "],["monospaced",["text","load-data"]],["text",", que vai carregar os dados usando a função "],["monospaced",["text","extract-doc"]],["text"," de um "],["italic",["text","namespace"]],["text"," e inserir no banco de dados usando a função "],["monospaced",["text","insert!"]],["text"," de outro "],["italic",["text","namespace"]],["text","."],["br"]],["paragraph",["text","A "],["italic",["text","lazy sequence"]],["text"," retornada por "],["monospaced",["text","extract-doc"]],["text"," é processada item a item através do operador "],["monospaced",["text","doseq"]],["text","."],["br"]],["paragraph",["text","Após completar a inclusão dos dados, vamos exibir a quantidade de registros inseridos."],["br"]],["code","clojure",["br"],["code-text","(defn- load-data []"],["br"],["code-text","  (doseq [v (data/extract-doc)]"],["br"],["code-text","    (db/insert! v))"],["br"],["code-text","  (println \"Adicionados\" (db/count) \"itens\"))"],["br"]],["paragraph",["br"]],["index",["text","read-line"]],["paragraph",["br"]],["paragraph",["text","Vamos criar uma função "],["monospaced",["text","search"]],["text",", também privada, que lê a opção do usuário através da função "],["monospaced",["text","read-line"]],["text",", pesquisa no banco a documentação do operador desejado e exibe as informações na tela."],["br"]],["paragraph",["text","Note que "],["monospaced",["text","read-line"]],["text"," retorna um valor do tipo "],["monospaced",["text","String"]],["text",", e por isso fizemos a conversão para "],["monospaced",["text","Symbol"]],["text"," dentro da função "],["monospaced",["text","search"]],["text","."],["br"]],["paragraph",["text","Você poderia também fazer com que "],["monospaced",["text","search"]],["text"," recebesse diretamente um "],["monospaced",["text","Symbol"]],["text",", deixando a conversão a cargo de quem for chamar a função."],["br"]],["paragraph",["text","Novamente é uma escolha de design da aplicação e fica a seu critério e da sua equipe."],["br"]],["code","clojure",["br"],["code-text","(defn- search []"],["br"],["code-text","  (ui/search)"],["br"],["code-text","  (let [operator (read-line)"],["br"],["code-text","        doc      (db/search operator)]"],["br"],["code-text","    (ui/result doc)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora precisamos criar a função que invoca o menu e trata a opção escolhida pelo usuário. Vamos deixar o menu dentro de um "],["italic",["text","loop"]],["text"," para que o usuário possa pesquisar quantos itens quiser sem sair da aplicação."],["br"]],["code","clojure",["br"],["code-text","(defn- main-menu []"],["br"],["code-text","  (loop []"],["br"],["code-text","    (ui/menu)"],["br"],["code-text","    (let [op (read-line)]"],["br"],["code-text","      (case op"],["br"],["code-text","        \"1\" (search)"],["br"],["code-text","        \"2\" (println \"Até mais\")"],["br"],["code-text","        :else (println \"Opção inválida\"))"],["br"],["code-text","      (when-not (= op \"2\")"],["br"],["code-text","        (recur)))))"],["br"]],["paragraph",["br"]],["paragraph",["text","Encerrando nossa aplicação, vamos implementar a função "],["monospaced",["text","-main"]],["text"," que, como já vimos, é o ponto inicial da aplicação."],["br"]],["paragraph",["text","O código que restou é bem simples: carregamos os dados em nosso banco e invocamos o menu principal para que o usuário escolha o que fazer."],["br"]],["code","clojure",["br"],["code-text","(defn -main [& args]"],["br"],["code-text","  (load-data)"],["br"],["code-text","  (main-menu))"],["br"]],["paragraph",["br"]],["paragraph",["text","Para executar a aplicação, digite "],["monospaced",["text","lein run"]],["text"," no terminal, dentro do diretório raiz da aplicação, que é onde está o arquivo "],["monospaced",["text","project.clj"]],["text","."],["br"]],["paragraph",["text","A maneira como a aplicação foi modelada permite que você substitua nosso banco de dados improvisado por um banco de dados de verdade sem mexer em mais de um "],["italic",["text","namespace"]],["text","."],["br"]],["index",["text","Martin, Robert"]],["paragraph",["br"]],["index",["text","Princípios SOLID"]],["paragraph",["br"]],["index",["text","Single responsibility principle"]],["paragraph",["br"]],["paragraph",["text","Note que a maioria dos princípios "],["italic",["text","SOLID"]],["text",", de Robert Martin"],["ref",["text","uncle-bob"]],["text",", também se aplicam à programação funcional. Aqui, por exemplo, utilizamos o "],["italic",["text","Single responsibility principle"]],["ref",["text","uncle-bob-srp"]],["text"," que, adaptando ao nosso contexto, diz que função, classe ou "],["italic",["text","namespace"]],["text"," deve definir uma única responsabilidade e ter apenas um motivo para ser alterado. Na prática isso significa que cada função deve fazer bem uma e somente uma coisa, e que os "],["italic",["text","namespaces"]],["text"," devem agregar as funções que cuidem de uma mesma responsabilidade."],["br"]],["paragraph",["text","É por isso que temos um "],["italic",["text","namespace"]],["text"," só para a interface com o usuário, outra só para o banco de dados e uma, com apenas uma função, que trata somente da extração das informações."],["br"]],["paragraph",["text","Ao contrário do que possa parecer, as boas práticas utilizadas na Programação Orientada a Objetos e na Programação Funcional não são tão diferentes entre si. Código limpo é sempre bem vindo não importando o paradigma que você esteja utilizando, e "],["italic",["text","namespaces"]],["text"," são uma boa ferramenta para chegarmos a esse objetivo."]]]