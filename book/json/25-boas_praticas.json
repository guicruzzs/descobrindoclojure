["document",["chapter",["text"," Dicas para um bom desenvolvimento em Clojure"]],["paragraph",["br"]],["quote",["text","\"Remember, good code is like a good joke: It needs no explanation.\" "],["text","  -- Russ Olsen"]],["paragraph",["br"]],["section",["text","Respeitando as convenções"]],["paragraph",["br"]],["paragraph",["text","Algumas linguagens como Java"],["ref",["text","java-code-conventions"]],["text"," e C#"],["ref",["text","csharp-code-conventions"]],["text"," têm guias de estilo pré-definidos e bem claros para toda a comunidade. Clojure não tem um guia escrito pelo criador da linguagem nem por alguma empresa que porventura detenha seus direitos, mas podemos nos basear em iniciativas da comunidade e em livros que são consideradas referências fundamentais."],["br"]],["paragraph",["text","Uma fonte importante para ficarmos por dentro das convenções utilizadas é o Clojure Style Guide, uma compilação feita pela comunidade e organizada por Bozhidar Batsov. Você pode encontrar esse guia no endereço:"],["br"]],["paragraph",["text","https://github.com/bbatsov/clojure-style-guide"],["br"]],["paragraph",["text","Note que as dicas deste livro são apenas sugestões. Como estamos apenas seguindo e listando aqui as convenções que a maioria da comunidade adota, não faz mal algum seguí-las."],["br"]],["paragraph",["text","Eu pessoalmente recomendo que elas sejam seguidas caso você queira que mais alguém leia o seu código."],["br"]],["paragraph",["text","Os códigos deste livro foram escritos seguindo boa parte das sugestões deste capítulo, além de se apoiar na maneira como o próprio código do Clojure foi escrito. Em alguns casos acabei fugindo de ambos para poder facilitar a apresentação do código no livro."],["br"]],["title",["text","Namespaces"]],["paragraph",["br"]],["paragraph",["text","Recomenda-se que você não utilize namespaces com muitos membros, como acontece no Java. Evite também utilizar namespaces com apenas um membro, já que a classe Java a ser gerada internamente vai cair no "],["italic",["text","default package"]],["text",", sem impossível utilizar esse código por dentro do Java."],["br"]],["paragraph",["text","Dois ou três nomes separados por ponto estão de ótimo tamanho."],["br"]],["code","clojure",["br"],["code-text",";; um nome muito longo"],["br"],["code-text","(ns br.com.casadocodigo.clojure.exemplos.nome-longo)"],["br"],["code-text",";; um nome curto demais"],["br"],["code-text","(ns foo)"],["br"]],["paragraph",["br"]],["title",["text","Funções e variáveis"]],["paragraph",["br"]],["paragraph",["text","Os nomes dados aos "],["italic",["text","bindings"]],["text",", nomes de funções e "],["italic",["text","namespaces"]],["text"," seguem o "],["italic",["text","LISP Case"]],["text",", onde palavras são separadas por "],["monospaced",["text","-"]],["text",". Ao contrário de outros sabores de LISP, em Clojure você usa sempre letras minúsculas."],["br"]],["code","clojure",["br"],["code-text","(def algum-valor 42)"],["br"],["code-text","(defn anos-idade [data-nascimento]"],["br"],["code-text","  ;; código"],["br"],["code-text","  )"],["br"]],["paragraph",["br"]],["title",["text","Predicados"]],["paragraph",["br"]],["paragraph",["text","Predicados são funções que, de acordo com os parâmetros recebidos, retornam "],["monospaced",["text","true"]],["text"," ou "],["monospaced",["text","false"]],["text","."],["br"]],["paragraph",["text","Recomenda-se que um predicado sempre tenha seu nome acompanhado por um ponto de interrogação."],["br"]],["code","clojure",["br"],["code-text","(odd? 3)"],["br"],["code-text","; true"],["br"],["code-text","(even? 5)"],["br"],["code-text","; false"],["br"],["code-text","(multiplo-de-3? 31)"],["br"],["code-text","; false"],["br"]],["paragraph",["br"]],["paragraph",["text","Nunca é demais lembrar, mas não use caracteres acentuados ou cedilha para nomear funções ou "],["italic",["text","bindings"]],["text",". O Clojure até deixa, mas não seria péssimo você ter que ler um código escrito em ideogramas chineses?"],["br"]],["title",["text","Sinalize o efeito colateral"]],["paragraph",["br"]],["paragraph",["text","Funções que causem feito colateral, alterem um estado global ou lidem com mutabilidade devem ser sinalizadas com um ponto de exclamação."],["br"]],["code","clojure",["br"],["code-text","(update-cliente! db cliente)"],["br"],["code-text","(delete-user! user)"],["br"],["code-text","(set! *warn-on-reflection* true)"],["br"]],["paragraph",["br"]],["paragraph",["text","O ponto de exclamação deixa claro que você deve ter atenção ao utilizar essa função."],["br"]],["title",["text","Bindings dinâmicos"]],["paragraph",["br"]],["paragraph",["italic",["text","Bindings"]],["text"," dinâmicos e estados globais mutáveis devem utilizar "],["italic",["text","earmuffs"]],["text",", que são aqueles asteriscos no começo e no final do nome."],["br"]],["code","clojure",["br"],["code-text","*out*"],["br"],["code-text","; #<PrintWriter java.io.PrintWriter@424c31e7>"],["br"],["code-text","*clojure-version*"],["br"],["code-text","; {:major 1, :minor 7, :incremental 0}"],["br"]],["paragraph",["br"]],["paragraph",["text","Os asteriscos também sinalizam que você deve tomar cuidado com aquele valor, pois outros pontos do sistema também vão acessar, e talvez modificar, a mesma informação."],["br"]],["title",["text","Protocols"]],["paragraph",["br"]],["paragraph",["italic",["text","Protocols"]],["text"," irão gerar interfaces Java, então devem seguir as mesmas convenções do Java, sendo a primeira letra de cada palavra em maiúscula e as demais em minúscula. Essa convencão é chamada de "],["italic",["text","Pascal Case"]],["text","."],["br"]],["paragraph",["text","Já os membros do "],["italic",["text","Protocol"]],["text"," seguem a convencão do Clojure, sendo escritas em letras minúsculas e tendo as palavras separadas por hífen."],["br"]],["code","clojure",["br"],["code-text","(defprotocol Telefone"],["br"],["code-text","  (codigo-pais [value] \"Código do país sem o sinal de +\")"],["br"],["code-text","  (codigo-area [value] \"Código de área. DDD no Brasil\")"],["br"],["code-text","  (telefone    [value] \"Número de telefone\")"],["br"],["code-text","  (ramal       [value] \"Ramal se necessário\"))"],["br"]],["paragraph",["br"]],["title",["text","Valores que não serão usados"]],["paragraph",["br"]],["paragraph",["text","É possível atribuir um valor ao símbolo "],["monospaced",["text","_"]],["text"," para demonstrar que ele não será utilizado. Para o compilador, o símbolo "],["monospaced",["text","_"]],["text"," funciona como qualquer outro, sem nada de especial, mas para quem lê o código fica claro que ele deve ser desconsiderado."],["br"]],["code","clojure",["br"],["code-text","(defn cor-sim-cor-nao [& cores]"],["br"],["code-text","  (let [[a _ c _ e _] cores]"],["br"],["code-text","    (println a c e)))"],["br"],["code-text","(cor-sim-cor-nao 1 2 3 4 5 6)"],["br"],["code-text","; 1 3 5"],["br"]],["paragraph",["br"]],["title",["text","Parênteses"]],["paragraph",["br"]],["paragraph",["text","A coisa mais comum para quem está chegando no Clojure é posicionar os parênteses como se fossem as chaves do Java."],["br"]],["code","clojure",["br"],["code-text",";; jeito feio"],["br"],["code-text","(reduce +"],["br"],["code-text","  (filter even? "],["br"],["code-text","    (map #(* % 3) (range 1 11))"],["br"],["code-text","  )"],["br"],["code-text",")"],["br"],["code-text","; 90"],["br"]],["paragraph",["br"]],["paragraph",["text","Por mais que, num primeiro momento, seja mais fácil sabermos qual parenteses fecha qual expressão, existe uma grande quantidade de ferramentas que indicam isso enquanto você digita, não sendo necessário escrever o código como se fosse uma linguagem herdeira do C."],["br"]],["paragraph",["text","Os parênteses devem sempre ser fechados ao mesmo tempo, no final da expressão:"],["br"]],["code","clojure",["br"],["code-text",";; jeito correto"],["br"],["code-text","(reduce +"],["br"],["code-text","  (filter even? "],["br"],["code-text","    (map #(* % 3) (range 1 11))))"],["br"],["code-text","; 90"],["br"]],["paragraph",["br"]],["paragraph",["text","Caso você fique incomodado com uma grande quantidade de parênteses sendo fechados ao mesmo tempo, duas coisas podem ser feitas."],["br"]],["paragraph",["text","A primeira é usar um "],["italic",["text","thread macro"]],["text",", que serve justamente para reduzir a quantidade de parênteses na linguagem."],["br"]],["code","clojure",["br"],["code-text",";; jeito mais limpo"],["br"],["code-text","(->> (range 1 11)"],["br"],["code-text","     (map #(* % 3))"],["br"],["code-text","     (filter even?)"],["br"],["code-text","     (reduce +))"],["br"],["code-text","; 90"],["br"]],["paragraph",["br"]],["paragraph",["text","Caso ainda assim você ache que a expressão está difícil de ler, pode ser um sinal de que você precisa criar funções pequenas e especializadas, que ajudam a limpar o código."],["br"]],["paragraph",["text","Apesar do nosso código já estar legível o suficiente, vamos espremer um pouco mais para deixá-lo mais conciso."],["br"]],["code","clojure",["br"],["code-text","(def um-a-dez (range 1 11))"],["br"],["code-text","(defn vezes-tres [seq] (map #(* % 3) seq))"],["br"],["code-text","(defn filtra-pares [seq] (filter even? seq))"],["br"],["code-text","(defn somatorio [seq] (reduce + seq))"],["br"],["code-text","(->> um-a-dez"],["br"],["code-text","     vezes-tres"],["br"],["code-text","     filtra-pares"],["br"],["code-text","     somatorio)"],["br"],["code-text","; 90"],["br"]],["paragraph",["br"]],["paragraph",["text","Outro hábito comum de quem chega de outras linguagens é o de colocar espaços "],["italic",["text","depois"]],["text"," dos parênteses. Use espaços apenas entre o operador e o operando, e não entre os parênteses e seus itens."],["br"]],["code","clojure",["br"],["code-text",";; Feio"],["br"],["code-text","( map inc ( range 1 11 ) )"],["br"],["code-text",";; Faça assim"],["br"],["code-text","(map inc (range 1 11))"],["br"]],["paragraph",["br"]],["paragraph",["text","Como dizia um grande professor que eu tive, "],["italic",["text","faça o básico e não invente"]],["text","."],["br"]],["title",["text","Indentação"]],["paragraph",["br"]],["paragraph",["text","Use dois espaços de indentação. Não use "],["monospaced",["text","tab"]],["text",". "],["br"]],["code","clojure",["br"],["code-text",";; legal"],["br"],["code-text","(defn soma [a b]"],["br"],["code-text","  (+ a b))"],["br"],["code-text",";; bisonho"],["br"],["code-text","(defn soma [a b]"],["br"],["code-text","        (+ a b))"],["br"]],["paragraph",["br"]],["paragraph",["text","Alinhe os "],["italic",["text","local bindings"]],["text"," um embaixo do outro. Isso ajuda a saber quando você está tratando do mesmo "],["italic",["text","binding"]],["text",", quando estamos tratando de outro e quando o "],["italic",["text","binding"]],["text"," acabou."],["br"]],["code","clojure",["br"],["code-text","(let [idade  5"],["br"],["code-text","      nome   \"Gustavo\""],["br"],["code-text","      sexo   :masculino"],["br"],["code-text","      artigo (if (= sexo :masculino)"],["br"],["code-text","                \"O\""],["br"],["code-text","                \"A\")]"],["br"],["code-text","  (println (str artigo \" \" nome \" tem \" idade \" anos\")))"],["br"],["code-text","; O Gustavo tem 5 anos"],["br"]],["paragraph",["br"]],["title",["text","Declaração de função"]],["paragraph",["br"]],["paragraph",["text","Caso a função tenha apenas uma linha de código, não há problema em declará-la em uma única linha, desde que você ou sua equipe sigam o padrão."],["br"]],["code","clojure",["br"],["code-text",";; está OK"],["br"],["code-text","(defn soma [a b] (+ a b))"],["br"],["code-text",";; está OK também"],["br"],["code-text","(defn mult [a b]"],["br"],["code-text","  (* a b))"],["br"]],["paragraph",["br"]],["paragraph",["text","Quando a função tiver apenas uma aridade, não use parênteses para separar o vetor dos parâmetros. Caso ela tenha mais de uma aridade, é obrigatório usar os parênteses."],["br"]],["code","clojure",["br"],["code-text",";; não está OK"],["br"],["code-text","(defn soma"],["br"],["code-text","  ([a b]"],["br"],["code-text","    (+ a b)))"],["br"],["code-text",";; jeito correto"],["br"],["code-text","(defn soma"],["br"],["code-text","  ([a] a)"],["br"],["code-text","  ([a b] (+ a b))"],["br"],["code-text","  ([a b & c] (apply soma (+ a b) c)))"],["br"],["code-text",";; jeito correto também"],["br"],["code-text","(defn soma"],["br"],["code-text","  ([a] "],["br"],["code-text","    a)"],["br"],["code-text","  ([a b]"],["br"],["code-text","    (+ a b))"],["br"],["code-text","  ([a b & c]"],["br"],["code-text","    (apply soma (+ a b) c)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Apesar de menos comum, pode-se posicionar a lista de parâmetros em outra linha, mesmo que a função não tenha documentação incluída."],["br"]],["code","clojure",["br"],["code-text",";; Feio, mas OK"],["br"],["code-text","(defn soma"],["br"],["code-text","  [a b]"],["br"],["code-text","  (+ a b))"],["br"],["code-text","(defn soma"],["br"],["code-text","  \"Função que soma dois números\""],["br"],["code-text","  [a b]"],["br"],["code-text","  (+ a b))"],["br"]],["paragraph",["br"]],["title",["text","Vírgulas"]],["paragraph",["br"]],["paragraph",["text","Vírgulas são opcionais no Clojure. O compilador os considera como espaços em branco."],["br"]],["paragraph",["text","Entretanto, elas nos ajudam a separar visualmente um item do outro, então acabam sendo úteis em alguns momentos."],["br"]],["paragraph",["text","Não use vírgulas para separar itens de uma lista ou de um vetor, mas está tudo bem se você usar para separar itens de um mapa."],["br"]],["code","clojure",["br"],["code-text",";; Feio"],["br"],["code-text","[1, 2, 3, 4, 5, 6]"],["br"],["code-text",";; Certo"],["br"],["code-text","[1 2 3 4 5 6]"],["br"],["code-text",";; Você não sabe onde começa e onde termina"],["br"],["code-text","{:a :b :c :d :e :f :g :h}"],["br"],["code-text",";; Agora dá para ler"],["br"],["code-text","{:a :b, :c :d, :e :f, :g :h}"],["br"],["code-text",";; Pessoalmente, acho assim bom também"],["br"],["code-text","{:a :b,"],["br"],["code-text"," :c :d,"],["br"],["code-text"," :e :f,"],["br"],["code-text"," :g :h}"],["br"],["code-text",";; Assim está bom também"],["br"],["code-text","{:a :b"],["br"],["code-text"," :c :d"],["br"],["code-text"," :e :f"],["br"],["code-text"," :g :h}"],["br"]],["paragraph",["br"]],["section",["text","Código idiomático"]],["paragraph",["br"]],["paragraph",["text","Escrever código idiomático é quase uma obsessão nas comunidades "],["italic",["text","LISP"]],["text"," e "],["italic",["text","Ruby"]],["text",". Código idiomático, no caso do Clojure, é aquele escrito "],["italic",["text","do jeito Clojure"]],["text","."],["br"]],["paragraph",["text","Por exemplo, por mais que esteja correto dizer determinada frase em Português, não basta simplesmente traduzir palavra por palavra para o Inglês. Pode até ser que alguém entenda o que você quer dizer, mas não é jeito de se dizer naquele idioma. Não é o \"jeito inglês/americano\" de se dizer algo."],["br"]],["paragraph",["text","Em Java, por exemplo, tendo uma lista de clientes, podemos escrever da seguinte forma, de maneira idiomática:"],["br"]],["code","java",["br"],["code-text","for(Cliente cliente : listaClientes) {"],["br"],["code-text","  System.out.println(cliente.getNome());"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["paragraph",["text","Por mais que o Ruby também tenha uma construção "],["monospaced",["text","for"]],["text",", a forma idiomática é usar "],["monospaced",["text","each"]],["text","."],["br"]],["code","ruby",["br"],["code-text","lista_clientes.each {|cliente| puts cliente.nome }"],["br"]],["paragraph",["br"]],["paragraph",["text","Em Clojure também temos as formas \"corretas\" de se escrever código, mesmo que as consideradas não idiomáticas cheguem ao mesmo resultado."],["br"]],["paragraph",["text","É bem possível que a versão Clojure do nosso exemplo seja:"],["br"]],["code","clojure",["br"],["code-text","(doseq [cliente lista-clientes]"],["br"],["code-text","  (println (:nome cliente)))"],["br"]],["paragraph",["br"]],["title",["text","Condicionais"]],["paragraph",["br"]],["index",["text","when"]],["index",["text","if"]],["paragraph",["br"]],["paragraph",["text","Se sua verificação executa algo apenas quando a condição for negativa ou positiva, use "],["monospaced",["text","when"]],["text"," no lugar do "],["monospaced",["text","if"]],["text",". Deixe para você usar o "],["monospaced",["text","if"]],["text"," numa situação onde você também usaria um "],["monospaced",["text","else"]],["text"," em outra linguagem."],["br"]],["code","clojure",["br"],["code-text",";; Quando temos um 'if' sem 'else', usamos when."],["br"],["code-text","(when (ready?)"],["br"],["code-text","  (println \"Preparado\"))"],["br"],["code-text",";; Quando temos um 'if' com 'else', usamos if."],["br"],["code-text","(if (ready?)"],["br"],["code-text","  (println \"Preparado\")"],["br"],["code-text","  (println \"Aguarde\"))"],["br"]],["paragraph",["br"]],["index",["text","if-let"]],["index",["text","if"]],["index",["text","let"]],["index",["text","when-let"]],["paragraph",["br"]],["paragraph",["text","Use "],["monospaced",["text","if-let"]],["text"," invés de encadear "],["monospaced",["text","let"]],["text"," e "],["monospaced",["text","if"]],["text",". A mesma regra se aplica ao "],["monospaced",["text","when"]],["text","."],["br"]],["code","clojure",["br"],["code-text",";; Ao invés de encadear let e if..."],["br"],["code-text","(defn soma-pares [& numeros]"],["br"],["code-text","  (let [pares (seq (filter even? numeros))]"],["br"],["code-text","    (if pares"],["br"],["code-text","      (reduce + pares)"],["br"],["code-text","      \"Nenhum número par\")))"],["br"],["code-text",";; ... use if-let"],["br"],["code-text","(defn soma-pares [& numeros]"],["br"],["code-text","  (if-let [pares (seq (filter even? numeros))]"],["br"],["code-text","    (reduce + pares)"],["br"],["code-text","    \"Nenhum número par\"))"],["br"],["code-text",";; O mesmo se aplica a let e when..."],["br"],["code-text","(defn soma-pares [& numeros]"],["br"],["code-text","  (let [pares (seq (filter even? numeros))]"],["br"],["code-text","    (when pares"],["br"],["code-text","      (reduce + pares))))"],["br"],["code-text",";; ... com when-let fica bem melhor"],["br"],["code-text","(defn soma-pares [& numeros]"],["br"],["code-text","  (when-let [pares (seq (filter even? numeros))]"],["br"],["code-text","    (reduce + pares)))"],["br"]],["paragraph",["br"]],["index",["text","if-not"]],["index",["text","when-not"]],["index",["text","not"]],["paragraph",["br"]],["paragraph",["text","Use "],["monospaced",["text","if-not"]],["text"," ao invés de encadear "],["monospaced",["text","if"]],["text"," e "],["monospaced",["text","not"]],["text",". O mesmo se aplica ao uso de "],["monospaced",["text","when"]],["text"," e "],["monospaced",["text","not"]],["text","."],["br"]],["code","clojure",["br"],["code-text",";; Feio"],["br"],["code-text","(when (not valid)"],["br"],["code-text","  (error-message))"],["br"],["code-text",";; Idiomático"],["br"],["code-text","(when-not valid"],["br"],["code-text","  (error-message))"],["br"],["code-text",";; É feio também"],["br"],["code-text","(if (not valid)"],["br"],["code-text","  (error-message)"],["br"],["code-text","  (ok-message))"],["br"],["code-text",";; Assim é melhor"],["br"],["code-text","(if-not valid"],["br"],["code-text","  (error-message)"],["br"],["code-text","  (ok-message))"],["br"],["code-text",";; Mas usar a cabeça é melhor ainda"],["br"],["code-text","(if valid"],["br"],["code-text","  (ok-message)"],["br"],["code-text","  (error-message))"],["br"]],["paragraph",["br"]],["index",["text","condp"]],["index",["text","cond"]],["paragraph",["br"]],["paragraph",["text","Use "],["monospaced",["text","condp"]],["text"," ao invés de "],["monospaced",["text","cond"]],["text"," quando o "],["italic",["text","binding"]],["text"," a ser comparado não muda."],["br"]],["code","clojure",["br"],["code-text",";; Olha idade se repetindo"],["br"],["code-text","(cond "],["br"],["code-text","  (>= 10 idade) \"Criança\""],["br"],["code-text","  (>= 18 idade) \"Adolescente\""],["br"],["code-text","  (>= 60 idade) \"Adulto\""],["br"],["code-text","  :else \"Idoso\")"],["br"],["code-text",";; Assim fica melhor"],["br"],["code-text","(condp >= idade "],["br"],["code-text","  10 \"Criança\""],["br"],["code-text","  18 \"Adolescente\""],["br"],["code-text","  60 \"Adulto\""],["br"],["code-text","  \"Idoso\")"],["br"]],["paragraph",["br"]],["index",["text","case"]],["paragraph",["br"]],["paragraph",["text","Ou use "],["monospaced",["text","case"]],["text"," no lugar de "],["monospaced",["text","condp"]],["text"," para deixar o código ainda mais simples caso você esteja comparando igualdades."],["br"]],["code","clojure",["br"],["code-text",";; Assim vai bem"],["br"],["code-text","(condp = sinal"],["br"],["code-text","  :vermelho \"Pare!\")"],["br"],["code-text","  :amarelo  \"Atenção\""],["br"],["code-text","  :verde    \"Siga\")"],["br"],["code-text",";; Mas assim fica melhor"],["br"],["code-text","(case sinal"],["br"],["code-text","  :vermelho \"Pare!\")"],["br"],["code-text","  :amarelo  \"Atenção\""],["br"],["code-text","  :verde    \"Siga\")"],["br"]],["paragraph",["br"]],["title",["text","Referenciando outros namespaces"]],["paragraph",["br"]],["index",["text","require"]],["index",["text","import"]],["index",["text","ns"]],["paragraph",["br"]],["paragraph",["text","A menos que você esteja no "],["italic",["text","REPL"]],["text",", não use as formas "],["monospaced",["text","require"]],["text"," e "],["monospaced",["text","import"]],["text",". Prefira usar os parâmetros "],["monospaced",["text",":require"]],["text"," e "],["monospaced",["text",":import"]],["text"," da macro "],["monospaced",["text","ns"]],["text","."],["br"]],["code","clojure",["br"],["code-text",";; Deixe para fazer isso no REPL"],["br"],["code-text","(require '[clojure.string :as str])"],["br"],["code-text","(import '(java.util Date Calendar))"],["br"],["code-text",";; Prefira fazer dessa forma no código"],["br"],["code-text","(ns meu.namespace"],["br"],["code-text","  (:require [clojure.string :as str])"],["br"],["code-text","  (:import  [java.util Date"],["br"],["code-text","                       Calendar]))"],["br"]],["paragraph",["br"]],["paragraph",["text","Use "],["monospaced",["text",":require"]],["text"," no lugar de "],["monospaced",["text",":use"]],["text"," para não sobrecarregar o "],["italic",["text","namespace"]],["text",", deixando a aplicação lenta, e também para não causar conflito de nomes."],["br"]],["code","clojure",["br"],["code-text",";; use deixa a sua aplicação lenta e causa conflitos"],["br"],["code-text","(ns meu.namespace"],["br"],["code-text","  (:use [clojure.string]))"],["br"],["code-text","; WARNING: reverse already refers to: #'clojure.core/reverse "],["br"],["code-text","; in namespace: meu.namespace, being replaced by: "],["br"],["code-text","; #'clojure.string/reverse"],["br"],["code-text","; WARNING: replace already refers to: #'clojure.core/replace"],["br"],["code-text","; in namespace: meu.namespace, being replaced by: "],["br"],["code-text","; #'clojure.string/replace"],["br"],["code-text",";; qual reverse estou usando?"],["br"],["code-text",";; o do clojure.core ou do clojure.string?"],["br"],["code-text","(reverse \"E agora?\")"],["br"],["code-text",";; já o require te dá muito mais controle"],["br"],["code-text","(ns meu.namespace"],["br"],["code-text","  (:require [clojure.string :as str]))"],["br"],["code-text",";; agora eu sei qual estou usando"],["br"],["code-text","(str/reverse \"Agora sim\")"],["br"]],["paragraph",["br"]],["title",["text","Trabalhando com objetos Java"]],["paragraph",["br"]],["index",["text","new"]],["paragraph",["br"]],["paragraph",["text","Apesar do Clojure oferecer a forma "],["monospaced",["text","new"]],["text"," para instanciar objetos, a forma mais "],["italic",["text","LISP"]],["text"," é aceita como sendo a idiomática pela comunidade."],["br"]],["code","clojure",["br"],["code-text",";; funciona, mas não é idiomático"],["br"],["code-text","(new Cliente \"Josivaldo\" 35)"],["br"],["code-text",";; assim tem mais cara de LISP, "],["br"],["code-text",";; por isso é considerado idiomático"],["br"],["code-text","(Client. \"Josivaldo\" 35)"],["br"]],["paragraph",["br"]],["paragraph",["text","O mesmo acontece quando queremos invocar um método de um objeto. O Clojure também oferece duas formas: uma com cara de Java e outra com cara de Clojure. Fique com a que tem cara de Clojure."],["br"]],["code","clojure",["br"],["code-text",";; tem cara de Java"],["br"],["code-text","(. cliente getNome)"],["br"],["code-text",";; prefira essa, usando notação prefixa"],["br"],["code-text","(.getNome cliente)"],["br"]],["paragraph",["br"]],["paragraph",["text","Já ao invocar um método estático, use "],["monospaced",["text","/"]],["text"," para separar a classe do membro."],["br"]],["code","clojure",["br"],["code-text",";; não, não"],["br"],["code-text","(. Calendar getInstance)"],["br"],["code-text",";; assim nem funciona"],["br"],["code-text","(.getInstance Calendar)"],["br"],["code-text",";; use desse jeito"],["br"],["code-text","(Calendar/getInstance)"],["br"]],["paragraph",["br"]],["title",["text","Conheça a ferramenta"]],["paragraph",["br"]],["paragraph",["text","É útil saber como as funções são por dentro. Isso ajuda a evitar que criemos código redundante e mais lento que suas alternativas idiomáticas."],["br"]],["index",["text","empty?"]],["index",["text","seq"]],["paragraph",["br"]],["paragraph",["text","Esse é o caso de "],["monospaced",["text","empty?"]],["text",", que internamente utiliza a função "],["monospaced",["text","seq"]],["text"," para gerar uma sequencia a partir do parâmetro recebido, retornando "],["monospaced",["text","true"]],["text"," caso "],["monospaced",["text","seq"]],["text"," retorne "],["monospaced",["text","nil"]],["text","."],["br"]],["paragraph",["text","Quando você usa "],["monospaced",["text","(not (empty? sequencia))"]],["text",", na verdade você está executando "],["monospaced",["text","(not (not (seq sequencia)))"]],["text","."],["br"]],["index",["text","nil punning"]],["paragraph",["br"]],["paragraph",["text","Ao invés disso, use apenas "],["monospaced",["text","(seq sequencia)"]],["text"," e deixe o "],["italic",["text","nil punning"]],["text"," fazer o resto por você. "],["br"]],["code","clojure",["br"],["code-text",";; redundante"],["br"],["code-text","(if-not (empty? '()) "],["br"],["code-text","  \"Ocupado\""],["br"],["code-text","  \"Vazio\")"],["br"],["code-text","; \"Vazio\""],["br"],["code-text",";; prefira assim"],["br"],["code-text","(if (seq '()) "],["br"],["code-text","  \"Ocupado\""],["br"],["code-text","  \"Vazio\")"],["br"],["code-text","; \"Vazio\""],["br"]],["paragraph",["br"]],["index",["text","and"]],["paragraph",["br"]],["paragraph",["text","As vezes você não precisa usar "],["monospaced",["text","and"]],["text",". Em Clojure os operadores lógicos aceitam mais de dois argumentos."],["br"]],["code","clojure",["br"],["code-text",";; funciona, mas é verboso em excesso"],["br"],["code-text","(and (> idade 18) (< idade 65))"],["br"],["code-text",";; assim fica até mais fácil de entender"],["br"],["code-text","(< 18 idade 65)"],["br"]],["paragraph",["br"]],["index",["text","complement"]],["paragraph",["br"]],["paragraph",["text","Use "],["monospaced",["text","complement"]],["text"," ao invés de criar uma função anônima que inverta o resultado de um predicado."],["br"]],["code","clojure",["br"],["code-text",";; sim, eu sei que existe a função 'odd?'"],["br"],["code-text","(filter #(not (even? %)) (range 1 11))"],["br"],["code-text",";; complement retorna uma função para você"],["br"],["code-text","(filter (complement even?) (range 1 11))"],["br"]],["paragraph",["br"]],["title",["text","Evite repetições"]],["paragraph",["br"]],["paragraph",["text","Quando você encadeia várias funções para processar um valor, pode acontecer de usarmos a mesma função em lugares diferentes. Em alguns casos isso pode ser eliminado se repensarmos a maneira de resolver o problema."],["br"]],["quote",["text","\"Map de map é map, filter de filter é filter.\" "],["text","  -- Eu, durante um "],["italic",["text","code review"]]],["paragraph",["br"]],["paragraph",["text","Por exemplo, evite utilizar mais de um "],["monospaced",["text","map"]],["text"," numa mesma expressão."],["br"]],["paragraph",["text","Um exemplo comum disso acontece em "],["italic",["text","coding dojos"]],["ref",["text","coding-dojo"]],["text"," usando Clojure. Geralmente no primeiro contato com a linguagem é pedido para implementar o "],["italic",["text","FizzBuzz"]],["ref",["text","fizzbuzz"]],["text","."],["br"]],["box",["text","Coding Dojo"],["paragraph",["br"]],["paragraph",["text","Caso você nunca tenha participado de um "],["italic",["text","coding dojo"]],["text",", pesquise a respeito e participe. São eventos muito bons para socializar e se tornar um programador melhor."],["br"]]],["paragraph",["br"]],["paragraph",["text","O primeiro programador criar uma lista de vinte elementos e substitui todos os múltiplos de três e cinco por "],["monospaced",["text","-2"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(map "],["br"],["code-text","  #(if (= 0 (mod % 15)) -2 %) "],["br"],["code-text","  (range 1 21))"],["br"],["code-text","; (1 2 3 4 5 6 7 8 9 10 11 12 13 14 \"Fizz\" 16 17 18 19 20)"],["br"]],["paragraph",["br"]],["paragraph",["text","O segundo programador substitui todos os múltiplos de cinco por "],["italic",["text","Buzz"]],["text",", mantendo o código que foi feito pelo primeiro programador."],["br"]],["code","clojure",["br"],["code-text","(map"],["br"],["code-text","  #(if (and (number? %) "],["br"],["code-text","            (= 0 (mod % 5))) "],["br"],["code-text","       \"Buzz\" "],["br"],["code-text","       %) "],["br"],["code-text","  (map "],["br"],["code-text","    #(if (= 0 (mod % 15)) \"FizzBuzz\" %) "],["br"],["code-text","    (range 1 21)))"],["br"],["code-text","; (1 2 3 4 \"Buzz\" 6 7 8 9 \"Buzz\" "],["br"],["code-text","; 11 12 13 14 \"FizzBuzz\" 16 17 18 19 \"Buzz\")"],["br"]],["paragraph",["br"]],["paragraph",["text","O código está ficando poluído e difícil de entender."],["br"]],["paragraph",["text","Vem o terceiro programador e substitui todos os múltiplos de três por "],["italic",["text","Fizz"]],["text",", mantendo o código que foi escrito até agora."],["br"]],["code","clojure",["br"],["code-text","(map"],["br"],["code-text","  #(if (and (number? %) "],["br"],["code-text","            (= 0 (mod % 3))) "],["br"],["code-text","       \"Fizz\" "],["br"],["code-text","       %) "],["br"],["code-text","  (map"],["br"],["code-text","    #(if (and (number? %) "],["br"],["code-text","              (= 0 (mod % 5))) "],["br"],["code-text","         \"Buzz\" "],["br"],["code-text","         %) "],["br"],["code-text","    (map "],["br"],["code-text","      #(if (= 0 (mod % 15)) \"FizzBuzz\" %) "],["br"],["code-text","      (range 1 21))))"],["br"],["code-text","; (1 2 \"Fizz\" 4 \"Buzz\" \"Fizz\" 7 8 \"Fizz\" \"Buzz\" "],["br"],["code-text",";  11 \"Fizz\" 13 14 \"FizzBuzz\" 16 17 \"Fizz\" 19 \"Buzz\")"],["br"]],["paragraph",["br"]],["paragraph",["text","Tive um professor que sempre dizia que, se o código começa a ficar complicado demais e difícil de ler, você está fazendo algo errado."],["br"]],["paragraph",["text","Dê uma outra olhada no código e perceba que o que fizemos foi encadear três chamadas de "],["monospaced",["text","map"]],["text"," em uma única expressão. Você até pode tentar reescrever o código usando "],["italic",["text","thread macros"]],["text",", mas o problema não está nos parênteses."],["br"]],["paragraph",["text","Quando você aplica "],["monospaced",["text","map"]],["text"," de "],["monospaced",["text","map"]],["text"," em uma sequencia, você está repetindo código desnecessariamente."],["br"]],["paragraph",["text","Se você estiver lidando com "],["italic",["text","lazy sequences"]],["text",", a redundância fica restrita ao "],["italic",["text","chunk"]],["text"," que estiver sendo processado. Porém, se for uma sequencia já avaliada ou um vetor, você terá que executar "],["monospaced",["text","map"]],["text"," três vezes para cada item da lista. Numa lista de mil itens, são três mil execuções."],["br"]],["paragraph",["text","Vamos resolver isso juntando todos as chamadas a "],["monospaced",["text","map"]],["text"," em uma só. Nosso código ficaria com essa cara:"],["br"]],["code","clojure",["br"],["code-text","(map"],["br"],["code-text","  #(cond (= 0 (mod % 15)) \"FizzBuzz\""],["br"],["code-text","         (= 0 (mod % 5))  \"Buzz\""],["br"],["code-text","         (= 0 (mod % 3))  \"Fizz\""],["br"],["code-text","         :else %)"],["br"],["code-text","  (range 1 21))"],["br"],["code-text","; (1 2 \"Fizz\" 4 \"Buzz\" \"Fizz\" 7 8 \"Fizz\" \"Buzz\" "],["br"],["code-text",";  11 \"Fizz\" 13 14 \"FizzBuzz\" 16 17 \"Fizz\" 19 \"Buzz\")"],["br"]],["paragraph",["br"]],["paragraph",["text","Bem mais fácil de ler, não?"],["br"]],["paragraph",["text","O mesmo se aplica se você tiver mais de uma chamada a "],["monospaced",["text","filter"]],["text"," dentro da mesma expressão. Considere unir as condições em um único predicado, fazendo com que "],["monospaced",["text","filter"]],["text"," apareça apenas uma vez."],["br"]],["section",["text","A prática leva à perfeição"]],["paragraph",["br"]],["paragraph",["text","Escrever código funcional e idiomático é questão de treino e prática. Por mais que possa parecer preciosismo por parte da comunidade, sempre existe uma razão para que essa ou aquela forma seja a preferida. Se tiver dúvida, pergunte na lista de discussão oficial ou no Clojure Brasil."],["br"]],["paragraph",["text","Como foi dito, as convenções não são leis que serão punidas quando violadas. Entenda, aprenda e quebre-as quando você ver uma boa razão para isso."]]]