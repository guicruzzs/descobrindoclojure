["document",["chapter",["text"," Estendendo a linguagem com macros"]],["paragraph",["br"]],["label",["text","capitulo-macros"]],["paragraph",["br"]],["index",["text","macros"]],["paragraph",["br"]],["quote",["text","\"As fronteiras de minha linguagem são as fronteiras de meu mundo\""],["text","  -- Ludwig Wittgenstein, filósofo"]],["paragraph",["br"]],["section",["text","Uma linguagem de argila"]],["paragraph",["br"]],["paragraph",["text","Carlinhos era um programador como qualquer outro. Entrava as oito da manhã, saia as cinco da tarde e estava satisfeito programando em Java, como tantos outros profissionais que conhecemos."],["br"]],["paragraph",["text","Numa sexta-feira, um colega de trabalho o apresentou a uma linguagem chamada "],["italic",["text","Ruby"]],["text",", criada por um japonês, e que estava sendo utilizada por um monte de empresas no mercado. Carlinhos resolveu experimentar."],["br"]],["paragraph",["text","Após passar o final de semana brincando com a nova linguagem, Carlinhos voltou ao trabalho e se sentiu incomodado. Alguma coisa estava errada com a linguagem que ele conhecia tão bem. Ele não entendia porque precisava escreve tanto para fazer o mesmo que no Ruby podia ser feito com poucas linhas. E pior: de forma menos legível e expressiva."],["br"]],["paragraph",["text","De repente Carlinhos começou a sentir falta de uma forma melhor de se expressar através do código. Ele queria ser tão ou mais produtivo que seus colegas que usavam Ruby. Ele queria, inclusive, poder mudar a linguagem conforme suas necessidades, de acordo com o problema a ser resolvido, algo que nem mesmo o Ruby permitia com facilidade. Ele queria muito mais."],["br"]],["paragraph",["text","Um dia, durante o almoço, ele resolveu dividir com os colegas as coisas que o incomodavam. Dois deles riram, dizendo que Carlinhos estava inventando coisas. Disseram inclusive que o Java era assim mesmo e pessoas criavam coisas bacanas com a linguagem no mundo inteiro sem reclamar."],["br"]],["paragraph",["text","O terceiro colega que estava na mesa, e até então tinha observado a conversa em silêncio, perguntou:"],["br"]],["paragraph",["italic",["text","\"E seu te disser que isso é possível? Que existe uma linguagem que você pode moldar como se fosse argila, deixando-a ainda mais expressiva e, de quebra, ainda pode continuar usando todas as bibliotecas que você usa hoje no Java?\""]],["br"]],["paragraph",["text","Carlinhos não podia acreditar naquilo. Seus dois colegas conformistas estavam ocupados demais atacando a sobremesa para prestar atenção na conversa."],["br"]],["paragraph",["italic",["text","\"Você deve estar se perguntando qual é a mágica. Não existe mágica. O que existe são macros.\""]],["text",", continuou o terceiro colega como se tivesse lido os pensamentos de Carlinhos. "],["italic",["text","\"Depois do almoço eu te explico o que é e como funciona, mas talvez seja o início de um caminho sem volta para você.\""]],["br"]],["paragraph",["text","Carlinhos mal podia esperar."],["br"]],["section",["text","Não é mágica. São macros."]],["paragraph",["br"]],["paragraph",["text","Esse capítulo não é sobre Carlinhos mas, imaginando como foi a conversa, podemos enumerar algumas coisas que poderiam ser melhoradas na linguagem Java caso ela permitisse macros. Pode imaginar, que é bem possível que o Clojure permita que você as adicione."],["br"]],["paragraph",["text","Por exemplo, a linguagem C# tem um recurso bem interessante chamado "],["monospaced",["text","using"]],["text",", em que um recurso é fechado automaticamente ao final do bloco."],["br"]],["index",["text","using (C Sharp)"]],["paragraph",["br"]],["code","java",["br"],["code-text","using (StreamReader sr = File.OpenText(\"arquivo.txt\"))"],["br"],["code-text","{"],["br"],["code-text","  Console.WriteLine(sr.ReadLine());"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["paragraph",["text","No Java você é obrigado a fechar o arquivo ao terminar de ler."],["br"]],["code","java",["br"],["code-text","DataInputStream bis ="],["br"],["code-text","    new DataInputStream("],["br"],["code-text","      new FileInputStream("],["br"],["code-text","        new File(\"arquivo.txt\")));"],["br"],["code-text","System.out.println(bis.readLine());"],["br"],["code-text","bis.close();"],["br"]],["paragraph",["br"]],["paragraph",["text","O problema é que é bem comum esquecermos de fechar o arquivo, abrindo espaço para erros na aplicação. Outro problema é que teremos que esperar eternamente pela boa vontade dos desenvolvedores da linguagem para que esse recurso seja adicionado, se algum dia chegar a ser adicionado."],["br"]],["paragraph",["text","Já no Clojure podemos criar nosso próprio "],["monospaced",["text","using"]],["text"," e trabalharmos com um código assim:"],["br"]],["code","clojure",["br"],["code-text","(def bis (DataInputStream."],["br"],["code-text","           (FileInputStream."],["br"],["code-text","             (File. \"arquivo.txt\"))))"],["br"],["code-text","(using bis"],["br"],["code-text","  (println (.readLine bis)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Que tal?"],["br"]],["paragraph",["text","Já no Ruby temos o "],["monospaced",["text","each"]],["text",", que executa um bloco de código em cada item de um vetor."],["br"]],["code","ruby",["br"],["code-text","lista_itens.each {|item| puts item}"],["br"]],["paragraph",["br"]],["paragraph",["text","Em Java teríamos que usar o nosso conhecido "],["monospaced",["text","for"]],["text",":"],["br"]],["code","java",["br"],["code-text","for(Item item : listaItens) {"],["br"],["code-text","  System.out.println(item);"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["paragraph",["text","E fique feliz por essa sintaxe do "],["monospaced",["text","for"]],["text",". Até a versão "],["italic",["text","1.4"]],["text"," do Java você seria obrigado a escrever assim:"],["br"]],["code","clojure",["br"],["code-text","for(int i = 0; i < listaItens.size(); i++) {"],["br"],["code-text","  System.out.println(listaItens.get(i));"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["paragraph",["text","Em Clojure podemos criar nosso próprio "],["monospaced",["text","each"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(each [item lista-itens]"],["br"],["code-text","  (println item))"],["br"]],["paragraph",["br"]],["paragraph",["text","Durante o capítulo vamos aprender a criar essas macros e outras mais que possam facilitar nossas vidas."],["br"]],["paragraph",["text","O próprio Clojure faz uso constante de macros para criar a linguagem. Muito do que você usa da biblioteca padrão foi escrito em Clojure."],["br"]],["paragraph",["text","Por alto, olhando o código fonte da linguagem, contei uma dúzia de formas especiais, que são operadores que formam o núcleo da linguagem, e mais de setenta macros que ajudam a formar a biblioteca padrão. É uma mostra de como você pode aumentar ou moldar a linguagem da mesma forma que os criadores da linguagem fizeram, sem plugins nem gambiarras."],["br"]],["section",["text","Legal, mas o que são macros?"]],["paragraph",["br"]],["paragraph",["text","Macros nada mais são do que construções idiomáticas que são "],["italic",["text","expandidas"]],["text"," em tempo de compilação. Durante essa "],["italic",["text","expansão"]],["text",", o código que você escreveu é convertido em um bloco maior de código e, caso não haja mais nenhuma macro nesse bloco, ele finalmente é avaliado e executado."],["br"]],["paragraph",["text","Vamos ver na prática como isso funciona começando com um código bem simples."],["br"]],["paragraph",["text","Nós aprendemos no capítulo "],["ref-label",["text","capitulo-funcoes"]],["text"," como repetir a execução de um código usando recursão. Vamos usar aqui o mesmo recurso para imprimir infinitamente um texto na tela."],["br"]],["code","clojure",["br"],["code-text","(loop []"],["br"],["code-text","  (println \"Preso num loop infinito\")"],["br"],["code-text","  (recur))"],["br"]],["paragraph",["br"]],["paragraph",["text","Qualquer programador que tenha alguma familiaridade com Clojure sabe que a dupla "],["monospaced",["text","loop"]],["text"," e "],["monospaced",["text","recur"]],["text"," sem uma condição de parada vai criar um "],["italic",["text","loop"]],["text"," infinito. E quem ainda não tem essa familiaridade? E se tivermos um trecho de código extenso usando esse recurso?"],["br"]],["paragraph",["text","Vamos então criar nossa primeira macro para deixar o código mais legível."],["br"]],["index",["text","defmacro"]],["index",["text","~@"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(defmacro infinite-loop"],["br"],["code-text","  \"Executa o conteúdo de body infinitamente\""],["br"],["code-text","  [& body]"],["br"],["code-text","  `(loop []"],["br"],["code-text","     ~@body"],["br"],["code-text","     (recur)))"],["br"],["code-text","(infinite-loop"],["br"],["code-text","  (println \"Preso num loop infinito\"))"],["br"]],["paragraph",["br"]],["paragraph",["text","Ao executar, você estará realmente preso num "],["italic",["text","loop"]],["text"," infinito."],["br"]],["index",["text","macroexpand-1"]],["paragraph",["br"]],["paragraph",["text","Para sabermos o que o compilador fez antes de executar o código, vamos utilizar o operador "],["monospaced",["text","macroexpand-1"]],["text",", que verifica "],["italic",["text","uma vez"]],["text"," quais operadores são macros, expandindo-os."],["br"]],["paragraph",["text","Para utilizar este operador, você precisa passar o código como se fosse uma lista. Para isso, use o operador "],["monospaced",["text","'"]],["text"," ou "],["monospaced",["text","quote"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(macroexpand-1"],["br"],["code-text","  '(infinite-loop"],["br"],["code-text","    (println \"Preso num loop infinito\")))"],["br"],["code-text","; (clojure.core/loop []"],["br"],["code-text",";   (println \"Preso num loop infinito\")"],["br"],["code-text",";   (recur))"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que a versão expandida é praticamente igual ao nosso código original, escrito com "],["monospaced",["text","loop"]],["text"," e "],["monospaced",["text","recur"]],["text","."],["br"]],["paragraph",["text","Olhando para o código da nossa macro, temos várias novidades e um velho conhecido."],["br"]],["index",["text","defn"]],["paragraph",["br"]],["paragraph",["text","A declaração de uma macro, feita através do operador "],["monospaced",["text","defmacro"]],["text",", guarda muitas semelhanças com "],["monospaced",["text","defn"]],["text",". Note que também temos um texto que serve como documentação, uma lista de argumentos e um corpo contendo as instruções a serem executadas, assim como na declaração de uma função. Na própria documentação ficamos sabendo se estamos vendo uma função ou uma macro."],["br"]],["index",["text","doc"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(doc infinite-loop)"],["br"],["code-text","; -------------------------"],["br"],["code-text","; user/infinite-loop"],["br"],["code-text","; ([& body])"],["br"],["code-text","; Macro"],["br"],["code-text",";   Executa o conteúdo de body infinitamente"],["br"]],["paragraph",["br"]],["index",["text","syntax-quote"]],["index",["text","`"]],["paragraph",["br"]],["paragraph",["text","Porém, note que imediatamente antes do corpo da função temos o conhecido operador "],["monospaced",["text","`"]],["text",", ou "],["italic",["text","syntax-quote"]],["text",", que já vimos no capítulo "],["ref-label",["text","capitulo-dados"]],["text","."],["br"]],["index",["text","quote"]],["paragraph",["br"]],["paragraph",["text","Relembrando, esse operador funciona praticamente da mesma forma que "],["monospaced",["text","quote"]],["text",", tratando uma lista de expressões como uma lista de dados. Porém, "],["italic",["text","syntax-quote"]],["text"," também resolve o nome do operador para seu nome completo, deixando claro em qual "],["italic",["text","namespace"]],["text"," ele foi declarado, ou se estivermos lidando com uma classe Java, em qual pacote está a tal classe."],["br"]],["code","clojure",["br"],["code-text",";; quote normal"],["br"],["code-text","'(1 2 3)"],["br"],["code-text","; (1 2 3)"],["br"],["code-text",";; syntax-quote"],["br"],["code-text","`(1 2 3)"],["br"],["code-text","; (1 2 3)"],["br"],["code-text",";; parecem iguais, mas vamos adicionar um operador qualquer"],["br"],["code-text","'(+ 1 2 3)"],["br"],["code-text","; (+ 1 2 3)"],["br"],["code-text",";; e agora com syntax-quote"],["br"],["code-text","`(+ 1 2 3)"],["br"],["code-text","; (clojure.core/+ 1 2 3)"],["br"],["code-text",";; ou com Java"],["br"],["code-text","`Integer/MAX_VALUE"],["br"],["code-text","; java.lang.Integer/MAX_VALUE"],["br"]],["paragraph",["br"]],["paragraph",["text","Assim o compilador sabe exatamente qual é o operador, classe ou objeto que deve ser usado."],["br"]],["paragraph",["text","Então, se funcionam praticamente da mesma forma, eu poderia muito bem usar o "],["italic",["text","quote"]],["text"," normal na minha macro, certo?"],["br"]],["paragraph",["text","Errado. Por "],["italic",["text","praticamente igual"]],["text"," significa que temos uma diferença sutil, mas muito importante. Quando você usa "],["italic",["text","syntax-quote"]],["text"," em uma lista, você também está informando que a lista é um "],["italic",["text","template"]],["text",", um modelo que será completado conforme a macro for expandida."],["br"]],["paragraph",["text","Com isso você avisa ao compilador que está escrevendo código para macros e isso habilita os demais operadores que vamos precisar e que vamos ver mais para frente."],["br"]],["paragraph",["text","Veja novamente o nosso exemplo. Os trechos com "],["monospaced",["text","loop"]],["text"," e "],["monospaced",["text","recur"]],["text"," são os mesmos que estão no código da macro, mas o recheio do código, a expressão que está dentro da repetição muda conforme você utiliza a macro."],["br"]],["paragraph",["text","Vamos usar novamente no nosso "],["italic",["text","loop"]],["text"," infinito para demonstrar, dessa vez adicionando uma pequena pausa entre cada repetição."],["br"]],["code","clojure",["br"],["code-text","(infinite-loop"],["br"],["code-text","  (Thread/sleep 2000)"],["br"],["code-text","  (println \"Pausadamente preso num loop infinito\"))"],["br"]],["paragraph",["br"]],["paragraph",["text","Se olharmos o código por dentro, veja que "],["monospaced",["text","~@body"]],["text"," foi completamente substituido pela sequencia de instruções que aninhamos dentro de "],["monospaced",["text","infinite-loop"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(macroexpand-1"],["br"],["code-text","  '(infinite-loop"],["br"],["code-text","     (Thread/sleep 2000)"],["br"],["code-text","     (println \"Pausadamente preso num loop infinito\")))"],["br"],["code-text","; (clojure.core/loop []"],["br"],["code-text",";   (Thread/sleep 2000)"],["br"],["code-text",";   (println \"Pausadamente preso num loop infinito\")"],["br"],["code-text",";   (recur))"],["br"]],["paragraph",["br"]],["box",["text","Quote e syntax-quote"],["paragraph",["br"]],["paragraph",["text","Para deixar claro as diferenças entre "],["italic",["text","quote"]],["text"," e "],["italic",["text","syntax-quote"]],["text",", compare os códigos executados usando um e outro."],["br"]],["paragraph",["text","Código com "],["italic",["text","quote"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(def numero 42)"],["br"],["code-text","'x#"],["br"],["code-text","; x#"],["br"],["code-text","'(+ ~numero ~numero))"],["br"],["code-text","; (+ (clojure.core/unquote numero)"],["br"],["code-text",";    (clojure.core/unquote numero))"],["br"]],["paragraph",["br"]],["paragraph",["text","Código com "],["italic",["text","syntax-quote"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(def numero 42)"],["br"],["code-text","`x#"],["br"],["code-text","; x__771__auto__"],["br"],["code-text","`(+ ~numero ~numero)"],["br"],["code-text","; (clojure.core/+ 42 42)"],["br"]],["paragraph",["br"]]],["paragraph",["br"]],["paragraph",["text","Relembrando que você usa "],["italic",["text","syntax-quote"]],["text"," para escrever macros, e usa "],["italic",["text","quote"]],["text"," normal para transformar o código em uma estrutura de dados e passar como parâmetro para "],["monospaced",["text","macroexpand-1"]],["text","."],["br"]],["section",["text","Usando unquote sem complicação"]],["paragraph",["br"]],["paragraph",["text","Agora vamos definir localmente dois valores, "],["monospaced",["text","a"]],["text"," e "],["monospaced",["text","b"]],["text",", um valendo "],["monospaced",["text","6"]],["text"," e outro valendo "],["monospaced",["text","7"]],["text",". Em seguida vamos utilizar "],["italic",["text","syntax-quote"]],["text"," em uma expressão que multiplica "],["monospaced",["text","a"]],["text"," por "],["monospaced",["text","b"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(let [a 6"],["br"],["code-text","      b 7]"],["br"],["code-text","  `(* a b))"],["br"],["code-text","; (clojure.core/* user/a user/b)"],["br"]],["paragraph",["br"]],["paragraph",["text","Ao invés de trabalhar com os valores locais, o "],["italic",["text","syntax-quote"]],["text"," considerou que "],["monospaced",["text","a"]],["text"," e "],["monospaced",["text","b"]],["text"," são "],["italic",["text","vars"]],["text"," do "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","user"]],["text",", que é o padrão do "],["italic",["text","REPL"]],["text","."],["br"]],["paragraph",["text","Como não existem os "],["italic",["text","vars"]],["text"," "],["monospaced",["text","a"]],["text"," e "],["monospaced",["text","b"]],["text",", esse código vai causar um erro ao ser executado."],["br"]],["index",["text","eval"]],["paragraph",["br"]],["paragraph",["text","Existe uma função chamada "],["monospaced",["text","eval"]],["text"," que recebe uma estrutura de dados e executa como se fosse código. Vamos testar nosso código para ver o erro acontecendo."],["br"]],["box",["text","Eval"],["paragraph",["br"]],["paragraph",["text","O nome "],["monospaced",["text","eval"]],["text"," vem do inglês "],["italic",["text","evaluate"]],["text",", que significa "],["italic",["text","avaliar"]],["text",". Avaliar é exatamente o o que Clojure faz quando interpreta e executa uma expressão."],["br"]],["paragraph",["text","Se um dia você resolver escrever uma linguagem, a função "],["monospaced",["text","eval"]],["text"," é um bom ponto para se começar."],["br"]]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(eval"],["br"],["code-text","  (let [a 6"],["br"],["code-text","        b 7]"],["br"],["code-text","    `(* a b)))"],["br"],["code-text","; CompilerException java.lang.RuntimeException: No such var: user/a"],["br"]],["paragraph",["br"]],["paragraph",["text","E por que o erro não ocorre assim que escrevemos o código com o "],["italic",["text","syntax-quote"]],["text","? Por que o código que está delimitado pelo "],["italic",["text","syntax-quote"]],["text",", e todo o resto do código de uma macro, é avaliado e executado "],["italic",["text","em tempo de compilação"]],["text",", enquanto a atribuição de valores a seus respectivos símbolos ocorre em "],["italic",["text","tempo de execução"]],["text","."],["br"]],["paragraph",["text","Para que o valor seja utilizado em tempo de execução, vamos usar o operador "],["italic",["text","unquote"]],["text",", representado pelo operador "],["monospaced",["text","~"]],["text",". Com ele podemos substituir trechos do "],["italic",["text","template"]],["text"," criado pelo "],["italic",["text","syntax-quote"]],["text"," por seus respectivos valores."],["br"]],["paragraph",["text","Colocando o operador "],["monospaced",["text","~"]],["text"," em prática, vemos que o código é expandido com o símbolos substituidos por seus valores, mas só é executado quando passado para "],["monospaced",["text","eval"]],["text",". Nós temos uma expressão como resultado, e sua execução só acontece quando queremos."],["br"]],["paragraph",["text","Vou substituir apenas um dos símbolos."],["br"]],["code","clojure",["br"],["code-text","(let [a 6"],["br"],["code-text","      b 7]"],["br"],["code-text","  `(* ~a b))"],["br"],["code-text","; (clojure.core/* 6 user/b)"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que "],["monospaced",["text","a"]],["text"," foi substituido pelo valor atribuido em tempo de execução, enquanto "],["monospaced",["text","b"]],["text"," continuou a ser entendido como um "],["italic",["text","var"]],["text"," que só vai estar disponível quando necessário."],["br"]],["paragraph",["text","E se eu utilizar "],["italic",["text","unquote"]],["text"," com um símbolo que não foi declarado? Vimos que sem o "],["italic",["text","unquote"]],["text"," o erro só acontece quando o nosso código é avaliado com "],["monospaced",["text","eval"]],["text",".. E com "],["italic",["text","unquote"]],["text","?"],["br"]],["code","clojure",["br"],["code-text","(let [a 6"],["br"],["code-text","      b 7]"],["br"],["code-text","  `(* ~c b)) ; c não existe"],["br"],["code-text","; CompilerException java.lang.RuntimeException:"],["br"],["code-text","; Unable to resolve symbol: c in this context"],["br"]],["paragraph",["br"]],["paragraph",["text","O próprio compilador reclamou que "],["monospaced",["text","c"]],["text"," não existe no contexto da expressão. Se você criar um "],["italic",["text","var"]],["text"," chamado "],["monospaced",["text","c"]],["text",", ou declarar um valor para "],["monospaced",["text","c"]],["text"," dentro do "],["monospaced",["text","let"]],["text"," ou mesmo se estiver dentro de uma função que receba "],["monospaced",["text","c"]],["text"," como parâmetro, o erro para de acontecer e o respectivo valor será utilizado."],["br"]],["code","clojure",["br"],["code-text","(def c 99)"],["br"],["code-text","(let [a 6"],["br"],["code-text","      b 7]"],["br"],["code-text","  `(* ~c b)) ; c é um var"],["br"],["code-text","(clojure.core/* 99 user/b)"],["br"]],["paragraph",["br"]],["paragraph",["text","O símbolo "],["monospaced",["text","c"]],["text"," é substituido por seu valor, desde que "],["monospaced",["text","c"]],["text"," exista."],["br"]],["paragraph",["text","Voltando ao nosso código, vamos substituir "],["monospaced",["text","a"]],["text"," e "],["monospaced",["text","b"]],["text"," por seus respectivos valores utilizando "],["italic",["text","unquote"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(let [a 6"],["br"],["code-text","      b 7]"],["br"],["code-text","  `(* ~a ~b))"],["br"],["code-text","; (clojure.core/* 6 7)"],["br"],["code-text","(eval"],["br"],["code-text","  (let [a 6"],["br"],["code-text","        b 7]"],["br"],["code-text","    `(* ~a ~b)))"],["br"],["code-text","; 42"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos criar uma macro chamada "],["monospaced",["text","mult"]],["text"," que multiplica os dois valores. Dessa vez os valores de "],["monospaced",["text","a"]],["text"," e "],["monospaced",["text","b"]],["text"," vêm dos parâmetros."],["br"]],["code","clojure",["br"],["code-text","(defmacro mult [a b]"],["br"],["code-text","  `(* ~a ~b))"],["br"],["code-text","(mult 6 7)"],["br"],["code-text","; 42"],["br"]],["paragraph",["br"]],["section",["text","Criando nossos próprios operadores"]],["paragraph",["br"]],["paragraph",["text","Agora que aprendemos a preencher a expressão com os valores, vamos finalmente desenvolver os operadores dos quais falamos no início do capítulo. O primeiro deles é o "],["monospaced",["text","unless"]],["text",", existente no Ruby, que funciona como um "],["monospaced",["text","if"]],["text"," invertido: se a condição for falsa, a primeira expressão é executada, caso contrário é executada a segunda."],["br"]],["paragraph",["text","É sempre uma boa prática escrever o código em Clojure que vai fazer o que queremos "],["italic",["text","antes"]],["text"," de escrever a macro. A partir do momento em que tivermos o código funcionando e fazendo o que se espera, vamos usá-lo como modelo para criar a macro."],["br"]],["paragraph",["text","O funcionamento de "],["monospaced",["text","unless"]],["text"," deve ficar assim:"],["br"]],["code","clojure",["br"],["code-text","(unless (= 1 0)"],["br"],["code-text","  (println \"Ufa! Um não é igual a zero.\")"],["br"],["code-text","  (println \"Que maluquice! Um é igual a zero!\"))"],["br"],["code-text","; CompilerException java.lang.RuntimeException:"],["br"],["code-text","; Unable to resolve symbol: unless in this context"],["br"]],["paragraph",["br"]],["paragraph",["text","Claro que não vai funcionar ainda. Falta escrever o código de "],["monospaced",["text","unless"]],["text","."],["br"]],["paragraph",["text","O código que faz isso, dentro das nossas limitadas ferramentas pode ser o seguinte:"],["br"]],["code","clojure",["br"],["code-text","(if (not (= 1 0))"],["br"],["code-text","  (println \"Ufa! Um não é igual a zero.\")"],["br"],["code-text","  (println \"Que maluquice! Um é igual a zero!\"))"],["br"],["code-text","; Ufa! Um não é igual a zero."],["br"]],["paragraph",["br"]],["paragraph",["text","Legal, o código em Clojure padrão funciona. Vamos então dissecar passo a passo o que temos aqui."],["br"]],["paragraph",["text","No nosso código, "],["monospaced",["text","(= 1 0)"]],["text"," é a condição. Vamos então utilizar a condição como um parâmetro da macro:"],["br"]],["code","clojure",["br"],["code-text","(defmacro unless [condicao]"],["br"],["code-text","  `(if (not ~condicao)"],["br"],["code-text","     (println \"Ufa! Um não é igual a zero.\")"],["br"],["code-text","     (println \"Que maluquice! Um é igual a zero!\")))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos executar nosso código para ver se está funcionando."],["br"]],["code","clojure",["br"],["code-text","(unless (= 1 0)"],["br"],["code-text","  (println \"Ufa! Um não é igual a zero.\")"],["br"],["code-text","  (println \"Que maluquice! Um é igual a zero!\"))"],["br"],["code-text","; ArityException Wrong number of args (3) passed to: user/unless"],["br"]],["paragraph",["br"]],["paragraph",["text","Ouch. O apressado come cru e quente. Tanto o código a ser executado caso a condição seja falsa como o código da expressão verdeira são considerados parâmetros para uma macro. Devemos modificar a assinatura da declaração da macro."],["br"]],["paragraph",["text","Vamos então separar as duas expressões com "],["monospaced",["text","println"]],["text"," em dois parâmetros: "],["monospaced",["text","verdadeiro"]],["text"," e "],["monospaced",["text","falso"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defmacro unless [condicao falso verdadeiro]"],["br"],["code-text","  `(if (not ~condicao)"],["br"],["code-text","     ~falso"],["br"],["code-text","     ~verdadeiro))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos tentar de novo:"],["br"]],["code","clojure",["br"],["code-text","(unless (= 1 0)"],["br"],["code-text","  (println \"Ufa! Um não é igual a zero.\")"],["br"],["code-text","  (println \"Que maluquice! Um é igual a zero!\"))"],["br"],["code-text","; Ufa! Um não é igual a zero."],["br"]],["paragraph",["br"]],["paragraph",["text","Se utilizarmos uma condição verdadeira, a segunda expressão deve ser executada."],["br"]],["code","clojure",["br"],["code-text","(unless (= 1 1)"],["br"],["code-text","  (println \"Que maluquice! Um não é igual a um!\")"],["br"],["code-text","  (println \"Tudo certo. Um é igual a um.\"))"],["br"],["code-text","; Tudo certo. Um é igual a um."],["br"]],["paragraph",["br"]],["section",["text","Por que uma macro e não uma função?"]],["paragraph",["br"]],["paragraph",["text","Um dos casos em que devemos utilizar macros ao invés de funções é quando não podemos avaliar as expressões antes de decidir qual caminho seguir."],["br"]],["paragraph",["text","Ao utilizarmos uma função, todas as expressões são avaliadas e somente os resultados são passados como parâmetro. Numa macro as expressões são passadas por parâmetro, sem serem avaliadas, e só retornam um valor quando for realmente necessário."],["br"]],["paragraph",["text","Vamos programar "],["monospaced",["text","unless"]],["text"," como uma função, para a qual vamos chamar de "],["monospaced",["text","f-unless"]],["text",", e vamos fazer uma checagem de acesso num sistema imaginário. Se o usuário tiver permissão, todas as informações do banco de dados serão excluídos. Caso contrário, será exibida uma mensagem de erro."],["br"]],["code","clojure",["br"],["code-text","(defn f-unless [condicao falso verdadeiro]"],["br"],["code-text","  (if (not condicao)"],["br"],["code-text","    falso"],["br"],["code-text","    verdadeiro))"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos escrever o nosso código de verificação de acesso. Nada muito sofisticado. Vamos começar com um usuário não autorizado."],["br"]],["code","clojure",["br"],["code-text","(def autorizado false)"],["br"],["code-text","(f-unless (not autorizado)"],["br"],["code-text","  (println \"Apagando todos os dados\")"],["br"],["code-text","  (println \"Acesso negado\"))"],["br"],["code-text","; Apagando todos os dados"],["br"],["code-text","; Acesso negado"],["br"],["code-text","; nil"],["br"]],["paragraph",["br"]],["paragraph",["text","Todos os dados foram apagados e a mensagem de acesso negado foi exibida. Péssimo."],["br"]],["paragraph",["text","Quando invocamos uma função, as expressões aninhadas são avaliadas de dentro para fora, da esquerda para a direita."],["br"]],["paragraph",["text","Com isso, nossa expressão é avaliada da seguinte forma. Vamos começar com a expressão original:"],["br"]],["code","clojure",["br"],["code-text","(f-unless (not autorizado)"],["br"],["code-text","  (println \"Apagando todos os dados\")"],["br"],["code-text","  (println \"Acesso negado\"))"],["br"]],["paragraph",["br"]],["paragraph",["bold",["text","Passo 1"]],["text",": a expressão mais interna e que estiver mais à esquerda é avaliada."],["br"]],["code","clojure",["br"],["code-text","(not autorizado) ; autorizado é false"],["br"],["code-text","(not false)      ; not false é true"],["br"],["code-text","true"],["br"],["code-text",";; A expressão é substituida pelo seu respectivo valor"],["br"],["code-text","(f-unless true"],["br"],["code-text","  (println \"Apagando todos os dados\")"],["br"],["code-text","  (println \"Acesso negado\"))"],["br"]],["paragraph",["br"]],["paragraph",["bold",["text","Passo 2"]],["text",": a próxima expressão mais interna à esquerda é avaliada."],["br"]],["code","clojure",["br"],["code-text","(println \"Apagando todos os dados\")"],["br"],["code-text","; é exibida a mensagem \"Apagando todos os dados\"."],["br"],["code-text","; num sistema de verdade todos os dados seriam apagados"],["br"],["code-text","; println retorna nil"],["br"],["code-text","(f-unless true"],["br"],["code-text","  nil"],["br"],["code-text","  (println \"Acesso negado\"))"],["br"]],["paragraph",["br"]],["paragraph",["bold",["text","Passo 3"]],["text",": a próxima expressão mais interna à esquerda, que agora é a última, será avaliada."],["br"]],["code","clojure",["br"],["code-text","(println \"Acesso negado\")"],["br"],["code-text","; é exibida a mensagem \"Acesso negado\""],["br"],["code-text","; println retorna nil"],["br"]],["paragraph",["br"]],["paragraph",["bold",["text","Passo 4"]],["text",": agora a função é invocada com os parâmetros já avaliados:"],["br"]],["code","clojure",["br"],["code-text","(f-unless true"],["br"],["code-text","  nil"],["br"],["code-text","  nil)"],["br"]],["paragraph",["br"]],["paragraph",["bold",["text","Passo 5"]],["text",": será retornado o terceiro parâmetro, que é "],["monospaced",["text","nil"]],["text",", já que o primeiro é "],["monospaced",["text","true"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(f-unless (not autorizado)"],["br"],["code-text","  (println \"Apagando todos os dados\")"],["br"],["code-text","  (println \"Acesso negado\"))"],["br"],["code-text","; Apagando todos os dados"],["br"],["code-text","; Acesso negado"],["br"],["code-text","; nil"],["br"]],["paragraph",["br"]],["paragraph",["text","Por isso serão exibidas as duas mensagens, ao invés de apenas uma, e "],["monospaced",["text","f-unless"]],["text"," vai retornar "],["monospaced",["text","nil"]],["text",". Se fosse um sistema de verdade, teríamos todos os dados apagados, a mensagem de acesso negado exibida e só então só seria verificado se o usuário tem ou não permissão."],["br"]],["paragraph",["text","Quando usamos macros, os parâmetros só serão avaliados quando for encontrador o operador "],["italic",["text","unquote"]],["text"," que, na nossa macro "],["monospaced",["text","unless"]],["text",", só são executados após passarem pelo "],["monospaced",["text","if"]],["text","."],["br"]],["paragraph",["text","Dessa forma os parâmetros só são avaliados "],["italic",["text","condicionalmente"]],["text",", ou seja, se o usuário tiver permissão, os dados serão excluídos e nenhuma mensagem de acesso negado será exibida. Caso contrário, apenas a mensagem será exibida e nenhuma informação será apagada. É exatamente o comportamento que esperamos."],["br"]],["index",["text","if-not"]],["paragraph",["br"]],["paragraph",["text","Apesar do exemplo com "],["monospaced",["text","unless"]],["text"," ser o "],["italic",["text","Olá, Mundo"]],["text"," das macros, a biblioteca padrão já oferece essa funcionalidade com o nome de "],["monospaced",["text","if-not"]],["text",". Reinventar a roda pode ser uma boa forma de entender como ela funciona."],["br"]],["section",["text","Usando várias expressões ao mesmo tempo com higiente"]],["paragraph",["br"]],["paragraph",["text","Vamos implementar agora o operador "],["monospaced",["text","using"]],["text","."],["br"]],["paragraph",["text","Relembrando, "],["monospaced",["text","using"]],["text"," recebe um valor que simboliza um arquivo, uma conexão de rede, com o banco de dados ou qualquer recurso que deva ser fechado após o uso, e também uma sequência de expressões que devem ser executadas enquanto o recurso estiver aberto."],["br"]],["index",["text","java.io.DataInputStream"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(def bis (DataInputStream."],["br"],["code-text","           (FileInputStream."],["br"],["code-text","             (File. \"arquivo.txt\"))))"],["br"],["code-text","(using bis"],["br"],["code-text","  (println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text","  (println (.readLine bis)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Para fins de teste, vamos criar um arquivo chamado "],["monospaced",["text","arquivo.txt"]],["text"," contendo três linhas:"],["br"]],["code",["br"],["code-text","Linha 1"],["br"],["code-text","Linha 2"],["br"],["code-text","Linha 3"],["br"]],["paragraph",["br"]],["paragraph",["text","Tudo bem simples para não perdermos o foco."],["br"]],["index",["text","java.io.File"]],["paragraph",["br"]],["index",["text","java.io.FileInputStream"]],["paragraph",["br"]],["paragraph",["text","Primeiro, vamos criar o código em Clojure que vai fazer o que queremos. Não podemos nos esquecer de importar as classes Java "],["monospaced",["text","DataInputStream"]],["text"," e "],["monospaced",["text","File"]],["text"," para que nosso exemplo funcione no "],["italic",["text","REPL"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(import java.io.DataInputStream"],["br"],["code-text","        java.io.FileInputStream"],["br"],["code-text","        java.io.File)"],["br"]],["paragraph",["br"]],["paragraph",["text","A declaração de "],["monospaced",["text","bis"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(def bis (DataInputStream."],["br"],["code-text","           (FileInputStream."],["br"],["code-text","             (File. \"arquivo.txt\"))))"],["br"]],["paragraph",["br"]],["paragraph",["text","E o código que queremos:"],["br"]],["code","clojure",["br"],["code-text","(let [temp bis]"],["br"],["code-text","  (println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text","  (println (.readLine bis))"],["br"],["code-text","  (.close temp))"],["br"],["code-text","; Exibindo a primeira linha do arquivo"],["br"],["code-text","; Linha 1"],["br"]],["paragraph",["br"]],["paragraph",["text","O começo é bem parecido com o código usando macros, com um "],["monospaced",["text","let"]],["text"," no lugar de "],["monospaced",["text","using"]],["text",", enquanto a última linha de código é a chamada ao método "],["monospaced",["text","close"]],["text",", que não aparece no nosso código com macro."],["br"]],["paragraph",["text","Esse "],["monospaced",["text","temp"]],["text"," surgiu aí por um motivo muito simples. O "],["monospaced",["text","bis"]],["text"," é definido pelo usuário e nós simplesmente não temos como adivinhar qual o nome do "],["italic",["text","binding"]],["text"," do usuário. Por isso criamos um "],["italic",["text","binding"]],["text"," que só existe dentro da nossa macro para que possamos fechar o recurso."],["br"]],["paragraph",["text","Nossa macro vai receber uma quantidade indefinida de parâmetros, sendo que o primeiro contém o recurso a ser fechado, enquanto todos os outros são as expressões que serão executadas na ordem antesdo fechamento do recurso."],["br"]],["paragraph",["text","Tudo o que se aplica a parâmetros de funções se aplica também a parâmetros de macros, incluindo o uso de quantidades variáveis de argumentos."],["br"]],["code","clojure",["br"],["code-text","(defmacro using [resource & body]"],["br"],["code-text","; aqui vem o código da macro"],["br"],["code-text","  )"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que vamos deixar todas as expressões em um vetor chamado "],["monospaced",["text","body"]],["text",", que indica o "],["italic",["text","corpo"]],["text"," da macro. Você vai notar que as bibliotecas do Clojure também chamam este argumento específico de "],["monospaced",["text","body"]],["text",", então vamos manter o padrão para que você já se acostume."],["br"]],["paragraph",["text","Usando o que já sabemos, vamos tentar utilizar o operador "],["italic",["text","unquote"]],["text"," para ver como o código se comporta. Vamos aproveitar e já invocar o método "],["monospaced",["text","close"]],["text"," no nosso recurso."],["br"]],["code","clojure",["br"],["code-text","(defmacro using [resource & body]"],["br"],["code-text","  `(let [temp ~resource]"],["br"],["code-text","     ~body"],["br"],["code-text","     (.close temp)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Executando a nossa macro, teremos o resultado abaixo:"],["br"]],["code","clojure",["br"],["code-text","(using bis"],["br"],["code-text","  (println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text","  (println (.readLine bis)))"],["br"],["code-text","; CompilerException java.lang.RuntimeException: Can't let qualified"],["br"],["code-text","; name: user/temp"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos expandir a macro para encontrar o porque do erro."],["br"]],["code","clojure",["br"],["code-text","(macroexpand-1 '(using bis"],["br"],["code-text","                  (println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text","                  (println (.readLine bis))))"],["br"],["code-text","; (clojure.core/let [user/temp bis]"],["br"],["code-text",";   ((println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text",";   (println (.readLine bis)))"],["br"],["code-text",";   (.close user/temp))"],["br"]],["paragraph",["br"]],["paragraph",["text","Perceba que nosso "],["italic",["text","binding"]],["text"," local acabou sendo transformado em "],["monospaced",["text","user/temp"]],["text",". Dizemos que ele "],["italic",["text","vazou"]],["text"," da macro, sujando o código e causando erro na execução."],["br"]],["paragraph",["text","Mesmo que você force o uso de "],["italic",["text","unquote"]],["text"," em "],["monospaced",["text","temp"]],["text",", o problema não vai ser resolvido. Como podemos usar "],["italic",["text","unquote"]],["text"," em um símbolo que ainda não existe? Pior ainda, num símbolo que estamos tentando criar?"],["br"]],["code","clojure",["br"],["code-text","(defmacro using [resource & body]"],["br"],["code-text","  `(let [~temp ~resource]"],["br"],["code-text","     ~body"],["br"],["code-text","     (.close ~temp)))"],["br"],["code-text","; CompilerException java.lang.RuntimeException:"],["br"],["code-text","; Unable to resolve symbol: temp in this context"],["br"]],["paragraph",["br"]],["paragraph",["text","A coisa pode ficar pior ainda. E se "],["monospaced",["text","temp"]],["text"," já existir e não tiver absolutamente nada a ver com nossa macro?"],["br"]],["code","clojure",["br"],["code-text","(def temp \"banana\")"],["br"],["code-text","(defmacro using [resource & body]"],["br"],["code-text","  `(let [~temp ~resource]"],["br"],["code-text","     ~body"],["br"],["code-text","     (.close ~temp)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora não deu erro. Ainda."],["br"]],["paragraph",["text","Vamos ver como fica a macro após ser expandida:"],["br"]],["code","clojure",["br"],["code-text","(macroexpand-1 '(using bis"],["br"],["code-text","                  (println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text","                  (println (.readLine bis))))"],["br"],["code-text","; (clojure.core/let [\"banana\" bis]"],["br"],["code-text",";   ((println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text",";    (println (.readLine bis)))"],["br"],["code-text",";   (.close \"banana\"))"],["br"]],["paragraph",["br"]],["paragraph",["text","Na primeira linha da expansão vemos um "],["italic",["text","binding"]],["text"," atribuindo o valor de "],["monospaced",["text","bis"]],["text",", que contém uma instância de "],["monospaced",["text","DataInputStream"]],["text"," para a "],["italic",["text","String"]],["text"," "],["monospaced",["text","banana"]],["text",". Não só não funciona como nem ao menos faz sentido."],["br"]],["paragraph",["text","Na última linha a coisa não fica melhor. A macro vai tentar executar o método "],["monospaced",["text","close"]],["text"," em um texto, o que também não funciona nem faz sentido."],["br"]],["code","clojure",["br"],["code-text","(using bis"],["br"],["code-text","  (println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text","  (println (.readLine bis)))"],["br"],["code-text","; Exception Unsupported binding form: banana"],["br"]],["paragraph",["br"]],["index",["text","higiene de macro"]],["paragraph",["br"]],["paragraph",["text","Para resolver essa sujeira causada pelo vazamento, vamos usar um recurso chamado "],["italic",["text","higiene de macro"]],["text"," ou "],["italic",["text","expansão higiênica de macros"]],["text",". Sim, o nome é esse mesmo. Vamos tornar nossa macro "],["italic",["text","higiênica"]],["ref",["text","hygienic-macro"]],["text","."],["br"]],["box",["text","Higiene"],["paragraph",["br"]],["paragraph",["text","Você vai encontrar material sobre macros higiênicas em Inglês com o nome de "],["italic",["text","hygienic macros"]],["text"," ou "],["italic",["text","hygienic macro expansion"]],["text","."],["br"]]],["paragraph",["br"]],["paragraph",["text","Para isso vamos usar um operador chamado "],["italic",["text","gensym"]],["text",", do Inglês "],["italic",["text","generated symbol"]],["text",". "],["italic",["text","Gensym"]],["text"," vai dizer ao compilador que ele deve gerar um símbolo, por isso o nome, cujo nome ainda não esteja sendo utilizado."],["br"]],["index",["text","#"]],["paragraph",["br"]],["paragraph",["text","Para isso basta utilizarmos o caracter "],["monospaced",["text","#"]],["text"," após o nome do símbolo."],["br"]],["code","clojure",["br"],["code-text","`temp#"],["br"],["code-text","; temp__769__auto__"],["br"],["code-text","`a#"],["br"],["code-text","; a__772__auto__"],["br"],["code-text","`(a# b# c#)"],["br"],["code-text","; (a__775__auto__ b__776__auto__ c__777__auto__)"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos agora fazer com que "],["monospaced",["text","temp"]],["text"," seja gerado no momento da criação da macro. Vamos manter o "],["italic",["text","var"]],["text"," "],["monospaced",["text","temp"]],["text"," contendo "],["italic",["text","banana"]],["text"," para termos certeza de que dessa vez não vai haver vazamento:"],["br"]],["code","clojure",["br"],["code-text","(def temp \"banana\")"],["br"],["code-text","(defmacro using [resource & body]"],["br"],["code-text","  `(let [temp# ~resource]"],["br"],["code-text","     (println ~body)"],["br"],["code-text","     ~body"],["br"],["code-text","     (.close temp#)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Compilou sem erro. Vamos ver agora a versão expandida."],["br"]],["code","clojure",["br"],["code-text","(macroexpand-1 '(using bis"],["br"],["code-text","                  (println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text","                  (println (.readLine bis))))"],["br"],["code-text","; (clojure.core/let [temp__772__auto__ bis]"],["br"],["code-text",";   ((println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text",";    (println (.readLine bis)))"],["br"],["code-text",";   (.close temp__772__auto__))"],["br"]],["paragraph",["br"]],["paragraph",["text","Note o símbolo "],["monospaced",["text","temp_772_auto_"]],["text",", criado especialmente para a nossa macro. Pode ficar tranquilo que não há chance de que esse símbolo interfira em algo que exista fora da macro. Perceba também que o "],["italic",["text","var"]],["text"," "],["monospaced",["text","temp"]],["text"," com sua banana nem ao menos aparecem."],["br"]],["paragraph",["text","Ainda há um problema no nosso código expandido, mas já vamos chegar nele."],["br"]],["paragraph",["text","Finalmente, vamos executar a macro para ver o que acontece."],["br"]],["code","clojure",["br"],["code-text","(using bis"],["br"],["code-text","  (println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text","  (println (.readLine bis)))"],["br"],["code-text","; Exibindo a primeira linha do arquivo"],["br"],["code-text","; Linha 1"],["br"],["code-text","; NullPointerException   user/eval788 (NO_SOURCE_FILE:3)"],["br"]],["paragraph",["br"]],["index",["text","java.lang.NullPointerException"]],["paragraph",["br"]],["paragraph",["text","Ah, o sempre nefasto "],["monospaced",["text","NullPointerException"]],["text","."],["br"]],["paragraph",["text","Se voltamos à expansão da macro, na linha "],["monospaced",["text","2"]],["text"," vamos ver dois parênteses sendo abertos."],["br"]],["code","clojure",["br"],["code-text","; (clojure.core/let [temp__772__auto__ bis]           1"],["br"],["code-text",";   ((println \"Exibindo a primeira linha do arquivo\") 2"],["br"],["code-text",";    (println (.readLine bis)))                       3"],["br"],["code-text",";   (.close temp__772__auto__))                       4"],["br"]],["paragraph",["br"]],["paragraph",["text","Lembre-se que as expressões são avaliadas de dentro para fora, da esquerda para a direita."],["br"]],["paragraph",["text","A primeira expressão, que exibe a mensagem \"Exibindo a primeira linha do arquivo\", retorna "],["monospaced",["text","nil"]],["text"," por conta do "],["monospaced",["text","println"]],["text",". A expressão seguinte, também com "],["monospaced",["text","println"]],["text",", também retorna "],["monospaced",["text","nil"]],["text","."],["br"]],["paragraph",["text","Com isso nossa expressão acaba virando "],["monospaced",["text","(nil nil)"]],["text","."],["br"]],["paragraph",["text","Como o primeiro item da lista deve ser um operador, o compilador tenta invocar o método "],["monospaced",["text","invoke"]],["text",", como vimos no capítulo "],["ref-label",["text","capitulo-funcoes"]],["text",". Ao tentar executar um método em um valor nulo, temos o tal "],["monospaced",["text","NullPointerException"]],["text","."],["br"]],["paragraph",["text","Tudo muito legal, mas como resolver?"],["br"]],["paragraph",["text","Nosso argumento "],["monospaced",["text","body"]],["text"," é um vetor contendo as expressões que devem ser executadas enquanto o recurso estiver aberto. Para que essas expressões sejam executadas uma a uma, devemos utilizar um tipo específico de "],["italic",["text","unquote"]],["text",", chamado "],["italic",["text","unquote splicing"]],["text",". Ao invés de utilizarmos o operador "],["monospaced",["text","~"]],["text",", vamos utilizar "],["monospaced",["text","~@"]],["text","."],["br"]],["paragraph",["text","Mais para o início do capítulo vimos o operador "],["monospaced",["text","~@"]],["text"," mas não entramos em detalhe sobre o que ele faz nem como funciona."],["br"]],["paragraph",["text","Vamos modificar o código da macro e expandir para ver como ficou."],["br"]],["code","clojure",["br"],["code-text","(defmacro using [resource & body]"],["br"],["code-text","  `(let [temp# ~resource]"],["br"],["code-text","     ~@body"],["br"],["code-text","     (.close temp#)))"],["br"],["code-text","(macroexpand-1 '(using bis"],["br"],["code-text","                  (println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text","                  (println (.readLine bis))))"],["br"],["code-text","; (clojure.core/let [temp__843__auto__ bis]"],["br"],["code-text",";   (println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text",";   (println (.readLine bis))"],["br"],["code-text",";   (.close temp__843__auto__))"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que as expressões que foram passadas por parâmetro agora estão no mesmo nível de aninhamento da chamada ao método "],["monospaced",["text","close"]],["text",". Com isso matamos o problema do "],["monospaced",["text","NullPointerException"]],["text","."],["br"]],["paragraph",["text","Vamos executar o código completo para ver nossa macro funcionando redondinha:"],["br"]],["code","clojure",["br"],["code-text","(import java.io.DataInputStream"],["br"],["code-text","        java.io.FileInputStream"],["br"],["code-text","        java.io.File)"],["br"],["code-text","(def bis (DataInputStream."],["br"],["code-text","           (FileInputStream."],["br"],["code-text","             (File. \"arquivo.txt\"))))"],["br"],["code-text","(using bis"],["br"],["code-text","  (println \"Exibindo a primeira linha do arquivo\")"],["br"],["code-text","  (println (.readLine bis)))"],["br"],["code-text","; Exibindo a primeira linha do arquivo"],["br"],["code-text","; Linha 1"],["br"]],["paragraph",["br"]],["paragraph",["text","Funcionou."],["br"]],["paragraph",["text","Podemos inclusive melhorar o código da nossa macro adicionando tratamento de erros. Dessa forma, mesmo que algo dê errado durante a execução do corpo da macro, o recurso será fechado."],["br"]],["code","clojure",["br"],["code-text","(defmacro using [resource & body]"],["br"],["code-text","  `(let [temp# ~resource]"],["br"],["code-text","     (try"],["br"],["code-text","       ~@body"],["br"],["code-text","       (finally"],["br"],["code-text","        (.close temp#)))))"],["br"]],["paragraph",["br"]],["index",["text","with-open"]],["paragraph",["br"]],["paragraph",["text","Caso você queira usar a nossa macro "],["monospaced",["text","using"]],["text",", o Clojure oferece a funcionalidade com o nome de "],["monospaced",["text","with-open"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(import java.io.DataInputStream"],["br"],["code-text","        java.io.FileInputStream"],["br"],["code-text","        java.io.File)"],["br"],["code-text","(with-open [bis (DataInputStream."],["br"],["code-text","                  (FileInputStream."],["br"],["code-text","                    (File. \"arquivo.txt\")))]"],["br"],["code-text","  (println (.readLine bis)))"],["br"],["code-text","; Linha 1"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que a implementação padrão do Clojure é bem mais sofisticada que a nossa, além de conter na própria declaração a abertura do arquivo. Caso você tenha curiosidade de ver o código, basta digitar "],["monospaced",["text","(source with-open)"]],["text"," no "],["italic",["text","REPL"]],["text","."],["br"]],["paragraph",["text","Ainda falta o operador "],["monospaced",["text","each"]],["text",", em que vamos imitar o método de mesmo nome do Ruby."],["br"]],["paragraph",["text","A macro "],["monospaced",["text","each"]],["text"," vai trabalhar com dois argumentos. No primeiro temos um "],["italic",["text","binding"]],["text"," onde cada membro de uma sequencia será atribuido para um símbolo. O segundo argumento é o código a ser executado com esse símbolo."],["br"]],["code","clojure",["br"],["code-text","(def lista-itens (range 1 11))"],["br"],["code-text","(each [item lista-itens]"],["br"],["code-text","  (println (* 2 item)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos utilizar de "],["italic",["text","destructuring"]],["text"," na lista de parâmetros da macro para podermos separar o símbolo do valor a ser atribuído."],["br"]],["code","clojure",["br"],["code-text","(defmacro each [[item list] & body]"],["br"]],["paragraph",["br"]],["paragraph",["text","Na macro "],["monospaced",["text","each"]],["text"," temos que lembrar do que é um "],["italic",["text","símbolo"]],["text",". Um símbolo é um tipo de dado que aponta para outro dado, por isso usamos símbolos para "],["italic",["text","binding"]],["text",". "],["italic",["text","Binding"]],["text"," significa, ao pé da letra, "],["italic",["text","amarração"]],["text",". Então pense que amarramos um valor a um símbolo."],["br"]],["paragraph",["text","Dito isso, podemos considerar um símbolo como um tipo de dado como qualquer outro, e ele de fato é, que pode ser passado por parâmetro como qualquer outro tipo."],["br"]],["paragraph",["text","Em tempo de execução o símbolo será avaliado e teremos um erro caso ele não tenha um valor atribuído. Já em tempo de compilação podemos passar um símbolo livremente sem medo de erros, desde que no momento da execução o símbolo tenha um valor atribuído."],["br"]],["paragraph",["text","Vamos utilizar esse símbolo no "],["italic",["text","binding"]],["text"," do "],["monospaced",["text","loop"]],["text",", já que vamos consumir a sequencia utilizando "],["italic",["text","tail call recursion"]],["text",". Veja os diversos conceitos que viemos aprendendo até aqui sendo utilizados na prática."],["br"]],["paragraph",["text","Vamos criar também um "],["italic",["text","gemsys"]],["text"," para armazenar o resto da lista, já que o primeiro item, que é o que interessa para o corpo, vai ser amarrado ao símbolo que foi recebido por parâmetro."],["br"]],["code","clojure",["br"],["code-text","  `(loop [~item (first ~list)"],["br"],["code-text","          list# (next ~list)]"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos definir a condição de parada do "],["monospaced",["text","loop"]],["text",": quando a lista terminar de ser consumida, devemos finalizar a execução da macro. Antes disso, devemos executar as instruções do corpo."],["br"]],["paragraph",["text","Finalmente, vamos pegar o primeiro item do resto da lista e atribuí-lo novamente ao símbolo, enquanto o resto do resto da lista fica no "],["italic",["text","gensym"]],["text","."],["br"]],["code","clojure",["br"],["code-text","    (when list#"],["br"],["code-text","      ~@body"],["br"],["code-text","      (recur (first list#)"],["br"],["code-text","             (next list#)))))"],["br"]],["paragraph",["br"]],["paragraph",["text","Terminamos. O nosso código completo ficaria assim:"],["br"]],["code","clojure",["br"],["code-text","(defmacro each [[item list] & body]"],["br"],["code-text","  `(loop [~item (first ~list)"],["br"],["code-text","          list# (next ~list)]"],["br"],["code-text","    (when list#"],["br"],["code-text","      ~@body"],["br"],["code-text","      (recur (first list#)"],["br"],["code-text","             (next list#)))))"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos ver o nosso código funcionando:"],["br"]],["code","clojure",["br"],["code-text","(def lista-itens (range 1 11))"],["br"],["code-text","(each [item lista-itens]"],["br"],["code-text","  (println (* 2 item)))"],["br"],["code-text","; 2"],["br"],["code-text","; 4"],["br"],["code-text","; 6"],["br"],["code-text","; 8"],["br"],["code-text","; 10"],["br"],["code-text","; 12"],["br"],["code-text","; 14"],["br"],["code-text","; 16"],["br"],["code-text","; 18"],["br"]],["paragraph",["br"]],["paragraph",["text","Simples assim nós conseguimos criar operadores no Clojure tão bacanas quanto aqueles de outras linguagens."],["br"]],["section",["text","Quando usar e quando não usar macros"]],["paragraph",["br"]],["paragraph",["text","Quando tive meus primeiros contatos com um dialeto LISP, tinha ouvido falar maravilhas a respeito de macros e achava que dominando o assunto eu me tornaria um mestre na linguagem."],["br"]],["paragraph",["text","Ledo engano."],["br"]],["paragraph",["text","Macros são uma parte importante da linguagem e devem sim ser estudadas, mas não podemos nos esquecer de alguns pequenos detalhes antes de decidirmos escrever uma macro."],["br"]],["title",["text","Não escreva uma macro se uma função pode resolver"]],["paragraph",["br"]],["paragraph",["text","Existem casos em que uma macro resolve problemas que uma função não consegue, como vimos ao criar a macro "],["monospaced",["text","unless"]],["text","."],["br"]],["paragraph",["text","Porém, uma das grandes vantagens da programação funcional é justamente o fato de uma função ser considerada um valor. Isso nos permite passar funções por parâmetro para outra função ou fazer com que uma função devolva outra função como resultado."],["br"]],["paragraph",["text","Com macros não temos isso, o que faz com que macros não sejam funcionais."],["br"]],["code","clojure",["br"],["code-text","(defmacro m+ [a b]"],["br"],["code-text","  `(+ ~a ~b))"],["br"],["code-text","(m+ 2 3)"],["br"],["code-text","; 5"],["br"],["code-text","(apply m+ [1 2 3 4])"],["br"],["code-text","; CompilerException java.lang.RuntimeException: Can't take value of a"],["br"],["code-text","; macro: #'user/m+,"],["br"]],["paragraph",["br"]],["paragraph",["text","Macros são executadas em tempo de compilação, num momento em que funções e seus valores ainda não existem. Já as funções são executadas em tempo de execução, num momento em que a macro já foi criada, executada e já saiu para comprar cigarro para nunca mais voltar."],["br"]],["paragraph",["text","Veja um exemplo bacana do que acontece ao misturarmos macros e funções. Relaxe, é algo que acontece o tempo todo."],["br"]],["code","clojure",["br"],["code-text","(defmacro minha-macro []"],["br"],["code-text","  (println \"Macro sendo executada\")"],["br"],["code-text","  6)"],["br"],["code-text","(defn minha-funcao []"],["br"],["code-text","  (println \"E o valor é\" (minha-macro)))"],["br"],["code-text","; Macro sendo executada"],["br"],["code-text","; #'user/minha-funcao"],["br"],["code-text","user=> (minha-funcao)"],["br"],["code-text","; E o valor é 6"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que "],["monospaced",["text","minha-macro"]],["text"," foi executada enquanto "],["monospaced",["text","minha-funcao"]],["text"," estava sendo criada. na prática é como se o corpo de "],["monospaced",["text","minha-funcao"]],["text"," se transformasse em "],["monospaced",["text","(println \"E o valor é\" 6))"]],["text"," instantes antes de ser executado."],["br"]],["paragraph",["text","Partindo do princípio de que, em uma linguagem funcional, uma função é tratada como um valor qualquer, eis uma regra simples de lembrar: função é valor que gera ou transforma valor, enquanto macro é código que gera código."],["br"]],["title",["text","Macros são mais difíceis de desenvolver"]],["paragraph",["br"]],["paragraph",["text","Macros são mais difíceis de desenvolver do que funções. Não difícil no sentido de conseguir a paz mundial ou de achar graça da piada do seu chefe, mas no sentido de que exige um pouco mais de atenção e cuidado para escrever e depois caçar possíveis erros."],["br"]],["paragraph",["text","Macros são expandidas e executadas em tempo de compilação. Quando ocorre algum erro durante a execução de uma macro, podemos não ter toda aquela informação sobre local do erro, número de linha e mesmo as mensagens de erro exigem um pouco mais de atenção sobre o que está acontecendo."],["br"]],["paragraph",["text","Quando escrevemos uma macro, temos que pensar "],["italic",["text","em duas camadas"]],["text",". Particularmente eu penso primeiro no código que eu quero após a expansão. Para isso escrevo código Clojure que faz o que preciso, sem pensar em macros."],["br"]],["paragraph",["text","Com esse código funcionando eu começo a transformá-lo em macro. Primeiro eu pensei no que preciso para o tempo de execução e depois converto para o que preciso em tempo de compilação. Você teve mostras disso na forma como as nossas macros foram criadas."],["br"]],["paragraph",["text","Com tempo e experiência nada impede que você escreva a macro diretamente, expandindo o código dentro da sua cabeça. Mas digo por experiência própria que qualquer erro que ocorra pode ser bem mais difícil de encontrar."],["br"]],["index",["text","macroexpand"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(defmacro causa-erro [valor]"],["br"],["code-text","  `(let [~'simbolo# ~valor]"],["br"],["code-text","     (println simbolo)))"],["br"],["code-text","(causa-erro :angu)"],["br"],["code-text","; CompilerException java.lang.RuntimeException: No such var:"],["br"],["code-text","; user/simbolo, compiling:(NO_SOURCE_PATH:1:1)"],["br"]],["paragraph",["br"]],["paragraph",["italic",["text","Ué, mas eu declarei "],["monospaced",["text","simbolo"]],["text"," no meu código."]],["br"]],["code","clojure",["br"],["code-text","(macroexpand '(causa-erro :angu))"],["br"],["code-text","; (let* [simbolo :angu] (clojure.core/println user/simbolo))"],["br"]],["paragraph",["br"]],["paragraph",["italic",["text","Ah, faltou um "],["monospaced",["text","quote"]],["text"," no meu código."]],["br"]],["title",["text","Uma macro pode ser usada para otimizar o código"]],["paragraph",["br"]],["paragraph",["text","Assim como a compilação "],["italic",["text","ahead-of-time"]],["text"," simplesmente muda o momento em que a compilação ocorre, mover um processamento pesado para uma macro move o momento em que a demora ocorre. Passamos a perder algum tempo na compilação para ganhar tempo em execução."],["br"]],["paragraph",["text","Além de técnicas como "],["italic",["text","type hinting"]],["text"," e memoização, essa pode ser uma abordagem a ser considerada, dependendo do caso."],["br"]],["paragraph",["text","Vamos supor que nossa função contenha um cálculo que leve trinta segundos para ser executado."],["br"]],["code","clojure",["br"],["code-text","(defn funcao-demorada []"],["br"],["code-text","  (println \"Calculando\")"],["br"],["code-text","  (Thread/sleep 30000)"],["br"],["code-text","  42)"],["br"],["code-text","(time (funcao-demorada))"],["br"],["code-text","; Calculando"],["br"],["code-text","; \"Elapsed time: 29999.913863 msecs\""],["br"],["code-text","; 42"],["br"]],["paragraph",["br"]],["paragraph",["text","Movendo o cálculo para uma macro, podemos ter o seguinte:"],["br"]],["code","clojure",["br"],["code-text","(defmacro calculo-demorado []"],["br"],["code-text","  (Thread/sleep 30000)"],["br"],["code-text","  42)"],["br"],["code-text","(defn funcao-demorada-2 []"],["br"],["code-text","  (println \"Calculando\")"],["br"],["code-text","  (calculo-demorado))"],["br"],["code-text","(time (funcao-demorada-2))"],["br"],["code-text","; Calculando"],["br"],["code-text","\"Elapsed time: 1.685714 msecs\""],["br"],["code-text","; 42"],["br"]],["paragraph",["br"]],["paragraph",["text","A execução ficou bem mais rápida. Note que a macro foi encapsulada em uma função para não perdermos as propriedades de "],["italic",["text","high order function"]],["text"," ou de composição da nossa função original."],["br"]],["paragraph",["text","Podemos também utilizar macros para determinar valores que não devem ser alterados a partir da compilação. Uma versão ou a data de compilação, por exemplo."],["br"]],["paragraph",["text","Vamos imaginar que temos um arquivo chamado "],["monospaced",["text","versao.txt"]],["text"," que é gerado automaticamente durante a compilação da sua aplicação."],["br"]],["paragraph",["text","Esse arquivo tem apenas uma linha escrita "],["monospaced",["text","1.2.3"]],["text",". Nada mais."],["br"]],["code","clojure",["br"],["code-text","(defmacro versao-sistema []"],["br"],["code-text","  (slurp \"versao.txt\"))"],["br"],["code-text","(defn info-sistema []"],["br"],["code-text","  (println \"Versão: \" (versao-sistema)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Considerando que tenha sido utilizada compilação "],["italic",["text","AOT"]],["text",", você distribui sua aplicação sem o tal arquivo. Como estamos usando o "],["italic",["text","REPL"]],["text",", vamos renomear ou apagar o arquivo."],["br"]],["code","clojure",["br"],["code-text","(info-sistema)"],["br"],["code-text","; Versão:  1.2.3"],["br"]],["paragraph",["br"]],["paragraph",["text","A função funciona sem problemas. Não precisamos mais do arquivo "],["monospaced",["text","versao.txt"]],["text"," porque seu conteúdo já foi lido em tempo de compilação."],["br"]],["paragraph",["text","Podemos expandir a brincadeira tambem:"],["br"]],["code","clojure",["br"],["code-text","(defmacro data-compilacao []"],["br"],["code-text","  (java.util.Date.))"],["br"],["code-text","(defn data-agora []"],["br"],["code-text","  (java.util.Date.))"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que, com exceção os operadores "],["monospaced",["text","defmacro"]],["text"," e "],["monospaced",["text","defn"]],["text"," os códigos são exatamente iguais."],["br"]],["code","clojure",["br"],["code-text","(defn info-data []"],["br"],["code-text","  (println \"Sistema compilado em\" (data-compilacao))"],["br"],["code-text","  (println \"Data e hora atuais  \" (data-agora))"],["br"],["code-text","  (Thread/sleep 5000))"],["br"],["code-text","(repeatedly 3 info-data)"],["br"],["code-text","; Sistema compilado em #inst \"2015-01-31T13:26:18.526-00:00\""],["br"],["code-text","; Data e hora atuais   #inst \"2015-01-31T13:26:18.595-00:00\""],["br"],["code-text","; Sistema compilado em #inst \"2015-01-31T13:26:18.526-00:00\""],["br"],["code-text","; Data e hora atuais   #inst \"2015-01-31T13:26:23.596-00:00\""],["br"],["code-text","; Sistema compilado em #inst \"2015-01-31T13:26:18.526-00:00\""],["br"],["code-text","; Data e hora atuais   #inst \"2015-01-31T13:26:28.600-00:00\""],["br"]],["paragraph",["br"]],["paragraph",["text","A função "],["monospaced",["text","repeatedly"]],["text"," faz com que uma função passada por parâmetro seja repetida por quantas vezes quisermos."],["br"]],["paragraph",["text","Note que a data de compilação permanece inalterada enquanto a data e horas atuais são atualizadas a cada cinco segundos."],["br"]],["index",["text","macros, &env"]],["paragraph",["br"]],["index",["text","macros, &post"]],["paragraph",["br"]],["section",["text","Os argumentos implícitos &env e &form"]],["paragraph",["br"]],["paragraph",["text","As macros nos presenteiam ainda com dois parâmetros pouco conhecidos e surpreendentes. Eles são considerados parâmetros implícitos porque você não os declara ao criar a sua macro, mas internamente o Clojure dá um jeito de passá-lo para o seu código."],["br"]],["paragraph",["text","Com elas você tem controle não apenas no que será avaliado em tempo de execução, mas também em como sua macro está sendo utilizada e nos "],["italic",["text","bindings"]],["text"," disponíveis no contexto atual."],["br"]],["paragraph",["text","Vamos brincar com o parâmetro "],["monospaced",["text","&env"]],["text",". Ele disponibiliza todos os "],["italic",["text","bindings"]],["text"," disponíveis no contexto em que a macro está sendo executada."],["br"]],["paragraph",["text","Vamos criar uma macro chamada "],["monospaced",["text","mostra-env"]],["text"," que simplesmente exibe o conteúdo de "],["monospaced",["text","&env"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defmacro mostra-env []"],["br"],["code-text","  (println &env))"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que nosso código não usa "],["italic",["text","syntax-quote"]],["text",", já que não temos código para expandir, e sim código para ser executado da forma que está durante a compilação."],["br"]],["code","clojure",["br"],["code-text","(mostra-env)"],["br"],["code-text","; nil"],["br"]],["paragraph",["br"]],["paragraph",["text","Foi impresso "],["monospaced",["text","nil"]],["text"," por não termos nenhum "],["italic",["text","binding"]],["text"," no contexto da execução da macro."],["br"]],["paragraph",["text","Vamos criar um "],["italic",["text","local binding"]],["text"," e testar de novo."],["br"]],["code","clojure",["br"],["code-text","(let [tchubiru \"iéié\"]"],["br"],["code-text","  (mostra-env))"],["br"],["code-text","; {tchubiru #<LocalBinding"],["br"],["code-text","; clojure.lang.Compiler$LocalBinding@7875e769>}"],["br"]],["paragraph",["br"]],["paragraph",["text","De dentro da macro conseguimos encontrar o "],["italic",["text","binding"]],["text"," "],["monospaced",["text","tchubiru"]],["text","."],["br"]],["paragraph",["text","Vamos usar vários para continuar a brincadeira."],["br"]],["code","clojure",["br"],["code-text","(let [tchubiru \"iéié\""],["br"],["code-text","      squidum  \"samba\""],["br"],["code-text","      putsputs \"dance\"]"],["br"],["code-text","  (mostra-env))"],["br"],["code-text","; {putsputs #<LocalBinding"],["br"],["code-text","; clojure.lang.Compiler$LocalBinding@492a88bc>, squidum"],["br"],["code-text","; #<LocalBinding clojure.lang.Compiler$LocalBinding@c280ffd>,"],["br"],["code-text","; tchubiru #<LocalBinding"],["br"],["code-text","; clojure.lang.Compiler$LocalBinding@58b04137>}"],["br"]],["paragraph",["br"]],["paragraph",["text","Reparem que cada "],["italic",["text","local binding"]],["text"," é um objeto do tipo "],["monospaced",["text","LocalBinding"]],["text",". Isso vai nos abrir possibilidades para algumas brincadeiras mais avançadas."],["br"]],["paragraph",["text","Como já dissemos em capítulos anteriores, argumentos de funções também funcionam como "],["italic",["text","local bindings"]],["text",", e podemos provar isso com nossa macro "],["monospaced",["text","mostra-env"]],["text",". Vamos criar uma função com três argumentos para ver o que acontece."],["br"]],["code","clojure",["br"],["code-text","(defn funcao-com-parametros [par1 par2 par3]"],["br"],["code-text","  (mostra-env))"],["br"],["code-text","; {par3 #<LocalBinding clojure.lang.Compiler$LocalBinding@365b00ac>,"],["br"],["code-text","; par2 #<LocalBinding clojure.lang.Compiler$LocalBinding@1653733>,"],["br"],["code-text","; par1 #<LocalBinding clojure.lang.Compiler$LocalBinding@1fb5db38>}"],["br"],["code-text","; #'user/funcao-com-parametros"],["br"]],["paragraph",["br"]],["paragraph",["text","Perceba que os "],["italic",["text","bindings"]],["text"," foram exibidos durante a criação da função, ou seja, durante a fase de compilação."],["br"]],["paragraph",["text","E o que acontece se executarmos a função "],["monospaced",["text","funcao-com-parametros"]],["text","? Que valor será exibido?"],["br"]],["code","clojure",["br"],["code-text","(funcao-com-parametros 1 2 3)"],["br"],["code-text","; nil"],["br"]],["paragraph",["br"]],["paragraph",["text","Como a macro é executada em tempo de compilação e a nossa macro retorna "],["monospaced",["text","nil"]],["text"," por conta do retorno de "],["monospaced",["text","println"]],["text",", é como se a linguagem substituisse a chamada à macro "],["monospaced",["text","mostra-env"]],["text"," por um "],["monospaced",["text","nil"]],["text"," em tempo de execução. E, aliás, é exatamente isso o que acontece."],["br"]],["paragraph",["text","Cada objeto "],["monospaced",["text","LocalBinding"]],["text"," tem uma propriedade "],["monospaced",["text","init"]],["text"," que contém a expressão que foi atribuída ao símbolo. E cada expressão tem um método "],["monospaced",["text","eval"]],["text"," que retorna seu respectivo valor. No final das contas é exatamente isso que o próprio Clojure faz quando utilizamos um símbolo no código."],["br"]],["paragraph",["text","Como estamos trabalhando em tempo de compilação com macros, podemos controlar a compilação como for conveniente."],["br"]],["code","clojure",["br"],["code-text","(defmacro mostra-env-valores []"],["br"],["code-text","  (doseq [[k v] &env]"],["br"],["code-text","    (println k \"=\" (.eval (.init v)))))"],["br"],["code-text","(let [tchubiru \"iéié\""],["br"],["code-text","      squidum  \"samba\""],["br"],["code-text","      putsputs \"dance\"]"],["br"],["code-text","  (mostra-env-valores))"],["br"],["code-text","; putsputs = dance"],["br"],["code-text","; squidum = samba"],["br"],["code-text","; tchubiru = iéié"],["br"]],["paragraph",["br"]],["paragraph",["text","O objeto "],["monospaced",["text","LocalBinding"]],["text"," nos permite saber também se o "],["italic",["text","binding"]],["text"," é ou não um argumento da função atual. Talvez isso seja útil algum dia, quem sabe?"],["br"]],["code","clojure",["br"],["code-text","(defmacro mostra-env-args []"],["br"],["code-text","  (doseq [[k v] &env]"],["br"],["code-text","    (let [arg (if (.isArg v)"],["br"],["code-text","                 \"é\""],["br"],["code-text","                 \"não é\")]"],["br"],["code-text","    (println k \"=\" arg \"um argumento da função\"))))"],["br"],["code-text","(let [tchubiru \"iéié\""],["br"],["code-text","      squidum  \"samba\""],["br"],["code-text","      putsputs \"dance\"]"],["br"],["code-text","  (mostra-env-args))"],["br"],["code-text","; putsputs = não é um argumento da função"],["br"],["code-text","; squidum = não é um argumento da função"],["br"],["code-text","; tchubiru = não é um argumento da função"],["br"],["code-text","; &env = é um argumento da função"],["br"],["code-text","; &form = é um argumento da função"],["br"],["code-text","; #'user/mostra-env-args"],["br"]],["paragraph",["br"]],["box",["text","Cuidado com detalhes de implementação"],["paragraph",["br"]],["paragraph",["text","Apesar de pouco provável, detalhes internos da linguagem sempre podem ser alterados. Amanhã ou depois alguém pode ter uma ideia genial e decidir que "],["monospaced",["text","LocalBinding"]],["text"," pode ser diferente para ser mais rápido e gastar menos memória."],["br"]],["paragraph",["text","De qualquer maneira, eu recomendo fortemente que, quando possível, você olhe o código fonte de qualquer ferramenta que você esteja utilizando e isso inclui o Clojure. Isso pode te ajudar a escrever código que aproveite melhor os recursos da máquina de forma idiomática."],["br"]]],["paragraph",["br"]],["paragraph",["text","Aqui temos uma situação inesperada. Os símbolos "],["monospaced",["text","tchubiru"]],["text",", "],["monospaced",["text","squidum"]],["text"," e "],["monospaced",["text","putsputs"]],["text"," realmente não são argumentos de função. Mas e "],["monospaced",["text","&env"]],["text"," e "],["monospaced",["text","&form"]],["text","? De onde eles surgiram se nem ao menos estamos dentro de uma função."],["br"]],["paragraph",["text","Vamos descobrir."],["br"]],["paragraph",["text","Ao criarmos uma macro, internamente é criado um "],["italic",["text","var"]],["text"," com o nome que demos, e alguma estrutura que não conhecemos ainda é atribuída a esse "],["italic",["text","var"]],["text","."],["br"]],["paragraph",["text","Para sabermos que valor um "],["italic",["text","var"]],["text"," está guardando, usamos o operador "],["monospaced",["text","deref"]],["text"," ou "],["monospaced",["text","@"]],["text",". Vamos usar a nossa macro "],["monospaced",["text","mostra-env"]],["text"," para avaliar isso. Ela foi escolhida apenas por ter o código mais simples, mas você pode testar com qualquer macro que quiser."],["br"]],["code","clojure",["br"],["code-text","@#'mostra-env"],["br"],["code-text","; #<user$mostra_env user$mostra_env@6181b1b2>"],["br"]],["paragraph",["br"]],["paragraph",["text","Certo, temos um objeto do tipo "],["monospaced",["text","user$mostra_env"]],["text",". Até aqui, nenhuma novidade. Lembre que dissemos que uma função no Clojure é representada por uma classe interna dentro de outra classe que tem o nome do "],["italic",["text","namespace"]],["text",". Vamos avaliar então se esse objeto é uma função."],["br"]],["code","clojure",["br"],["code-text","(isa? (class @#'mostra-env) clojure.lang.AFunction)"],["br"],["code-text","; true"],["br"]],["paragraph",["br"]],["paragraph",["text","Surpresa. Internamente uma macro guarda seu código como se fosse uma função. Relembrando que macros e funções são coisas diferentes, mas internamente são armazenadas da mesma forma."],["br"]],["paragraph",["text","Já que o "],["italic",["text","var"]],["text"," "],["monospaced",["text","mostra-env"]],["text"," contém uma função, vamos tentar executá-la."],["br"]],["code","clojure",["br"],["code-text","(@#'mostra-env)"],["br"],["code-text","; ArityException Wrong number of args (0) passed to:"],["br"],["code-text","; user/mostra-env  clojure.lang.AFn.throwArity (AFn.java:429)"],["br"]],["paragraph",["br"]],["paragraph",["text","Esse erro indica que a função deveria receber argumentos e não passamos nenhum. Quantos argumentos nós não sabemos. Vamos então criar uma função auxiliar que retorna a quantidade de argumentos que uma função deve receber. Vamos chamá-la de "],["monospaced",["text","arg-count"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn arg-count [f]"],["br"],["code-text","  (let [m (first (.getDeclaredMethods (class f)))"],["br"],["code-text","        p (.getParameterTypes m)]"],["br"],["code-text","    (alength p)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Aqui usamos mais um pouco de "],["italic",["text","reflection"]],["text",". O método "],["monospaced",["text","getDeclaredMethods"]],["text"," nos retorna um "],["italic",["text","array"]],["text"," com os método daquele objeto. Uma função normalmente vai ter apenas um método, que é justamente "],["monospaced",["text","invoke"]],["text",". Caso tenha mais de um, usamos apenas o primeiro deles. Não é perfeito, mas funciona bem para o que precisamos."],["br"]],["paragraph",["text","Então usamos o método "],["monospaced",["text","getParameterTypes"]],["text"," para retornar um "],["italic",["text","array"]],["text"," contendo os tipos de cada argumento. Por fim, usamos a função "],["monospaced",["text","alength"]],["text"," para saber o tamanho de um "],["italic",["text","array"]],["text"," Java."],["br"]],["paragraph",["text","Juntando tudo temos:"],["br"]],["code","clojure",["br"],["code-text","(arg-count @#'mostra-env)"],["br"],["code-text","; 2"],["br"],["code-text","(@#'mostra-env nil nil)"],["br"],["code-text","; nil"],["br"]],["paragraph",["br"]],["paragraph",["text","Então você se pergunta "],["italic",["text","de onde vieram esses dois argumentos se a nossa macro não tinha argumento nenhum?"]],["br"]],["paragraph",["text","Esses argumentos são justamente "],["monospaced",["text","&form"]],["text"," e "],["monospaced",["text","&env"]],["text",", que ficam escondidos da chamada da macro. Por isso são chamados "],["italic",["text","argumentos implícitos"]],["text","."],["br"]],["paragraph",["text","Já que estamos aqui, vamos descobrir então qual deles é "],["monospaced",["text","&form"]],["text"," e qual deles é "],["monospaced",["text","&env"]],["text",". Vamos passar dois argumentos para a função. Como "],["monospaced",["text","mostra-env"]],["text"," manda exibir "],["monospaced",["text","&env"]],["text",", podemos descobrir facilmente quem é quem."],["br"]],["code",["br"],["code-text","(@#'mostra-env :parametro1 :parametro2)"],["br"],["code-text","; :parametro2"],["br"]],["paragraph",["br"]],["paragraph",["text","Pronto. Sabemos agora que toda macro guarda seu código dentro da estrutura de uma função e que essa função sempre vai ter dois argumentos a mais: "],["monospaced",["text","&form"]],["text"," e "],["monospaced",["text","&env"]],["text"," respectivamente, como podemos ver ao verificarmos as macros abaixo."],["br"]],["code","clojure",["br"],["code-text","(defmacro um-argumento [a] ())"],["br"],["code-text","(arg-count @#'um-argumento)"],["br"],["code-text","; 3"],["br"],["code-text","(defmacro dois-argumentos [a b] ())"],["br"],["code-text","(arg-count @#'dois-argumentos)"],["br"],["code-text","; 4"],["br"],["code-text","(defmacro tres-argumentos [a b c] ())"],["br"],["code-text","(arg-count @#'tres-argumentos)"],["br"],["code-text","; 5"],["br"],["code-text","(defmacro varios-argumentos [& varios] ())"],["br"],["code-text","(arg-count @#'varios-argumentos)"],["br"],["code-text","; 3"],["br"]],["paragraph",["br"]],["paragraph",["text","Podemos usar também "],["monospaced",["text","macroexpand-1"]],["text"," para ver o que é o Clojure faz quando criamos uma macro."],["br"]],["code","clojure",["br"],["code-text","(macroexpand-1"],["br"],["code-text","  '(defmacro varios-argumentos [& varios]"],["br"],["code-text","    (println &env)))"],["br"],["code-text",";(do"],["br"],["code-text",";  (clojure.core/defn varios-argumentos"],["br"],["code-text",";    ([&form &env & varios]"],["br"],["code-text",";      (println &env)))"],["br"],["code-text",";  (. (var varios-argumentos) (setMacro))"],["br"],["code-text",";  (var varios-argumentos))"],["br"]],["paragraph",["br"]],["paragraph",["text","E eis a prova de que o código de uma macro é representado internamente como uma função. O método "],["monospaced",["text","setMacro"]],["text"," adiciona metadado "],["monospaced",["text",":macro true"]],["text",", permitindo ao compilador saber quando executar código em tempo de compilação, no caso de uma macro, e quando executá-lo em tempo de execução, no caso de uma função."],["br"]],["code","clojure",["br"],["code-text","(defmacro uma-macro [] nil)"],["br"],["code-text","(defn uma-funcao [] nil)"],["br"],["code-text","(meta #'uma-macro)"],["br"],["code-text","; {:ns #<Namespace user>, :name uma-macro, :file \"NO_SOURCE_PATH\","],["br"],["code-text","; :column 1, :line 1, :macro true, :arglists ([])}"],["br"],["code-text","(meta #'uma-funcao)"],["br"],["code-text","; {:ns #<Namespace user>, :name uma-funcao, :file \"NO_SOURCE_PATH\","],["br"],["code-text","; :column 1, :line 1, :arglists ([])}"],["br"]],["paragraph",["br"]],["title",["text","A forma &form"]],["paragraph",["br"]],["paragraph",["text","Já o argumento implícito "],["monospaced",["text","&form"]],["text"," nos permite ver a expressão em que a macro foi invocada."],["br"]],["paragraph",["text","Vamos criar uma macro chamada "],["monospaced",["text","mostra-form"]],["text"," para ver na prática."],["br"]],["code","clojure",["br"],["code-text","(defmacro mostra-form []"],["br"],["code-text","  (println &form))"],["br"],["code-text","(mostra-form)"],["br"],["code-text","; (mostra-form)"],["br"]],["paragraph",["br"]],["paragraph",["text","Não parece ter muita graça. Vamos reescrever a macro para que ela aceite vários argumentos."],["br"]],["code","clojure",["br"],["code-text","(defmacro mostra-form [& args]"],["br"],["code-text","  (println &form))"],["br"],["code-text","(mostra-form :um)"],["br"],["code-text","; (mostra-form :um)"],["br"],["code-text","(mostra-form :um :dois)"],["br"],["code-text","; (mostra-form :um :dois)"],["br"],["code-text","(mostra-form :um :dois :tres)"],["br"],["code-text","; (mostra-form :um :dois :tres)"],["br"]],["paragraph",["br"]],["paragraph",["text","Como "],["monospaced",["text","&form"]],["text"," nos retorna uma lista, vamos extrair os argumentos."],["br"]],["code","clojure",["br"],["code-text","(defmacro mostra-form-args [& args]"],["br"],["code-text","  (println (rest &form)))"],["br"],["code-text","; (mostra-form-args 1 2 3)"],["br"],["code-text","; (1 2 3)"],["br"]],["paragraph",["br"]],["paragraph",["text","O argumento "],["monospaced",["text","&form"]],["text"," carrega alguns metadados que podem ser úteis se você estiver desenvolvendo alguma ferramenta que analise código Clojure."],["br"]],["code","clojure",["br"],["code-text","(defmacro mostra-form-meta [& args]"],["br"],["code-text","  (println (meta &form)))"],["br"],["code-text","(mostra-form-meta 1 2 3 4)"],["br"],["code-text","; {:line 1, :column 1}"],["br"]],["paragraph",["br"]],["paragraph",["text","Linha "],["monospaced",["text","1"]],["text"," e coluna "],["monospaced",["text","1"]],["text"," do "],["italic",["text","REPL"]],["text",". Faz sentido."],["br"]],["code","clojure",["br"],["code-text","(let [a 1]"],["br"],["code-text","  (println a)"],["br"],["code-text","  (mostra-form-meta))"],["br"],["code-text","; {:line 3, :column 1}"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora a macro está na linha "],["monospaced",["text","3"]],["text"," do nosso código."],["br"]],["index",["text","reader macros"]],["index",["text","read-macros"]],["paragraph",["br"]],["section",["text","Reader macros"]],["paragraph",["br"]],["todo",["text","a explicação não ficou legal"]],["paragraph",["br"]],["paragraph",["text","Durante a leitura do código, existem duas tabelas de caracteres que indicam se o que vem a seguir é um tipo específico de dados ou se o comportamento do "],["italic",["text","reader"]],["text"," deve ser modificado temporariamente. Esses caracteres são chamados "],["italic",["text","reader macros"]],["text",", ou "],["italic",["text","read-macros"]],["text",".."],["br"]],["paragraph",["text","Para entendermos melhor como esse recurso funciona, vamos dar uma olhada mais detalhada no que acontece durante o ciclo de execução do código Clojure, seja dentro do "],["italic",["text","REPL"]],["text",", seja como uma aplicação a parte."],["br"]],["todo",["text","criar diagrama"]],["paragraph",["br"]],["paragraph",["text","Enquanto no Java podemos executar código apenas em tempo de execução, no Clojure temos, de maneira bem simplificada, três fases distintas"],["ref-label",["text","on-lisp"]],["text",":"],["br"]],["paragraph",["text","- "],["bold",["text","tempo de leitura"]],["text",", momento em que o código é lido e interpretado pelo "],["italic",["text","reader"]],["text",". O código de um "],["italic",["text","reader macro"]],["text"," é executadas nesse momento."],["br"]],["paragraph",["text","- "],["bold",["text","tempo de compilação"]],["text",", momento em que a representação lógica do código gerada pelo "],["italic",["text","reader"]],["text"," é compilada para "],["italic",["text","bytecode"]],["text",". Macros são expandidas e executadas nessa fase."],["br"]],["paragraph",["text","- "],["bold",["text","tempo de execução"]],["text",", momento em que o "],["italic",["text","bytecode"]],["text"," gerado pelo compilador é executado."],["br"]],["paragraph",["text","No "],["italic",["text","REPL"]],["text",", o tempo de leitura representa o "],["italic",["text","R"]],["text",", "],["italic",["text","read"]],["text",", enquanto os tempos de compilação e execução representam o "],["italic",["text","E"]],["text",", "],["italic",["text","evaluate"]],["text",". O "],["italic",["text","P"]],["text",", "],["italic",["text","print"]],["text",", fica no final do tempo de execução."],["br"]],["paragraph",["text","Ao se deparar com um "],["italic",["text","reader macro"]],["text"," o "],["italic",["text","reader"]],["text"," padrão, implementado pela classe "],["monospaced",["text","clojure.lang.LispReader"]],["text",", efetua a leitura do código através de uma função predefinida em uma tabela interna. Essa função trata o trecho seguinte e devolve o controle ao "],["italic",["text","reader"]],["text"," padrão. Normalmente existe um operador equivalente ao "],["italic",["text","reader macro"]],["text"," que pode ser chamado em tempo de execução."],["br"]],["paragraph",["text","Com esse recurso podemos escrever código mais conciso e simples de ler, ou até mesmo código que não tenha a cara habitual do LISP."],["br"]],["title",["text","Os reader macros"]],["paragraph",["br"]],["paragraph",["text","- "],["monospaced",["text",";"]],["text"," - o primeiro deles é o caracter usado para comentários. Você pode utilizar também a macro "],["monospaced",["text","comment"]],["text"," com a vantagem de permitir múltiplas linhas. O problema de usar a macro "],["monospaced",["text","comment"]],["text"," é que você vai receber "],["monospaced",["text","nil"]],["text"," como retorno. Tome cuidado para não deixar que isso atrapalhe o retorno de uma expressão."],["br"]],["code","clojure",["br"],["code-text","; linha comentada"],["br"],["code-text","(comment uma linha"],["br"],["code-text","duas linhas"],["br"],["code-text","três linhas)"],["br"],["code-text","; nil"],["br"]],["paragraph",["br"]],["paragraph",["text","- "],["monospaced",["text","\\"]],["text"," - seguido de um caracter retorna seu respectivo valor como um caracter Java. Equivale a utilizar a função "],["monospaced",["text","char"]],["text"," passando o valor numérico do caracter. Um valor "],["italic",["text","string"]],["text"," é tratado pelo Clojure como uma lista de caracteres, mesmo que na realidade não seja. Vimos isso no capítulo "],["ref-label",["text","capitulo-dados"]],["text","."],["br"]],["code","clojure",["br"],["code-text","\\a"],["br"],["code-text","; \\a"],["br"],["code-text","(char 98)"],["br"],["code-text","; \\b"],["br"],["code-text","(apply list \"batata\")"],["br"],["code-text","; (\\b \\a \\t \\a \\t \\a)"],["br"],["code-text","(str \\b \\a \\t \\a \\t \\a)"],["br"],["code-text","; batata"],["br"],["code-text","(str (char 98) (char 97) (char 116) (char 97) (char 116) (char 97))"],["br"],["code-text","; \"batata\""],["br"]],["paragraph",["br"]],["paragraph",["text","- "],["monospaced",["text","@"]],["text"," - é o operador "],["italic",["text","deref"]],["text",", usado para ver o valor de um "],["italic",["text","atom"]],["text",", "],["italic",["text","ref"]],["text",", "],["italic",["text","var"]],["text",", "],["italic",["text","agent"]],["text",", "],["italic",["text","delay"]],["text",", "],["italic",["text","future"]],["text"," e "],["italic",["text","promise"]],["text",".Quando utilizado com "],["italic",["text","delay"]],["text",", força a execução caso ainda não tenha acontecido. Com "],["italic",["text","future"]],["text"," ou "],["italic",["text","promise"]],["text"," a "],["italic",["text","thread"]],["text"," ficará bloqueada até que o valor seja retornado ou a computação seja concluída. Se utilizarmos com "],["italic",["text","atom"]],["text",", "],["italic",["text","var"]],["text"," ou "],["italic",["text","agent"]],["text"," teremos o valor mais recente armazenado. Você pode usar a macro "],["monospaced",["text","deref"]],["text"," com "],["italic",["text","timeout"]],["text",", se preferir, para que um valor padrão seja retornado caso a computação demore demais."],["br"]],["code","clojure",["br"],["code-text","(def aguarde (delay \"não preciso disso agora\"))"],["br"],["code-text","aguarde"],["br"],["code-text","; #<Delay@31cc4717: :pending>"],["br"],["code-text","@aguarde"],["br"],["code-text","; \"não preciso disso agora\""],["br"],["code-text","@(var +)"],["br"],["code-text","; #<core$_PLUS_ clojure.core$_PLUS_@3e79a799>"],["br"],["code-text","(def aguarde-2 (promise))"],["br"],["code-text","(deref aguarde-2 1000 \"tempo esgotado\")"],["br"],["code-text",";; aguarda um segundo"],["br"],["code-text","; \"tempo esgotado\""],["br"]],["paragraph",["br"]],["paragraph",["text","- "],["monospaced",["text","^"]],["text"," - indica que estamos atribuindo metadados a um símbolo ou valor."],["br"]],["code","clojure",["br"],["code-text","(def ^:batata pure 42)"],["br"],["code-text","(meta #'pure)"],["br"],["code-text","; {:ns #<Namespace user>, :name pure, :batatas true,"],["br"],["code-text","; :file \"NO_SOURCE_PATH\", :column 1, :line 1}"],["br"],["code-text","(def ^{:batata true} fritas 42)"],["br"],["code-text","(meta #'fritas)"],["br"],["code-text","; {:ns #<Namespace user>, :name fritas, :batatas true,"],["br"],["code-text","; :file \"NO_SOURCE_PATH\", :column 1, :line 1}"],["br"]],["paragraph",["br"]],["paragraph",["text","- "],["monospaced",["text","`"]],["text",", "],["monospaced",["text","@"]],["text"," e "],["monospaced",["text","~@"]],["text"," - são os operadores para criação de macros que vimos neste capítulo."],["br"]],["paragraph",["text","- "],["monospaced",["text","("]],["text",", "],["monospaced",["text","▷"]],["text",", "],["monospaced",["text","{"]],["text"," - são utilizados para criarmos listas, vetores e mapas, respectivamente."],["br"]],["title",["text","Dispatch macro"]],["paragraph",["br"]],["paragraph",["text","O "],["italic",["text","dispatch macro"]],["text"," é um tipo especial de "],["italic",["text","reader macro"]],["text"," que delega a responsabilidade do "],["italic",["text","reader"]],["text"," para uma função definida em uma tabela chamada internamente de "],["italic",["text","dispatchMacros"]],["text",". Essa informação vai ser relevante mais para frente."],["br"]],["paragraph",["text","O "],["italic",["text","dispatch macro"]],["text"," é representado pelo caracter "],["monospaced",["text","#"]],["text",". Isso significa que qualquer combinação que você use iniciada por "],["monospaced",["text","#"]],["text"," executará a função correpondente na tabela "],["italic",["text","dispatchMacros"]],["text"," ou vai causar um erro."],["br"]],["code","clojure",["br"],["code-text",";; a combinação #* não existe"],["br"],["code-text","#* a"],["br"],["code-text","; RuntimeException No reader function for tag *"],["br"]],["paragraph",["br"]],["paragraph",["text","Por que, afinal, criar um "],["italic",["text","dispatch macro"]],["text"," quando se tem o alfabeto inteiro para utilizar como "],["italic",["text","reader macro"]],["text","?"],["br"]],["paragraph",["text","O primeiro motivo é que não temos o alfabeto inteiro. Se, por exemplo, utilizarmos "],["monospaced",["text","A"]],["text"," como um "],["italic",["text","reader macro"]],["text"," para funções anônimas, não poderíamos ter mais nenhum símbolo que comece com "],["monospaced",["text","A"]],["text"," maiúsculo."],["br"]],["paragraph",["text","O segundo motivo é que, usando "],["monospaced",["text","A"]],["text"," para definir uma função anônima seria bem ruim de ler."],["br"]],["code","clojure",["br"],["code-text",";; ilegível, certo?"],["br"],["code-text","(map A* % %A (range 1 11))"],["br"]],["paragraph",["br"]],["paragraph",["text","Então o "],["italic",["text","dispatch macro"]],["text"," se torna um ponto de expansão da linguagem, permitindo inclusive a utilização de sintaxes diferentes de "],["italic",["text","S-Expressions"]],["text","."],["br"]],["paragraph",["text","Os "],["italic",["text","reader macros"]],["text"," que fazem uso de "],["italic",["text","dispatch macro"]],["text"," são:"],["br"]],["index",["text","#'"]],["paragraph",["br"]],["paragraph",["text","- "],["monospaced",["text","#'"]],["text"," - é utilizado para referenciarmos "],["italic",["text","var"]],["text",". É equivalente à forma especial "],["monospaced",["text","var"]],["text",". Note que fazer referência ao "],["italic",["text","var"]],["text"," não retorna o valor associado a ele. Para isso devemos usar o operador "],["monospaced",["text","@"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def vaca :muuuuuu)"],["br"],["code-text","#'vaca"],["br"],["code-text","; #'user/vaca"],["br"],["code-text","(var vaca)"],["br"],["code-text","; #'user/vaca"],["br"],["code-text","@#'vaca"],["br"],["code-text","; :muuuuuu"],["br"],["code-text","(deref (var vaca))"],["br"],["code-text","; :muuuuuu"],["br"],["code-text","vaca"],["br"],["code-text","; :muuuuuu"],["br"]],["paragraph",["br"]],["index",["text","java.util.regex.Pattern"]],["paragraph",["br"]],["index",["text","#\""]],["paragraph",["br"]],["paragraph",["text","- "],["monospaced",["text","#\""]],["text"," - é utilizado quando queremos trabalhar com expressões regulares. Por baixo dos panos cria um objeto do tipo "],["monospaced",["text","java.util.regex.Pattern"]],["text",", permitindo a utilização de todas as funcionalidades que o Java traz nativamente para manipular expressões regulares."],["br"]],["code","clojure",["br"],["code-text","(def telefone #\"\\w{3}[-. ]\\w{3}[-. ]\\w{3}\")"],["br"],["code-text","(re-matches telefone \"abcdef\")"],["br"],["code-text","; nil"],["br"],["code-text","(re-matches telefone \"987.654.321\")"],["br"],["code-text","; \"987.654.321\""],["br"],["code-text","(re-matches telefone \"987-654-321\")"],["br"],["code-text","; \"987-654-321\""],["br"]],["paragraph",["br"]],["paragraph",["text","- "],["monospaced",["text","#("]],["text"," - com "],["monospaced",["text","#("]],["text"," nós criamos funções anônimas de forma mais concisa, sem a necessidade de declarar a lista de argumentos. Quando lidamos com apenas um parâmetro utilizamos o caracter "],["monospaced",["text","%"]],["text",", e quando lidamos com mais de um usamos a versão numerada, de acordo com a ordem do parâmetro."],["br"]],["code","clojure",["br"],["code-text","(map #(* % %) (range 1 6))"],["br"],["code-text","; (1 4 9 16 25)"],["br"],["code-text","(map (fn [x] (* x x)) (range 1 6))"],["br"],["code-text","; (1 4 9 16 25)"],["br"],["code-text","(#(* %1 %2 %3 %4) 2 3 4 5)"],["br"],["code-text","; 120"],["br"],["code-text","((fn [a b c d] (* a b c d)) 2 3 4 5)"],["br"],["code-text","; 120"],["br"]],["paragraph",["br"]],["paragraph",["text","- "],["monospaced",["text","#{"]],["text"," - é utilizado para a criação de "],["italic",["text","sets"]],["text",", que são coleções de dados que não se repetem. Podemos também utilizar a função "],["monospaced",["text","set"]],["text"," para o mesmo fim."],["br"]],["code","clojure",["br"],["code-text","#{:a :b :c :c :d :d}"],["br"],["code-text","; IllegalArgumentException Duplicate key: :c"],["br"],["code-text","(def vogal? #{\\a \\e \\i \\o \\u})"],["br"],["code-text","(vogal? \\a)"],["br"],["code-text","; \\a"],["br"],["code-text","(vogal? \\b)"],["br"],["code-text","; nil"],["br"],["code-text","(set \"batata\")"],["br"],["code-text","; #{\\a \\b \\t}"],["br"]],["paragraph",["br"]],["paragraph",["text","- "],["monospaced",["text","#_"]],["text"," - diz ao "],["italic",["text","reader"]],["text"," que a próxima expressão deve ser descartada. Enquanto o "],["italic",["text","reader macro"]],["text"," de comentário ignora toda a linha, esse "],["italic",["text","macro reader"]],["text"," ignora uma expressão completa, que pode ocupar várias linhas ou apenas um símbolo. É um recurso bem útil durante o desenvolvimento, quando você precisa ignorar uma expressão completa, já que é mais simples do que comentar inúmeras linhas."],["br"]],["code","clojure",["br"],["code-text","(+ 1 2 3 #_ 4) ; descarta o 4"],["br"],["code-text","; 6"],["br"],["code-text","(+ 1 2 #_ 3 4) ; descarta o 3"],["br"],["code-text","; 7"],["br"],["code-text","(map"],["br"],["code-text","  #_ (fn [x] (* 2 x)) odd? ; descarta '(fn ...)'' e deixa 'odd?'"],["br"],["code-text","  (range 2 7))"],["br"],["code-text","; (false true false true false)"],["br"]],["paragraph",["br"]],["todo",["text","se der tempo, falar sobre tagged literals e data-readers"]],["paragraph",["br"]],["section",["text","Criando reader macros"]],["paragraph",["br"]],["paragraph",["text","Por padrão, o Clojure não permite a criação de "],["italic",["text","reader macros"]],["text"," além daquelas que já vêm com a linguagem. Para quem vem do Common Lisp esse é um dos pontos que causa a maior estranheza. Já para quem vem do Java, Ruby ou outras linguagens mais conhecidas, isso não muda muita coisa. De acordo com o criador da linguagem, não existe previsão ou intenção de implementar esse recurso na linguagem"],["ref",["text","clojure-reader-macro"]],["text","."],["br"]],["paragraph",["text","Um dos problemas que isso pode trazer é a possibilidade de duas bibliotecas definirem o mesmo "],["italic",["text","reader macro"]],["text"," para coisas diferentes. Apenas o que foi declarado em uma das bibliotecas vai funcionar, trazendo comportamentos totalmente imprevistos para a outra. Já macros normais podem ter o mesmo nome em bibliotecas diferentes, uma vez que ambas estariam separadas em seus próprios "],["italic",["text","namespaces"]],["text","."],["br"]],["paragraph",["text","Ou, nas palavras do pai da criança:"],["br"]],["quote",["text","\"Conforme o tempo passa eu me torno mais inflexível na minha decisão de não suportar reader macros. (...) Enquanto reader macros tornam a linguagem ainda mais poderosa, elas têm como preço a falta de interoperabilidade, muito mais do que macros comuns, que podem ser colocadas em namespaces\""],["text","  -- Rich Hickey, criador do Clojure"]],["paragraph",["br"]],["paragraph",["text","Porém, Clojure é uma linguagem flexível num nível muito além do que você imagina. Por mais que a linguagem não disponibilize uma forma de criarmos nossos próprios "],["italic",["text","reader macros"]],["text",", podemos alterá-la para adicionar os recursos que desejarmos."],["br"]],["paragraph",["text","Deixo claro, como um aviso, de que esse recurso não deve ser utilizado em produção. Estou demonstrando aqui para que você possa entender melhor como a linguagem funciona por dentro, como podemos estendê-la e também porque a curiosidade nos move e nos desafia."],["br"]],["paragraph",["text","Este seria um livro muito chato se eu me limitasse a apresentar o feijão-com-arroz da linguagem, certo?"],["br"]],["paragraph",["text","Vamos por a mão na massa então."],["br"]],["paragraph",["text","Anteriormente eu havia dito que existe uma tabela interna chamada "],["italic",["text","dispatchMacros"]],["text",", contendo as funções que serão executadas ao utilizarmos o "],["italic",["text","dispatch macro"]],["text",". Essa tabela nada mais é do que um "],["italic",["text","array"]],["text"," de objetos que implementam "],["monospaced",["text","clojure.lang.IFn"]],["text"," e, apesar de não ser um membro público de "],["monospaced",["text","clojure.lang.LispReader"]],["text",", podemos fazer uso de "],["italic",["text","reflection"]],["text"," para acessá-lo."],["br"]],["paragraph",["text","Primeiro vamos acessar o campo "],["monospaced",["text","dispatchMacros"]],["text"," da classe "],["monospaced",["text","clojure.lang.LispReader"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(.getDeclaredField clojure.lang.LispReader \"dispatchMacros\")"],["br"],["code-text","; #<Field static clojure.lang.IFn[]"],["br"],["code-text","; clojure.lang.LispReader.dispatchMacros>"],["br"]],["paragraph",["br"]],["index",["text","java.lang.reflect.Field"]],["paragraph",["br"]],["paragraph",["text","O método "],["monospaced",["text","getDeclaredField"]],["text"," nos retorna um objeto do tipo "],["monospaced",["text","Field"]],["text",". Vale lembrar que esse objeto não é imutável, como estamos habituados no Clojure."],["br"]],["paragraph",["text","Vamos então permitir que o campo seja acessado de fora da classe, mesmo não sendo público. Para isso vamos usar o método "],["monospaced",["text","setAccessible"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(let [dispatch-macros (.getDeclaredField"],["br"],["code-text","                         clojure.lang.LispReader"],["br"],["code-text","                         \"dispatchMacros\")]"],["br"],["code-text","  (.setAccessible dispatch-macros true))"],["br"],["code-text","; nil"],["br"]],["paragraph",["br"]],["index",["text","void"]],["paragraph",["br"]],["paragraph",["text","O método "],["monospaced",["text","setAccessible"]],["text"," tem o tipo "],["monospaced",["text","void"]],["text",", o que no Clojure equivale a retornar "],["monospaced",["text","nil"]],["text","."],["br"]],["paragraph",["text","Para retornarmos o valor desse campo vamos utilizar o método "],["monospaced",["text","get"]],["text",", passando "],["monospaced",["text","nil"]],["text"," como parâmetro."],["br"]],["code","clojure",["br"],["code-text","(let [dispatch-macros"],["br"],["code-text","      (.getDeclaredField clojure.lang.LispReader \"dispatchMacros\")]"],["br"],["code-text","  (.setAccessible dispatch-macros true)"],["br"],["code-text","  (.get dispatch-macros nil))"],["br"],["code-text","; #<IFn[] [Lclojure.lang.IFn;@37272973>"],["br"],["code-text","; ]"],["br"]],["paragraph",["br"]],["index",["text","clojure.lang.IFn"]],["paragraph",["br"]],["paragraph",["text","Agora temos um "],["italic",["text","array"]],["text"," de objetos do tipo "],["monospaced",["text","IFn"]],["text",", que é exatamente o que estávamos esperando."],["br"]],["paragraph",["text","Esse "],["italic",["text","array"]],["text"," tem 256 posições, sendo uma para cada caracter da "],["italic",["text","tabela ASCII"]],["text",". Dessa forma, o caracter "],["monospaced",["text","#"]],["text"," fica na posição 35, que é o seu valor na tal tabela."],["br"]],["index",["text","int"]],["paragraph",["br"]],["paragraph",["text","Para sabermos o valor numérico do caracter, temos que convertê-lo para um inteiro Java usando a função "],["monospaced",["text","int"]],["text",". Perceba que estamos interessados no valor "],["monospaced",["text","int"]],["text"," primitivo do Java, e não na classe "],["monospaced",["text","Integer"]],["text","."],["br"]],["paragraph",["text","Vamos testar o que acontece se acessarmos a posição do caracter "],["monospaced",["text","'"]],["text",". Dessa forma vamos ver que função é executada quando utilizamos o "],["italic",["text","macro reader"]],["text"," "],["monospaced",["text","#'"]],["text","."],["br"]],["index",["text","aget"]],["paragraph",["br"]],["paragraph",["text","Para acessar uma posição de um "],["italic",["text","array"]],["text"," Java devemos usar a função "],["monospaced",["text","aget"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(aget"],["br"],["code-text","  (let [dispatch-macros"],["br"],["code-text","        (.getDeclaredField clojure.lang.LispReader \"dispatchMacros\")]"],["br"],["code-text","    (.setAccessible dispatch-macros true)"],["br"],["code-text","    (.get dispatch-macros nil))"],["br"],["code-text","  (int \\'))"],["br"],["code-text","; #<VarReader clojure.lang.LispReader$VarReader@10be441>"],["br"]],["paragraph",["br"]],["paragraph",["text","E eis que temos um objeto do tipo "],["monospaced",["text","VarReader"]],["text",". Sabendo que "],["monospaced",["text","#'"]],["text"," é exatamente a forma de retornarmos um "],["italic",["text","var"]],["text",", temos certeza de que estamos no caminho certo."],["br"]],["index",["text","aset"]],["paragraph",["br"]],["paragraph",["text","Vamos criar uma função chamada "],["monospaced",["text","dispatch-reader-macro"]],["text"," que recebe dois parâmetros: o caracter que será usado com o "],["italic",["text","dispatch macro"]],["text"," e a função que vai tratar o conteúdo. O que muda em relação ao nosso último código é que vamos utilizar "],["monospaced",["text","aset"]],["text"," para modificar o valor de uma posição do "],["italic",["text","array"]],["text"," e vamos substituir o caracter "],["monospaced",["text","'"]],["text"," pelo caracter que for passado como parâmetro."],["br"]],["code","clojure",["br"],["code-text","(defn dispatch-reader-macro [character function]"],["br"],["code-text","  (aset"],["br"],["code-text","    (let [dispatch-macros (.getDeclaredField"],["br"],["code-text","                             clojure.lang.LispReader"],["br"],["code-text","                             \"dispatchMacros\")]"],["br"],["code-text","      (.setAccessible dispatch-macros true)"],["br"],["code-text","      (.get dispatch-macros nil))"],["br"],["code-text","    (int character)"],["br"],["code-text","    function))"],["br"]],["paragraph",["br"]],["paragraph",["text","A função que passarmos no argumento "],["monospaced",["text","function"]],["text"," vai receber dois parâmetros. O primeiro é uma referência ao próprio "],["italic",["text","reader"]],["text"," e o segundo contém o "],["italic",["text","reader macro"]],["text"," que utilizamos."],["br"]],["paragraph",["text","Vamos criar um "],["italic",["text","reader macro"]],["text"," que recebe um XML e nos retorna um mapa. Ao invés de reinventarmos a roda, vamos utilizar a própria biblioteca "],["monospaced",["text","clojure.xml"]],["text",", que já vem com o Clojure."],["br"]],["paragraph",["text","A biblioteca "],["monospaced",["text","xml.reader"]],["text"," tem uma função "],["monospaced",["text","parse"]],["text"," que não lida diretamente com textos, mas aceita que usemos um "],["monospaced",["text","InputStream"]],["text",". Para passarmos um texto como "],["monospaced",["text","InputStream"]],["text"," podemos usar a classe "],["monospaced",["text","java.io.ByteArrayInputStream"]],["text","."],["br"]],["paragraph",["text","Vamos criar uma lista de compras em formato XML para vê-la funcionando."],["br"]],["code","clojure",["br"],["code-text","(require '[clojure.xml :as xml])"],["br"],["code-text","(def xml \"<compras><item><batata><preco>1.23</preco></batata>"],["br"],["code-text","</item></compras>\")"],["br"],["code-text","(let [bytes  (.getBytes xml)"],["br"],["code-text","      bis    (java.io.ByteArrayInputStream. bytes)"],["br"],["code-text","      result (xml/parse bis)]"],["br"],["code-text","  result)"],["br"],["code-text","; {:tag :compras, :attrs nil, :content [{:tag :item, :attrs nil,"],["br"],["code-text","; :content [{:tag :batata, :attrs nil, :content [{:tag :preco,"],["br"],["code-text","; :attrs nil, :content [\"1.23\"]}]}]}]}"],["br"]],["paragraph",["br"]],["paragraph",["text","Temos nosso XML convertido para um mapa. Vamos fazer então com que o Clojure extraia esse texto do código fonte. Para isso vou utilizar a classe "],["monospaced",["text","StringReader"]],["text",", que é o que o "],["italic",["text","reader"]],["text"," usa para ler dados do tipo "],["italic",["text","string"]],["text",". Ao invés de perder tempo inventando coisas possivelmente com "],["italic",["text","bugs"]],["text",", vamos utilizar o que a própria linguagem nos oferece."],["br"]],["paragraph",["text","Vamos criar uma função chamada "],["monospaced",["text","xml-reader"]],["text",", que usaremos em seguida na definição do "],["italic",["text","reader macro"]],["text",". Ela recebe como parâmetros o "],["italic",["text","reader"]],["text"," do Clojure e o caracter que foi utilizado com o "],["italic",["text","dispatch macro"]],["text",". Nela vamos utilizar "],["monospaced",["text","StringReader"]],["text"," e o nosso código para tratar o XML dentro do texto."],["br"]],["code","clojure",["br"],["code-text","(require '[clojure.xml :as xml])"],["br"],["code-text","(defn xml-reader [reader character]"],["br"],["code-text","  (let [chr (.read reader)"],["br"],["code-text","        string-reader (clojure.lang.LispReader$StringReader.)"],["br"],["code-text","        string (.invoke"],["br"],["code-text","                  string-reader"],["br"],["code-text","                  reader"],["br"],["code-text","                  chr)"],["br"],["code-text","        bytes  (.getBytes string)"],["br"],["code-text","        bis    (java.io.ByteArrayInputStream. bytes)"],["br"],["code-text","        result (xml/parse bis)]"],["br"],["code-text","    result))"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos definir o "],["italic",["text","reader macro"]],["text"," "],["monospaced",["text","#X"]],["text"," como o leitor de XML:"],["br"]],["code","clojure",["br"],["code-text","(dispatch-reader-macro \\X xml-reader)"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos utilizar aquele mesmo XML da lista de compras com nosso "],["italic",["text","macro reader"]],["text","."],["br"]],["code","clojure",["br"],["code-text","#X\""],["br"],["code-text","  <compras>"],["br"],["code-text","    <item>"],["br"],["code-text","      <batata>"],["br"],["code-text","        <preco>1.23</preco>"],["br"],["code-text","      </batata>"],["br"],["code-text","    </item>"],["br"],["code-text","  </compras>\""],["br"],["code-text","; {:tag :compras, :attrs nil, :content [{:tag :item, :attrs nil,"],["br"],["code-text","; :content [{:tag :batata, :attrs nil, :content [{:tag :preco,"],["br"],["code-text","; :attrs nil, :content [\"1.23\"]}]}]}]}"],["br"]],["paragraph",["br"]],["paragraph",["text","E eis que alteramos o "],["italic",["text","reader"]],["text"," do Clojure com um pouco de "],["italic",["text","reflection"]],["text"," e curiosidade."],["br"]],["section",["text","Onde aprender mais"]],["paragraph",["br"]],["paragraph",["text","Macros formam um assunto muito vasto e com muitos detalhes. Os fundamentos são simples, aprendemos poucos operadores e um pouco de prática vai ajudar bastante."],["br"]],["paragraph",["text","No capítulo "],["ref-label",["text","capitulo-mais"]],["text"," eu indico alguns livros para que você domine totalmente o assunto, caso seja de seu interesse."]]]