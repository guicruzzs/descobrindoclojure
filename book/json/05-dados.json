["document",["chapter",["text"," Dados e metadados"]],["paragraph",["br"]],["label",["text","capitulo-dados"]],["paragraph",["br"]],["quote",["text","\"Choose immutability and see where it takes you\""],["text","  -- Rich Hickey, criador do Clojure"]],["paragraph",["br"]],["section",["text","Imutabilidade é bacana, confie em mim"]],["paragraph",["br"]],["paragraph",["text","Uma das coisas mais difíceis de entender e aceitar em uma linguagem funcional, quando estamos tendo um primeiro contato, é o fato dos dados, na maioria das vezes, não poderem ser alterados depois de criados."],["br"]],["index",["text","imutabilidade"]],["paragraph",["br"]],["paragraph",["text","Essa característica de não podermos alterar o dado após sua criação é chamada de "],["italic",["text","imutabilidade"]],["text","."],["br"]],["paragraph",["text","Em uma linguagem como o Java, por exemplo, é comum criarmos uma variável temporária e alterarmos seu valor até chegarmos ao resultado que queremos."],["br"]],["paragraph",["text","Lá nos primórdios das linguagens de programação, memória e processamento eram recursos caríssimos, então cada "],["italic",["text","byte"]],["text"," fazia a diferença. O conceito de "],["italic",["text","garbage collector"]],["text"," até já existia"],["ref",["text","lisp-1"]],["text",", mas era inviável nas máquinas comerciais existentes."],["br"]],["paragraph",["text","Por conta disso, o reaproveitamento de variáveis era considerada uma boa prática, e a mutabilidade de dados numa linguagem era quase obrigatória."],["br"]],["code","java",["text"," label=\"Uma variável sendo reaproveitada\""],["br"],["code-text","int calculoQualquer(int valor) {"],["br"],["code-text","  int resultado = 0;"],["br"],["code-text","  resultado = dobro(resultado);"],["br"],["code-text","  resultado = triplo(resultado);"],["br"],["code-text","  resultado = raizQuadrada(resultado);"],["br"],["code-text","  return resultado;"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["paragraph",["text","De certo modo, modificar o valor de uma variável, desde que isso não insira bugs no código, não é uma prática ruim. O problema começa quando você tem que compartilhar esse valor entre diferentes processos ou "],["italic",["text","threads"]],["text","."],["br"]],["paragraph",["text","Partindo do pressuposto que o leitor teve infância, tente imaginar que você tenha um saquinho de bolas de gude (burca, fubeca, ou bila dependendo da época e do lugar da sua infância) e você, na solidão de um quintal ou do carpete da avó, queira contar quantas bolinhas existem ali."],["br"]],["paragraph",["text","Estando você sozinho, fica fácil de contar por mais que isso demore. Você pegas as bolinhas de um lugar, coloca em outro e incrementa um contador mental. Ao acabar as bolinhas, você tem a quantidade."],["br"]],["paragraph",["text","Agora imagine que você tenha um irmão que goste de atrapalhar. Irmãos são ótimos para isso. Enquanto você conta as bolinhas, ele muda a quantidade de bolinhas de um lado, do outro, ou mesmo começa a sumir com as bolinhas."],["br"]],["paragraph",["text","Mesmo que você consiga terminar, sua contagem não vai servir para nada."],["br"]],["paragraph",["text","Então você resolve organizar as coisas."],["br"]],["paragraph",["text","Você separa suas bolinhas em dois grupos. Uma para o irmão bagunceiro, outra para você. Ele conta o grupo de lá, você conta o grupo de cá e no final vocês somam os totais."],["br"]],["paragraph",["text","Bacana, assim funcionou."],["br"]],["paragraph",["text","Não acho que estavam pensando em bolinhas de gude, mas as pessoas que criam linguagens de programação resolveram colocar semáforos, como esses de trânsito, para que dois processos não alterem a mesma variável, como dois irmãos fazendo bagunça. No Java os semáforos são chamados de "],["italic",["text","locks"]],["text","."],["br"]],["paragraph",["text","A história dos semáforos funciona muito bem quando temos dois processos querendo mexer no mesmo valor, mas a coisa começa a ficar bem complicada quando passamos a ter vários processos querendo mexer no mesmo lugar."],["br"]],["paragraph",["text","Muitos algoritmos foram desenvolvidos, muitas ideias foram pensadas e muitas noites de sono foram perdidas até que alguém se perguntou se não seria uma boa se os valores simplesmente não mudassem."],["br"]],["paragraph",["text","E essa pessoa estava certa."],["br"]],["paragraph",["text","Se um valor não se altera até o fim de sua vida, qual a necessidade de criarmos gerenciamentos complicados com semáforos, travas e outras analogias? O número "],["italic",["text","1"]],["text"," sempre será "],["italic",["text","1"]],["text",", não importando quantas pessoas o estejam usando ao mesmo tempo."],["br"]],["paragraph",["text","Se você acha isso pouco prático e difícil de imaginar, pense na classe "],["monospaced",["text","String"]],["text"," do Java. Uma vez que você crie um valor do tipo "],["monospaced",["text","String"]],["text",", ele não pode mais ser modificado."],["br"]],["code","java",["br"],["code-text","String texto = \"Meu cavalo come abóbora\";"],["br"],["code-text","texto.toUpperCase();"],["br"],["code-text","// MEU CAVALO COME ABÓBORA"],["br"],["code-text","texto;"],["br"],["code-text","// Meu cavalo come abóbora"],["br"]],["paragraph",["br"]],["paragraph",["text","Os métodos de "],["monospaced",["text","String"]],["text"," retornam um novo valor, mantendo o texto original inalterado. Isso significa que um valor "],["monospaced",["text","String"]],["text"," é imutável e, por definição, um valor imutável pode ser compartilhado sem medo entre diferentes processos ou "],["italic",["text","threads"]],["text","."],["br"]],["paragraph",["text","Quando um valor pode ser compartilhado entre diferentes "],["italic",["text","threads"]],["text"," sem medo de fazermos lambança, dizemos que o valor é "],["italic",["text","thread-safe"]],["text","."],["br"]],["paragraph",["text","Como fazemos então para lidar com valores imutáveis se em algum momento vamos precisar que um valor seja modificado para outro?"],["br"]],["paragraph",["text","A primeira coisa que podemos fazer é não modificar valores, e sim transformá-los. Isso significa que vamos gerar um novo valor ao invés de transformar o atual, exatamente como faz a classe "],["monospaced",["text","String"]],["text","."],["br"]],["paragraph",["text","Por mais que isso possa parecer pouco produtivo em termos de processamento e memória, caso você tenha se perguntado se a cada transformação será criado um objeto completamente novo, o Clojure faz uso de "],["italic",["text","estruturas persistentes"]],["text"," para otimizar essas transformações, compartilhando partes da estrutura entre valores diferentes."],["br"]],["paragraph",["text","Afinal de contas, se esses valores não serão alterados, qual o problema em os usarmos em diferentes lugares ao mesmo tempo?"],["br"]],["paragraph",["text","A segunda coisa que podemos fazer é limitar as partes móveis da aplicação. Se você isolar as partes mutáveis do seu sistema em lugares que não serão acessados por diferentes threads ao mesmo tempo, ainda assim você consegue manter seu código "],["italic",["text","thread-safe"]],["text",". Vamos ver como isso funciona ao vermos "],["italic",["text","estruturas transientes"]],["text","."],["br"]],["paragraph",["text","Outro ponto importante de nos apoiarmos em valores imutáveis, mesmo fora do Clojure, é que você não pode confiar naquilo que muda sem que você perceba."],["br"]],["paragraph",["text","Quando você usa um "],["italic",["text","hashmap"]],["text",", por exemplo, você tem cada item formado por uma chave e um valor."],["br"]],["paragraph",["text","Essa chave é pesquisada através de um valor numérico chamado "],["italic",["text","hashcode"]],["text",", que é calculada de acordo com os atributos do objeto. Se os atributos mudam, o "],["italic",["text","hashcode"]],["text"," também muda."],["br"]],["paragraph",["text","Se o "],["italic",["text","hashcode"]],["text"," muda, a chave do "],["italic",["text","hashmap"]],["text"," já não é mais confiável, já que você não vai mais encontrar o objeto com o "],["italic",["text","hashcode"]],["text"," antigo. É como se você tivesse uma chave de casa para uma fechadura que pode mudar sem você saber. Não parece muito útil, certo?"],["br"]],["paragraph",["text","Por mais que pareça bobeira, é um erro muito comum quando você usa uma linguagem que oferece a mutabilidade como padrão, como é o caso do Java."],["br"]],["paragraph",["text","Vamos ver em detalhes estruturas persistentes e transientes neste capítulo, enquanto nos capítulos sobre integração com o Java e sobre concorrência vamos ver com calma como a imutabilidade faz toda a diferença."],["br"]],["section",["text","Tipos escalares"]],["paragraph",["br"]],["paragraph",["text","Um tipo escalar é todo aquele formado por um único valor. Nessa classificação se encaixam "],["italic",["text","strings"]],["text","; "],["italic",["text","números"]],["text","; valores lógicos, ou booleanos, representador por "],["monospaced",["text","true"]],["text"," e "],["monospaced",["text","false"]],["text","; e "],["monospaced",["text","nil"]],["text",", que representa a ausência de valor ou um valor nulo."],["br"]],["paragraph",["text","Existem outros dois tipos escalares específicos do Clojure, "],["italic",["text","symbol"]],["text"," e "],["italic",["text","keyword"]],["text","."],["br"]],["index",["text","symbol"]],["paragraph",["br"]],["title",["text","Symbol"]],["paragraph",["br"]],["paragraph",["text","Você deve se lembrar da forma "],["monospaced",["text","let"]],["text"," que usamos para criar um "],["italic",["text","binding"]],["text"," local:"],["br"]],["code","clojure",["br"],["code-text","(let [x 1]"],["br"],["code-text","  (println \"O valor de x é\" x))"],["br"],["code-text","; O valor de x é"],["br"]],["paragraph",["br"]],["paragraph",["text","No nosso código atribuimos o valor numérico "],["italic",["text","1"]],["text"," ao "],["monospaced",["text","x"]],["text","."],["br"]],["paragraph",["text","O "],["monospaced",["text","x"]],["text"," dessa expressão é um símbolo Clojure, que internamente vai apontar para o valor "],["italic",["text","1"]],["text",". Esse símbolo é representado em Clojure por um tipo chamado "],["monospaced",["text","symbol"]],["text","."],["br"]],["paragraph",["text","Por mais que pareça natural ter um símbolo que aponta para um valor em qualquer linguagem, na forma de "],["italic",["text","variável"]],["text"," ou "],["italic",["text","constante"]],["text",", não paramos para pensar no que o símbolo em si representa até encontrarmos um tipo específico para isso, como acontece com o Clojure."],["br"]],["paragraph",["text","O ato do compilador olhar para um símbolo e utilizar o valor para o qual ele aponta é chamado de "],["italic",["text","resolução"]],["text",". Então, no nosso código, quando você manda imprimir "],["monospaced",["text","x"]],["text",", a linguagem olha para o valor que está sendo apontado e retorna "],["italic",["text","1"]],["text","."],["br"]],["box",["text","Para quem vem de outras linguagens"],["paragraph",["br"]],["paragraph",["text","Para quem está acostumado com linguagens que tratam código e dados de forma diferente, como é o caso do Java, C, Ruby, Python, PHP e quase todas as linguagens usadas em grande escala no mercado, o conceito de símbolo pode ser um pouco confuso."],["br"]],["paragraph",["text","Vamos olhar o código a seguir para entender o que é um símbolo."],["br"]],["code","java",["br"],["code-text","x = 42;"],["br"]],["paragraph",["br"]],["paragraph",["text","Estamos atribuindo o valor "],["italic",["text","42"]],["text"," a "],["monospaced",["text","x"]],["text",". Nessa expressão, "],["monospaced",["text","x"]],["text"," e "],["monospaced",["text","="]],["text"," são símbolos, e "],["italic",["text","42"]],["text"," é um literal. Enquanto "],["monospaced",["text","x"]],["text"," é um símbolo que representa uma variável, "],["monospaced",["text","="]],["text"," é um símbolo que representa o operador de atribuição de valores. Já o literal representa um valor inteiro."],["br"]],["paragraph",["text","Como nas linguagens heteroicônicas você não manipula código como estrutura de dados, esse tipo de informação passa batido e, para a maioria das pessoas, é completamente irrelevante. Já em linguagens que tratam código como dados e vice-versa, como é o caso do Clojure, símbolos são tão importantes quanto qualquer outro tipo de dado da linguagem."],["br"]]],["paragraph",["br"]],["paragraph",["text","Ainda olhando para o código que escrevemos, podemos entender que "],["monospaced",["text","let"]],["text"," também é um símbolo, que internamente aponta para uma macro, e "],["monospaced",["text","println"]],["text"," é ainda outro símbolo que aponta para uma função que imprime na tela."],["br"]],["paragraph",["text","Então você se pergunta onde é que isso vai ser usado. O tempo todo, eu respondo. Mas você dificilmente vai precisar saber se um valor é um símbolo ou não."],["br"]],["paragraph",["text","De qualquer maneira, é bom conhecer o que é e o que faz um símbolo."],["br"]],["index",["text","symbol?"]],["paragraph",["br"]],["paragraph",["text","Existem duas funções para lidar com símbolos: "],["monospaced",["text","symbol"]],["text"," e "],["monospaced",["text","symbol?"]],["text",". A primeira cria um símbolo sem atribuir qualquer valor:"],["br"]],["code","clojure",["br"],["code-text","(symbol x)"],["br"],["code-text","; x"],["br"]],["paragraph",["br"]],["paragraph",["text","Já "],["monospaced",["text","symbol?"]],["text"," retorna "],["monospaced",["text","true"]],["text"," caso o parâmetro seja um símbolo. Porém, existe uma pegadinha aí."],["br"]],["paragraph",["text","Se passarmos o símbolo como parâmetro, a função vai receber o valor que foi "],["italic",["text","amarrado"]],["text"," a ele (daí o nome "],["italic",["text","binding"]],["text","), e não o símbolo propriamente dito:"],["br"]],["code","clojure",["br"],["code-text","(symbol? x)"],["br"],["code-text","; Unable to resolve symbol: x in this context,"],["br"],["code-text","(let [x 42]"],["br"],["code-text","  (println (symbol? x))"],["br"],["code-text","  ; false"],["br"],["code-text","  (println (number? x)))"],["br"],["code-text","  ; true"],["br"]],["paragraph",["br"]],["index",["text","'"]],["index",["text","quote"]],["paragraph",["br"]],["paragraph",["text","Entra em cena o operador "],["monospaced",["text","quote"]],["text",", ou simplesmente "],["monospaced",["text","'"]],["text",", que diz ao compilador que aquele símbolo ou expressão não deve ser resolvido ou avaliado."],["br"]],["code","clojure",["br"],["code-text","(symbol? 'x)"],["br"],["code-text","; true"],["br"],["code-text","(symbol? (quote x))"],["br"],["code-text","; true"],["br"]],["paragraph",["br"]],["index",["text","Keyword"]],["index",["text",":"]],["paragraph",["br"]],["title",["text","Keyword"]],["paragraph",["br"]],["paragraph",["text","Já o tipo "],["italic",["text","keyword"]],["text"," pode ser considerado um irmão mais famoso do "],["italic",["text","symbol"]],["text",", que aponta para si mesmo ao invés de apontar para outro valor. Se "],["italic",["text","symbol"]],["text"," é o irmão dedo-duro, podemos dizer que "],["italic",["text","keyword"]],["text"," é o irmão egoísta."],["br"]],["paragraph",["italic",["text","Keywords"]],["text"," normalmente são utilizadas como chaves em um mapa, mas podem também ser utilizadas no lugar de um texto repetitivo que possa indicar uma configuração ou opção de uma função ou biblioteca, como uma constante ou uma enumeração."],["br"]],["code","clojure",["br"],["code-text",":eu-me-basto"],["br"],["code-text","; :eu-me-basto"],["br"],["code-text","(let [pessoa {:nome \"José\" :idade 40}]"],["br"],["code-text","  (println (pessoa :nome)))"],["br"],["code-text","; José"],["br"]],["paragraph",["br"]],["index",["text","keyword"]],["index",["text","keyword?"]],["paragraph",["br"]],["paragraph",["text","Assim como acontece com "],["italic",["text","symbol"]],["text",", existem as funções "],["monospaced",["text","keyword"]],["text"," e "],["monospaced",["text","keyword?"]],["text"," para, respectivamente, criar um "],["italic",["text","keyword"]],["text"," ou verificar se o parâmetro é um "],["italic",["text","keyword"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(keyword \"texto\")"],["br"],["code-text","; :texto"],["br"],["code-text","(keyword? :qualquer)"],["br"],["code-text","; true"],["br"]],["paragraph",["br"]],["paragraph",["text","Finalmente, como um "],["italic",["text","keyword"]],["text"," tem a si mesmo como valor, não é necessário declará-lo antes de usar."],["br"]],["paragraph",["text","Internamente, a classe Java responsável pela representação de um "],["italic",["text","keyword"]],["text"," implementa também a classe Java "],["monospaced",["text","AFn"]],["text"," que é a base de todas as funções do Clojure."],["br"]],["paragraph",["text","Isso significa que podemos usar um "],["italic",["text","keyword"]],["text"," como um operador, o que acaba sendo uma boa prática."],["br"]],["paragraph",["text","Imagine que temos um mapa simples, contendo o código do Estado e seu respectivo nome:"],["br"]],["code","clojure",["br"],["code-text","(def estados {:es \"Espírito Santo\""],["br"],["code-text","              :mg \"Minas Gerais\""],["br"],["code-text","              :rj \"Rio de Janeiro\""],["br"],["code-text","              :sp \"São Paulo\"})"],["br"],["code-text","(estados :sp)"],["br"],["code-text","; \"São Paulo\""],["br"],["code-text","(:sp estados)"],["br"],["code-text","; \"São Paulo\""],["br"]],["paragraph",["br"]],["paragraph",["text","Ambas as formas retornam o mesmo resultado. Mais para frente vamos ver essa característica em detalhes, e quais as suas vantagens."],["br"]],["index",["text","Namespace qualified keyword"]],["paragraph",["br"]],["title",["text","Namespace qualified keyword"]],["paragraph",["br"]],["paragraph",["text","Existe um tipo especial de "],["italic",["text","keyword"]],["text"," que traz automaticamente o "],["italic",["text","namespace"]],["text"," no qual ele foi criado junto do próprio nome. Por conta disso ele é chamado de "],["italic",["text","namespace qualified keyword"]],["text",", ou "],["italic",["text","keyword que traz o nome do namespace no qual foi criado"]],["text",". Vou chamá-los apenas de "],["italic",["text","keywords qualificados"]],["text"," para não gastar o dedo digitando."],["br"]],["paragraph",["text","Esse "],["italic",["text","keyword"]],["text"," de nome diferente funciona assim: ao invés de utilizarmos um sinal de dois-pontos antes do nome, usamos dois. O "],["italic",["text","reader"]],["text"," do Clojure substitui o segundo sinal de dois-pontos pelo "],["italic",["text","namespace"]],["text"," atual."],["br"]],["paragraph",["text","Vamos partir do pressuposto de que você acabou de entrar no "],["italic",["text","REPL"]],["text"," e estamos no "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","user"]],["text","."],["br"]],["code","clojure",["br"],["code-text",":normal"],["br"],["code-text","; :normal"],["br"],["ns-sym","℔",["code-text","nome-completo"]],["br"],["code-text","; :user/nome-completo"],["br"]],["paragraph",["br"]],["paragraph",["text","O "],["italic",["text","keyword"]],["text"," "],["monospaced",["text","normal"]],["text"," não pertence a nenhum "],["italic",["text","namespace"]],["text",". Como já foi dito aqui, ele é um egoísta que só olha para si mesmo. Uma das vantagens disso é que você pode utilizar um "],["italic",["text","keyword"]],["text"," em qualquer lugar do sistema sem nem se preocupar onde foi o primeiro lugar em que ele foi criado."],["br"]],["paragraph",["text","Já o "],["italic",["text","keyword"]],["text"," "],["monospaced",["text","nome-completo"]],["text"," pertence ao "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","user"]],["text",", não interessando o que aconteça com ele daqui para frente. Isso permite, por exemplo, que você tenha mais de um "],["italic",["text","keyword"]],["text"," com o mesmo nome, desde que cada um pertença a um "],["italic",["text","namespace"]],["text"," diferente."],["br"]],["paragraph",["text","Apesar do uso de "],["italic",["text","keywords"]],["text"," qualificados ser bem menos comum que o seu irmão sem sobrenome, existem situações em que seu uso é bem vindo."],["br"]],["paragraph",["text","Imagine que você tenha um "],["italic",["text","hashmap"]],["text"," (ou dicionário, ou mapa - veremos em detalhes a seguir), que pode ser manipulado por funções em diferentes "],["italic",["text","namespaces"]],["text","."],["br"]],["paragraph",["text","Seria uma forma de evitar conflitos caso você tenha dois "],["italic",["text","keywords"]],["text"," com o mesmo nome."],["br"]],["index",["text","atom"]],["paragraph",["br"]],["paragraph",["text","Vamos criar um "],["italic",["text","atom"]],["text"," que será compartilhado por mais de um "],["italic",["text","namespace"]],["text","."],["br"]],["box",["text","Atom"],["paragraph",["br"]],["paragraph",["text","Um "],["italic",["text","atom"]],["text"," é uma estrutura de dados utilizada em processamento concorrente. Ela garante que alterações ou leituras em diferentes "],["italic",["text","threads"]],["text"," não corrompam os dados. Veremos essa estrutura com detalhes no capítulo "],["ref-label",["text","capitulo-concorrencia"]],["text","."],["br"]]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(ns capitulo05)"],["br"],["code-text","(def compartilhado (atom {}))"],["br"]],["paragraph",["br"]],["index",["text","swap!"]],["paragraph",["br"]],["paragraph",["text","Agora vamos atribuir um valor ao "],["italic",["text","atom"]],["text"," utilizando a função "],["monospaced",["text","swap!"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(swap! compartilhado assoc "],["ns-sym","℔",["code-text","funcoes 4)"]],["br"],["code-text","@compartilhado"],["br"],["code-text","; {:capitulo05/funcoes 4}"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos criar outro "],["italic",["text","namespace"]],["text"," e repetir a alteração."],["br"]],["code","clojure",["br"],["code-text","(ns outro-namespace)"],["br"],["code-text","(swap! capitulo05/compartilhado assoc "],["ns-sym","℔",["code-text","funcoes 10)"]],["br"],["code-text","@capitulo05/compartilhado"],["br"],["code-text","; {:outro-namespace/funcoes 10, :capitulo05/funcoes 4}"],["br"]],["paragraph",["br"]],["paragraph",["text","Podemos utilizar "],["italic",["text","keywords"]],["text"," qualificados também para definir hierarquias de tipos de dados. Em linguagens orientadas a objeto nós temos hierarquia de dados na forma de herança. Aquela história de "],["italic",["text","todo cachorro é um animal, todo gato é um animal, mas um cachorro não é um gato"]],["text",", só que sem herdar os comportamentos típicos de um objeto."],["br"]],["paragraph",["text","Vamos usar o exemplo dos gatos e cachorros para exemplificar. É um tanto bobo e desconectado do mundo real, mas tem um grande valor didático."],["br"]],["index",["text","derive"]],["paragraph",["br"]],["paragraph",["text","Vamos usar a função "],["monospaced",["text","derive"]],["text"," para dizer que um tipo é derivado de outro, ou que um tipo é subtipo de outro."],["br"]],["paragraph",["text","Vamos começar com o cachorro."],["br"]],["code","clojure",["br"],["code-text","(derive "],["ns-sym","℔",["code-text","cachorro "]],["ns-sym","℔",["code-text","animal)"]],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos para o gato."],["br"]],["code","clojure",["br"],["code-text","(derive "],["ns-sym","℔",["code-text","gato "]],["ns-sym","℔",["code-text","animal)"]],["br"]],["paragraph",["br"]],["index",["text","isa?"]],["paragraph",["br"]],["paragraph",["text","Então vamos verificar se um cachorro ou um gato são animais, e então termos certeza de que gatos não são cachorros. Para isso usamos a função "],["monospaced",["text","isa?"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(isa? "],["ns-sym","℔",["code-text","cachorro "]],["ns-sym","℔",["code-text","animal)"]],["br"],["code-text","; true"],["br"],["code-text","(isa? "],["ns-sym","℔",["code-text","gato "]],["ns-sym","℔",["code-text","animal)"]],["br"],["code-text","; true"],["br"],["code-text","(isa? "],["ns-sym","℔",["code-text","cachorro "]],["ns-sym","℔",["code-text","gato)"]],["br"],["code-text","; false"],["br"]],["paragraph",["br"]],["paragraph",["text","Parece um tanto lógico também que todo cachorro é um animal, mas nem todo animal é um cachorro."],["br"]],["code","clojure",["br"],["code-text","(isa? "],["ns-sym","℔",["code-text","cachorro "]],["ns-sym","℔",["code-text","animal)"]],["br"],["code-text","; true"],["br"],["code-text","(isa? "],["ns-sym","℔",["code-text","animal "]],["ns-sym","℔",["code-text","cachorro)"]],["br"],["code-text","; false"],["br"]],["paragraph",["br"]],["paragraph",["text","Podemos dizer também que um poodle é um cachorro, e ainda assim continua sendo um animal."],["br"]],["code","clojure",["br"],["code-text","(derive "],["ns-sym","℔",["code-text","poodle "]],["ns-sym","℔",["code-text","cachorro)"]],["br"],["code-text","(isa? "],["ns-sym","℔",["code-text","poodle "]],["ns-sym","℔",["code-text","cachorro)"]],["br"],["code-text","; true"],["br"],["code-text","(isa? "],["ns-sym","℔",["code-text","poodle "]],["ns-sym","℔",["code-text","animal)"]],["br"],["code-text","; true"],["br"]],["paragraph",["br"]],["paragraph",["text","Lembrando de "],["italic",["text","multimethods"]],["text",", vamos integrar com o que acabamos de aprender sobre hierarquia."],["br"]],["paragraph",["text","Vamos definir alguns mamíferos."],["br"]],["code","clojure",["br"],["code-text","(derive "],["ns-sym","℔",["code-text","cachorro "]],["ns-sym","℔",["code-text","mamifero)"]],["br"],["code-text","(derive "],["ns-sym","℔",["code-text","gato "]],["ns-sym","℔",["code-text","mamifero)"]],["br"],["code-text","(derive "],["ns-sym","℔",["code-text","morcego "]],["ns-sym","℔",["code-text","mamifero)"]],["br"],["code-text","(derive "],["ns-sym","℔",["code-text","baleia "]],["ns-sym","℔",["code-text","mamifero)"]],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos definir alguns animais que voam e outros que nadam."],["br"]],["code","clojure",["br"],["code-text","(derive "],["ns-sym","℔",["code-text","morcego "]],["ns-sym","℔",["code-text","voador)"]],["br"],["code-text","(derive "],["ns-sym","℔",["code-text","gaivota "]],["ns-sym","℔",["code-text","voador)"]],["br"],["code-text","(derive "],["ns-sym","℔",["code-text","baleia "]],["ns-sym","℔",["code-text","nadador)"]],["br"],["code-text","(derive "],["ns-sym","℔",["code-text","salmao "]],["ns-sym","℔",["code-text","nadador)"]],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos criar "],["italic",["text","multimethods"]],["text"," que mostrem mensagens de acordo com tipo do animal. Vamos usar a função "],["monospaced",["text","identity"]],["text",", que retorna o próprio parâmetro. Por exemplo, "],["monospaced",["text","(identity \"texto\")"]],["text"," retorna "],["monospaced",["text","\"texto\""]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defmulti animal identity)"],["br"],["code-text","(defmethod animal "],["ns-sym","℔",["code-text","mamifero [valor]"]],["br"],["code-text","  (println \"Um\" valor \"mama\"))"],["br"],["code-text","(defmethod animal "],["ns-sym","℔",["code-text","voador [valor]"]],["br"],["code-text","  (println \"Um\" valor \"voa\"))"],["br"],["code-text","(defmethod animal "],["ns-sym","℔",["code-text","nadador [valor]"]],["br"],["code-text","  (println \"Um\" valor \"nada\"))"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora começa a diversão. Primeiro vamos testar um cachorro. Para a tranquilidade das entidades protetores de animais, nenhum cachorro será ferido, incomodado ou molestado na execução desses testes."],["br"]],["code","clojure",["br"],["code-text","(animal "],["ns-sym","℔",["code-text","cachorro)"]],["br"],["code-text","; Um :user/cachorro mama"],["br"]],["paragraph",["br"]],["paragraph",["text","Legal. Vamos um gato e, em seguida, um morcego."],["br"]],["code","clojure",["br"],["code-text","(animal "],["ns-sym","℔",["code-text","gato)"]],["br"],["code-text","; Um :user/gato mama"],["br"],["code-text","(animal "],["ns-sym","℔",["code-text","morcego)"]],["br"],["code-text","; IllegalArgumentException Multiple methods in multimethod"],["br"],["code-text","; 'animal' match dispatch value: :user/morcego -> :user/mamifero"],["br"],["code-text","; and :user/voador, and neither is preferred"],["br"],["code-text","; clojure.lang.MultiFn.findAndCacheBestMethod (MultiFn.java:182)"],["br"]],["paragraph",["br"]],["paragraph",["text","O Clojure ficou confuso, já que um morcego é mamífero e ao mesmo tempo voador. Tudo bem, é complicado explicar para uma criança que nem todo animal que voa é ave."],["br"]],["index",["text","prefer-method"]],["paragraph",["br"]],["paragraph",["text","Vamos utilizar a função "],["monospaced",["text","prefer-method"]],["text"," para dizer qual valor tem prioridade na hierarquia."],["br"]],["code","clojure",["br"],["code-text","(prefer-method animal "],["ns-sym","℔",["code-text","mamifero "]],["ns-sym","℔",["code-text","voador)"]],["br"],["code-text","(animal "],["ns-sym","℔",["code-text","morcego)"]],["br"],["code-text","; Um :user/morcego mama"],["br"],["code-text","(animal "],["ns-sym","℔",["code-text","gaivota)"]],["br"],["code-text","; Um :user/gaivota voa"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos dar um desconto ao nosso código por ele não saber que o correto é "],["italic",["text","uma gaivota"]],["text"," ao invés de "],["italic",["text","um gaivota"]],["text","."],["br"]],["paragraph",["text","Fazendo o mesmo com os mamíferos que nadam, podemos testar a baleia e o salmão. Novamente nenhum ser aquático será incomodado na execução do código a seguir."],["br"]],["code","clojure",["br"],["code-text","(prefer-method animal "],["ns-sym","℔",["code-text","mamifero "]],["ns-sym","℔",["code-text","nadador)"]],["br"],["code-text","(animal "],["ns-sym","℔",["code-text","baleia)"]],["br"],["code-text","; Um :user/baleia mama"],["br"],["code-text","(animal "],["ns-sym","℔",["code-text","salmao)"]],["br"],["code-text","; Um :user/salmao nada"],["br"]],["paragraph",["br"]],["paragraph",["text","No capítulo "],["ref-label",["text","capitulo-integracao-java"]],["text"," vamos descobrir outra aplicação para "],["italic",["text","keywords"]],["text"," qualificados ao trabalharmos com protocolos."],["br"]],["section",["text","Strings, caracteres e expressões regulares"]],["paragraph",["br"]],["index",["text","class"]],["paragraph",["br"]],["paragraph",["text","Um valor do tipo "],["italic",["text","string"]],["text"," é um texto, sem nenhuma diferença especial em relação à sua linguagem preferida. Internamente é usada a classe "],["monospaced",["text","java.lang.String"]],["text",", que é exatamente a mesma que você usa no Java padrão. Isso significa que todos os métodos que você já utiliza com "],["italic",["text","strings"]],["text"," no Java estão disponíveis no Clojure. Vamos usar a função "],["monospaced",["text","class"]],["text"," para poder ver isso na prática:"],["br"]],["code","clojure",["br"],["code-text","(class \"Clojure\")"],["br"],["code-text","; java.lang.String"],["br"],["code-text","(.toUpperCase \"Clojure\")"],["br"],["code-text","; \"CLOJURE\""],["br"]],["paragraph",["br"]],["paragraph",["text","A biblioteca padrão vem também com um namespace chamado "],["monospaced",["text","clojure.string"]],["text"," que traz mais algumas funções para complementar os métodos da classe "],["monospaced",["text","String"]],["text"," do Java."],["br"]],["img",["text","images/capitulo_05/clojure_string.png \"Funções disponíveis em clojure.string\" label=cap05-clojure-string w=80%"]],["paragraph",["br"]],["paragraph",["text","Apesar de uma "],["italic",["text","string"]],["text"," ser um tipo escalar, e não uma coleção (que veremos em detalhes mais adiante), o Clojure dá um jeito para que seja tratado como se fosse. Isso acontece porque, sempre que uma função que lida com sequencias recebe uma "],["italic",["text","string"]],["text",", é retornada uma sequencia de verdade, ou parte dela, como resultado:"],["br"]],["code","clojure",["br"],["code-text","(class \"nome\")"],["br"],["code-text","; java.lang.String"],["br"],["code-text","(rest \"nome\")"],["br"],["code-text","; (\\o \\m \\e)"],["br"],["code-text","(class (rest \"nome\"))"],["br"],["code-text","; clojure.lang.StringSeq"],["br"]],["paragraph",["br"]],["title",["text","Caracteres"]],["paragraph",["br"]],["paragraph",["text","Quando o Clojure trata uma "],["italic",["text","string"]],["text"," como sequencia, cada item é representado por um caracter. Da mesma forma, qualquer método válido para tratar caracteres em Java pode ser usado para manipular caracteres em Clojure, uma vez que o tipo é o mesmo em ambas as linguagens."],["br"]],["paragraph",["text","A principal diferença aqui é visual. Enquanto em Java os caracteres são representados entre apóstrofos, em Clojure utilizamos uma barra invertida antes do caracter:"],["br"]],["code","clojure",["br"],["code-text","(first \"Um texto\")"],["br"],["code-text","\\U"],["br"],["code-text","(class (first \"Um texto\"))"],["br"],["code-text","; java.lang.Character"],["br"]],["paragraph",["br"]],["box",["text","Aspas, apóstrofos e ápices"],["paragraph",["br"]],["paragraph",["text","Devido a uma limitação das máquinas de escrever, que foi herdada pelos teclados dos computadores, nos acostumamos a usar "],["italic",["text","ápices"]],["text"," ("],["monospaced",["text","'"]],["text",") ao invés de "],["italic",["text","apóstrofos"]],["text",". Um apóstrofo é mais arredondado: ’"],["ref",["text","wiki-apostrofo"]],["text","."],["br"]],["paragraph",["text","Já "],["italic",["text","apóstrofe"]],["text",", com e no final, é uma figura de linguagem que nada tem a ver com Clojure, ó caro leitor. Nada que vá mudar o rumo do livro, mas é bacana saber."],["br"]]],["paragraph",["br"]],["paragraph",["text","E para montar uma "],["italic",["text","string"]],["text"," a partir de vários caracteres, podemos usar a conhecida função "],["monospaced",["text","str"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(str \\O \\i)"],["br"],["code-text","; \"Oi\""],["br"]],["paragraph",["br"]],["title",["text","Expressões regulares"]],["paragraph",["br"]],["paragraph",["text","Expressões regulares são sequencias de caracteres que formam um padrão de busca. A ideia foi criada na década de 1950, por um matemático chamado Stephen Cole"],["ref",["text","nerve-nets"]],["text",", mas as expressões passaram a ter um uso mais prático na década de 1960, quando Ken Thompson, desenvolveu um editor chamado "],["italic",["text","qed"]],["ref",["text","qed-editor"]],["text",", que fazia uso de expressões regulares para pesquisar textos dentro de um arquivo."],["br"]],["paragraph",["text","A título de curiosidade, Ken Thompson também foi o responsável ela linguagem "],["italic",["text","B"]],["text",", que deu origem à linguagem "],["italic",["text","C"]],["ref",["text","c-history"]],["text"," e também é um dos criadores da linguagem Go"],["ref",["text","golang"]],["text","."],["br"]],["index",["text","re-pattern"]],["paragraph",["br"]],["paragraph",["text","Uma expressão regular em Clojure é escrita como uma "],["italic",["text","string"]],["text",", mas com um caracter "],["monospaced",["text","#"]],["text"," na frente. Você também pode criar uma expressão regular a partir de uma "],["italic",["text","string"]],["text"," usando a função "],["monospaced",["text","re-pattern"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","#\"abc\""],["br"],["code-text","; #\"abc\""],["br"],["code-text","(re-pattern \"abc\")"],["br"],["code-text","#\"abc\""],["br"]],["paragraph",["br"]],["index",["text","re-find"]],["paragraph",["br"]],["paragraph",["text","Para encontrarmos um valor dentro de outro, usamos a função "],["monospaced",["text","re-find"]],["text",", passando como parâmetros a expressão regular e o texto que pode conter o que precisamos:"],["br"]],["code","clojure",["br"],["code-text","(def frase \"O rato roeu a roupa do rei de Roma\")"],["br"],["code-text","(re-find #\"ro\" frase)"],["br"],["code-text","; \"ro\""],["br"],["code-text","(re-find #\"gato\" frase)"],["br"],["code-text","; nil"],["br"]],["paragraph",["br"]],["paragraph",["text","Caso a expressão, ou "],["italic",["text","pattern"]],["text",", não seja encontrada na frase, a função "],["monospaced",["text","re-find"]],["text"," retorna "],["monospaced",["text","nil"]],["text",". No nosso exemplo, não havia nenhum gato próximo à roupa do rei de Roma e deu no que deu."],["br"]],["index",["text","re-seq"]],["paragraph",["br"]],["paragraph",["text","Já a função "],["monospaced",["text","re-seq"]],["text"," nos retorna uma sequencia contendo todas as ocorrências daquele "],["italic",["text","pattern"]],["text",". Vamos criar uma sequencia contendo todas as palavras da frase que comecem com a letra "],["italic",["text","r"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(re-seq #\"r\\w*\" frase)"],["br"],["code-text","; (\"rato\" \"roeu\" \"roupa\" \"rei\")"],["br"]],["paragraph",["br"]],["paragraph",["text","E cadê a palavra "],["italic",["text","Roma"]],["text","?"],["br"]],["paragraph",["text","Por padrão, uma expressão regular diferencia maiúsculas de minúsculas. Para alterar esse comportamento precisamos adicionar a opção "],["monospaced",["text","(?i)"]],["text"," antes do "],["italic",["text","pattern"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(re-seq #\"(?i)r\\w*\" frase)"],["br"],["code-text","; (\"rato\" \"roeu\" \"roupa\" \"rei\" \"Roma\")"],["br"]],["paragraph",["br"]],["paragraph",["text","Existem várias outras opções além do "],["monospaced",["text","?i"]],["br"]],["paragraph",["text","Existem guias de expressões regulares para todos os gostos na Internet, além de sites para que você possa testar suas expressões contra textos de diversos tamanhos. Os meus preferidos, e os que recomendo, são o "],["italic",["text","Rubular"]],["text"," (http://www.rubular.com) e o "],["italic",["text","Regexr"]],["text"," (http://www.regexr.com/)."],["br"]],["index",["text","replace"]],["index",["text","clojure.string/replace"]],["paragraph",["br"]],["paragraph",["text","A função "],["monospaced",["text","replace"]],["text"," que está no namespace "],["monospaced",["text","clojure.string"]],["text"," também utiliza expressões regulares para substituir ocorrências dentro de textos."],["br"]],["paragraph",["text","Vamos usar "],["monospaced",["text","replace"]],["text"," para "],["italic",["text","cebolinhar"]],["text"," a frase:"],["br"]],["code","clojure",["br"],["code-text","(clojure.string/replace frase #\"(?i)r\" \"l\")"],["br"],["code-text","; \"O lato loeu a loupa do lei de loma\""],["br"]],["paragraph",["br"]],["paragraph",["text","Agora que sabemos tudo sobre "],["italic",["text","strings"]],["text"," no Clojure, vamos aos números."],["br"]],["section",["text","Tipos numéricos"]],["paragraph",["br"]],["index",["text","Long"]],["paragraph",["br"]],["paragraph",["text","Não há muitos segredos quando se trata de números em Clojure. Números inteiros são, por padrão, representados com a classe "],["monospaced",["text","Long"]],["text"," do Java, que permite valores entre "],["monospaced",["text","(2 ^ 63) - 1"]],["text"," e "],["monospaced",["text","(-2 ^ 63)"]],["text",", o que dá e sobra para a maioria dos cálculos que quisermos fazer."],["br"]],["index",["text","Long/MIN_VALUE"]],["paragraph",["br"]],["index",["text","Long/MAX_VALUE"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(Long/MIN_VALUE)"],["br"],["code-text","; -9223372036854775808"],["br"],["code-text","(Long/MAX_VALUE)"],["br"],["code-text","; 9223372036854775807"],["br"]],["paragraph",["br"]],["paragraph",["text","As constantes "],["monospaced",["text","MIN_VALUE"]],["text"," e "],["monospaced",["text","MAX_VALUE"]],["text"," contém, respectivamente, o menor e o maior valor possível que pode ser armazenado como "],["monospaced",["text","Long"]],["text",". É bem mais fácil lembrar o nome da constante do que memorizar esses valores gigantescos."],["br"]],["box",["text","Um inteiro não deveria ser Integer?"],["paragraph",["br"]],["paragraph",["text","Antes da versão 1.3.0, o padrão para números inteiros era a classe Java "],["monospaced",["text","Integer"]],["text",", que poderia ser promovida para "],["monospaced",["text","Long"]],["text"," e então para "],["monospaced",["text","BigInt"]],["text","."],["br"]],["paragraph",["text","Da versão 1.3.0 para cá a linguagem não usa mais a classe "],["monospaced",["text","Integer"]],["text"," internamente."],["br"]],["paragraph",["text","Também daquela versão para cá os valores só serão promovidos se você utilizar os operadores aritméticos terminados em "],["monospaced",["text","'"]],["text",", e não mais automaticamente."],["br"]]],["paragraph",["br"]],["index",["text","BigInt"]],["paragraph",["br"]],["index",["text","+'"]],["paragraph",["br"]],["index",["text","-'"]],["paragraph",["br"]],["index",["text","inc'"]],["paragraph",["br"]],["paragraph",["text","Caso isso ainda não seja suficiente, o próprio Clojure "],["italic",["text","promove"]],["text"," o valor para "],["monospaced",["text","BigInt"]],["text"," caso você utilize os operadores terminados em "],["monospaced",["text","'"]],["text",", como "],["monospaced",["text","+'"]],["text",", "],["monospaced",["text","-'"]],["text",", "],["monospaced",["text","inc'"]],["text"," e assim por diante."],["br"]],["paragraph",["text","Para lidar com números decimais, é utilizada a classe "],["monospaced",["text","Double"]],["text"," do Java. Da mesma forma que acontece com os números inteiros, o Clojure pode promover o valor para "],["monospaced",["text","BigDecimal"]],["text"," caso seja necessário."],["br"]],["code","clojure",["br"],["code-text","(Double/MIN_VALUE)"],["br"],["code-text","; 4.9E-324"],["br"],["code-text","(Double/MAX_VALUE)"],["br"],["code-text","; 1.7976931348623157E308"],["br"]],["paragraph",["br"]],["index",["text","N"]],["index",["text","M"]],["paragraph",["br"]],["paragraph",["text","Você pode trabalhar diretamente com "],["monospaced",["text","BigInt"]],["text"," e "],["monospaced",["text","BigDecimal"]],["text",", adicionando a letra "],["monospaced",["text","N"]],["text"," ao final do número inteiro ou a letra "],["monospaced",["text","M"]],["text"," ao final do número decimal."],["br"]],["code","clojure",["br"],["code-text","(type 1)"],["br"],["code-text","; java.lang.Long"],["br"],["code-text","(type 1N)"],["br"],["code-text","; clojure.lang.BigInt"],["br"],["code-text","(type 1.0)"],["br"],["code-text","; java.lang.Double"],["br"],["code-text","(type 1.0M)"],["br"],["code-text","; java.math.BigDecimal"],["br"]],["paragraph",["br"]],["paragraph",["text","Existem também as funções "],["monospaced",["text","bigint"]],["text"," e "],["monospaced",["text","bigdec"]],["text",", caso você precise converter o valor em tempo de execução."],["br"]],["code","clojure",["br"],["code-text","(bigdec (+ 1 1))"],["br"],["code-text","; 2M"],["br"],["code-text","(bigint (+ 1 1))"],["br"],["code-text","; 2N"],["br"]],["paragraph",["br"]],["section",["text","Overflow e autopromoção"]],["paragraph",["br"]],["paragraph",["text","Resumidamente, "],["italic",["text","overflow"]],["text"," é quando tentamos atribuir um valor muito grande a um tipo de dado que não comporta aquela quantidade de informação."],["br"]],["paragraph",["text","Imagine que você tem um copo de 300ml e queira colocar um litro d'água dentro dele. Obviamente o litro d'água não vai caber no copo, então podem acontecer duas coisas: ou você desiste assim que perceber que a água não vai caber no copo; ou continua assim mesmo, despejando o litro, perdendo tudo o que foi derramado para fora do copo. Aliás, a tradução literal de "],["italic",["text","overflow"]],["text"," para o português é justamente "],["italic",["text","transbordar"]],["text","."],["br"]],["paragraph",["text","O Clojure permite que você escolha qualquer uma dessas duas abordagens e ainda traz uma terceira que não seria possível apenas usando o copo."],["br"]],["paragraph",["text","Na primeira forma, que seria aquela em que desistimos no meio do caminho, vamos causar um erro, parando o processo para que nada de pior aconteça."],["br"]],["paragraph",["text","Vamos utilizar a constante "],["monospaced",["text","MAX_VALUE"]],["text"," que vimos acima, para já começarmos o exemplo no limite da capacidade de um tipo "],["monospaced",["text","Long"]],["text","."],["br"]],["paragraph",["text","Sobre esse valor, vamos somar "],["italic",["text","1"]],["text",", que é suficiente para fazermos o copo transbordar, como podemos ver na figura "],["ref-label",["text","repl-overflow-error"]],["text","."],["br"]],["code","clojure",["br"],["code-text","Long/MAX_VALUE"],["br"],["code-text","(+ 1 Long/MAX_VALUE)"],["br"]],["paragraph",["br"]],["img",["text","images/capitulo_05/repl_overflow_error.png w=90% \"Não era o valor que esperávamos\" label=repl-overflow-error"]],["paragraph",["br"]],["paragraph",["text","Podemos permitir também que o copo transborde usando explicitamente as operações iniciadas por "],["monospaced",["text","unchecked-"]],["text",". Com isso deixamos claro que não estamos checando se houve "],["italic",["text","overflow"]],["text",", ganhando um pouco de tempo, mas perdendo completamente a segurança das checagens."],["br"]],["index",["text","unchecked-add"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","Long/MAX_VALUE"],["br"],["code-text","(unchecked-add 1 Long/MAX_VALUE)"],["br"]],["paragraph",["br"]],["paragraph",["text","Aqui não ocorre o erro, mas ao somarmos "],["italic",["text","1"]],["text"," ao valor de "],["monospaced",["text","MAX_VALUE"]],["text",", que é "],["monospaced",["text","9.223.372.036.854.775.807"]],["text",", teremos um número negativo. Aqui dizemos que ocorreu o "],["italic",["text","overflow"]],["text",", como podemos ver na figura "],["ref-label",["text","repl-overflow-done"]],["text","."],["br"]],["img",["text","images/capitulo_05/repl_overflow_done.png w=90% \"Não coube, deu erro\" label=repl-overflow-done"]],["paragraph",["br"]],["paragraph",["text","Apenas para que você entenda o que aconteceu, considere que um valor do tipo "],["monospaced",["text","Long"]],["text"," ocupa 64 bits de memória. Como esse número pode ser positivo ou negativo, o bit mais significativo, que é aquele mais a esquerda, é usado para indicar o sinal do número: "],["italic",["text","1"]],["text"," se for negativo, "],["italic",["text","0"]],["text"," se for positivo."],["br"]],["paragraph",["text","Com isso, o maior número positivo possível é "],["monospaced",["text","(2 ^ 63) - 1"]],["text",", enquanto o maior número negativo é "],["monospaced",["text","-(2 ^ 63)"]],["text",". O "],["monospaced",["text","- 1"]],["text"," do número positivo se deve ao fato do zero ser considerado positivo."],["br"]],["paragraph",["text","O número "],["monospaced",["text","9.223.372.036.854.775.807"]],["text"," em binário é uma sequencia de 63 bits "],["italic",["text","1"]],["text",". Ao somar o número "],["italic",["text","1"]],["text",", teremos um bit "],["italic",["text","1"]],["text"," seguido de 63 bits "],["italic",["text","0"]],["text",". Como acabamos de dizer, o bit mais a esquerda é usado como indicador de sinal, retornando o maior número negativo possível, que é o gigantesco "],["monospaced",["text","-9.223.372.036.854.775.808"]],["text",". Esse bit mais a esquerda, que era "],["italic",["text","0"]],["text"," e virou "],["italic",["text","1"]],["text"," com a soma, transbordou na conta, vindo daí o termo "],["italic",["text","overflow"]],["text","."],["br"]],["paragraph",["text","Na figura "],["ref-label",["text","diagram-overflow"]],["text"," temos uma variável de oito bits contendo o valor "],["italic",["text","127"]],["text"," e ao somarmos "],["italic",["text","1"]],["text"," recebemos o valor "],["monospaced",["text","-128"]],["text",". Perceba que a soma "],["italic",["text","vaza"]],["text",", ou "],["italic",["text","transborda"]],["text",", para o bit responsável pelo sinal."],["br"]],["img",["text","images/capitulo_05/diagram_overflow.png w=80% \"Como acontece o overflow\" label=diagram-overflow"]],["paragraph",["br"]],["paragraph",["text","Voltando à nossa analogia, imagine que você, percebendo que o copo não vai comportar um litro d'água, ao invés de desistir ou desperdiçar água, busque um recipiente maior. Uma jarra, por exemplo. Pois é exatamente isso que o Clojure faz quando você usa o terceiro tipo de operador."],["br"]],["paragraph",["text","Vamos utilizar os operadores que já conhecemos seguidos do caracter "],["monospaced",["text","'"]],["text",", assim teremos as operações "],["monospaced",["text","+'"]],["text",", "],["monospaced",["text","*'"]],["text"," e várias outras que automaticamente modificam o tipo do dado em que o valor vai ser guardado."],["br"]],["code","clojure",["br"],["code-text","Long/MAX_VALUE"],["br"],["code-text","(+' 1 Long/MAX_VALUE)"],["br"]],["paragraph",["br"]],["paragraph",["text","Perceba na figura "],["ref-label",["text","repl-overflow-promote"]],["text"," que o resultado está correto e que também aparece a letra "],["monospaced",["text","N"]],["text",", que indica que o número agora é um "],["monospaced",["text","BigInt"]],["text",". Chamamos isso de "],["italic",["text","autopromoção"]],["text",", ou "],["italic",["text","promoção automática de tipos"]],["text","."],["br"]],["img",["text","images/capitulo_05/repl_overflow_promote.png w=90% \"Exemplo de autopromoção\" label=repl-overflow-promote"]],["paragraph",["br"]],["paragraph",["text","Então devemos usar sempre os operadores seguidos de "],["monospaced",["text","'"]],["text","? Não necessariamente."],["br"]],["paragraph",["text","Cada uma das formas tem suas vantagens e desvantagens. A forma "],["monospaced",["text","unchecked-"]],["text"," tende a ser mais rápida, sendo muito útil quando você está manipulando dados em conjunto com uma biblioteca do Java e a velocidade é algo crítico."],["br"]],["paragraph",["text","Já a forma seguida de "],["monospaced",["text","'"]],["text"," tende a ser mais lenta e ocupar mais memória, mas promove automaticamente os tipos de dados."],["br"]],["paragraph",["text","De qualquer forma, em pelo menos oitenta por cento dos casos, os operadores que você já conhecia servirão perfeitamente para o que você precisa."],["br"]],["section",["text","Indo além da base 10"]],["paragraph",["br"]],["paragraph",["text","É comum que as linguagens de programação forneçam formas de escrevermos números usando bases diferentes da que estamos habituados."],["br"]],["paragraph",["text","Nas linguagens inspiradas pelo C, podemos escrever números em base "],["italic",["text","8"]],["text"," e "],["italic",["text","16"]],["text"," no meio do código, e o próprio compilador se vira para converter."],["br"]],["box",["text","O compilador e as bases numéricas"],["paragraph",["br"]],["paragraph",["text","Se pararmos para pensar, não deve ser esforço nenhum, já que internamente os valores numéricos são convertidos para valores binários o tempo todo."],["br"]]],["paragraph",["br"]],["index",["text","octal"]],["paragraph",["br"]],["index",["text","hexadecimal"]],["paragraph",["br"]],["code","java",["br"],["code-text","// octal, ou base 8"],["br"],["code-text","072"],["br"],["code-text","// hexadecimal, ou base 16"],["br"],["code-text","0xCABECA"],["br"],["code-text","// decimal, ou base 10"],["br"],["code-text","42"],["br"]],["paragraph",["br"]],["paragraph",["text","Já o Clojure nos oferece bem mais do que vamos precisar. Podemos escrever números em praticamente qualquer base que desejarmos, além das que as linguagens tradicionais já nos oferecem."],["br"]],["index",["text","binário"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","2r101010"],["br"],["code-text","; 42"],["br"],["code-text","8r52"],["br"],["code-text","; 42"],["br"],["code-text","16rCABECA"],["br"],["code-text","; 13287114"],["br"],["code-text","10r1234"],["br"],["code-text","; 1234"],["br"]],["paragraph",["br"]],["paragraph",["text","Podemos colocar praticamente qualquer número inteiro antes do literal "],["monospaced",["text","r"]],["text",", e o compilador vai entender que queremos converter a partir daquela base."],["br"]],["box",["text","Os limites da brincadeira"],["paragraph",["br"]],["paragraph",["text","Na prática, podemos utilizar qualquer base entre "],["italic",["text","2"]],["text"," e "],["italic",["text","36"]],["text",", o que já é muito mais do que você vai precisar em qualquer situação normal."],["br"]]],["paragraph",["br"]],["code","clojure",["br"],["code-text","32rPLINIO"],["br"],["code-text","; 861494872"],["br"],["code-text","36rClojure"],["br"],["code-text","; 27432414842"],["br"]],["paragraph",["br"]],["paragraph",["text","Com tanta base disponível de forma transparente, dá para se divertir bastante com mensagens engraçadinhas."],["br"]],["index",["text","Notação científica"]],["paragraph",["br"]],["section",["text","Notação científica"]],["paragraph",["br"]],["paragraph",["text","Você pode expressar também números muito grandes ou muito pequenos usando "],["italic",["text","notação científica"]],["text","."],["br"]],["paragraph",["text","Notação científica é uma forma de representar valores usando a notação "],["monospaced",["text","a x 10^b"]],["text",". Podemos representar dois milhões como "],["monospaced",["text","2 * 10^6"]],["text"," ou, em Clojure, como "],["monospaced",["text","2e6"]],["text",". Um "],["italic",["text","googol"]],["text"," pode ser representado como "],["monospaced",["text","1e100"]],["text",", ou seja, o dígito um seguido de "],["italic",["text","100"]],["text"," zeros."],["br"]],["code","clojure",["br"],["code-text","2e6"],["br"],["code-text","; 2000000.0"],["br"],["code-text","(def googol 1e100)"],["br"],["code-text","googol"],["br"],["code-text","1.0E100"],["br"]],["paragraph",["br"]],["box",["text","Googol"],["paragraph",["br"]],["paragraph",["text","A constante "],["italic",["text","googol"]],["text"," foi imaginada pelo sobrinho do matemático Edward Kasner, em 1938, quando lhe foi perguntado como poderia se chamar o maior número que ele imaginasse"],["ref",["text","math-imagination"]],["text","."],["br"]],["paragraph",["text","Para se ter uma ideia do quão grande é esse valor, estima-se que o peso total do universo seja algo entre "],["monospaced",["text","10^50"]],["text"," e "],["monospaced",["text","10^60"]],["text"," quilos"],["ref",["text","deadbeat-universe"]],["text","."],["br"]],["paragraph",["text","Como você já deve ter imaginado, foi daí que os criadores do "],["italic",["text","Google"]],["text"," tiraram o nome para o projeto de faculdade"],["ref",["text","google-name"]],["text","."],["br"]]],["paragraph",["br"]],["paragraph",["text","Da mesma forma, podemos representar um número menor que "],["italic",["text","1"]],["text"," usando um expoente negativo."],["br"]],["paragraph",["text","Estima-se que um átomo de hidrogênio tenha "],["monospaced",["text","2.5 x 10^-11"]],["text"," metros. Isso dá onze zeros depois da vírgula e, em seguida, o número "],["italic",["text","25"]],["text","."],["br"]],["paragraph",["text","Obviamente a precisão e as casas decimais são ignoradas a partir de um certo tamanho porque, como já dissemos, a memória de um computador é limitada e temos estruturas bem reduzidas para armazenar números dentro dele."],["br"]],["code","clojure",["br"],["code-text","25e-12"],["br"],["code-text","; 2.5E-11"],["br"]],["paragraph",["br"]],["paragraph",["text","Caso você tenha curiosidade de saber os limites dessa notação, as constantes "],["monospaced",["text","MIN_VALUE"]],["text"," e "],["monospaced",["text","MAX_VALUE"]],["text"," da classe "],["monospaced",["text","Double"]],["text"," podem te dizer."],["br"]],["code","clojure",["br"],["code-text","Double/MAX_VALUE"],["br"],["code-text","; 1.7976931348623157E308"],["br"],["code-text","Double/MIN_VALUE"],["br"],["code-text","; 4.9E-324"],["br"]],["paragraph",["br"]],["paragraph",["text","Fique tranquilo. Com essa notação podemos trabalhar com números muito maiores que um "],["italic",["text","googol"]],["text"," e muito menores que o tamanho do menor átomo."],["br"]],["index",["text","Números racionais"]],["paragraph",["br"]],["section",["text","Números racionais"]],["paragraph",["br"]],["paragraph",["text","Quando dividimos um número por outro em Clojure podemos ter duas respostas diferentes: um número inteiro ou um número racional."],["br"]],["box",["text","Relembrando"],["paragraph",["br"]],["paragraph",["text","Um número racional é todo aquele que pode ser representado como uma fração, ou razão, entre dois números inteiros"],["ref",["text","numeros-racionais"]],["text","."],["br"]]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(/ 6 3)"],["br"],["code-text","; 2"],["br"],["code-text","(/ 1 3)"],["br"],["code-text","; 1/3"],["br"]],["paragraph",["br"]],["index",["text","Ratio"]],["paragraph",["br"]],["paragraph",["text","O resultado de "],["monospaced",["text","(/ 1 3)"]],["text"," é "],["monospaced",["text","1/3"]],["text",", um número que internamente é representado pelo tipo "],["monospaced",["text","Ratio"]],["text","."],["br"]],["paragraph",["text","Quando executamos a mesma operação em Java, Ruby ou qualquer outra linguagem popular, recebemos um número inteiro ou um decimal como resultado. Por que em Clojure é diferente?"],["br"]],["paragraph",["text","O mesmo comportamento, de receber um número racional ao invés de um decimal, é encontrado nas demais implementações de LISP, como o Common Lisp, Scheme e Racket para ficar nas mais conhecidas. Logo, é um comportamento esperado quando estamos usando um Lisp."],["br"]],["paragraph",["text","Mas não é simplesmente porque todo mundo faz que você deva fazer também. O tipo "],["monospaced",["text","Ratio"]],["text"," foi criado para que a perda de precisão com arredondamento seja reduzida ao mínimo possível."],["br"]],["index",["text","double"]],["paragraph",["br"]],["paragraph",["text","Para convertermos um valor racional em um valor decimal, basta utilizar a função "],["monospaced",["text","double"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(/ 1 3)"],["br"],["code-text","; 1/3"],["br"],["code-text","(double 1/3)"],["br"],["code-text","; 0.3333333333333333"],["br"]],["paragraph",["br"]],["index",["text","rationalize"]],["paragraph",["br"]],["paragraph",["text","E para converter um tipo decimal para racional, usamos a função "],["monospaced",["text","rationalize"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(rationalize 0.125)"],["br"],["code-text","; 1/8"],["br"]],["paragraph",["br"]],["paragraph",["text","Quando você divide um por três, você tem como resultado o número 0.333... seguido de infinitos 3. Essa repetição infinita de números é chamado de dízima periódica."],["br"]],["index",["text","propagação de erro"]],["paragraph",["br"]],["paragraph",["text","O problema é que em um computador existe um espaço finito para armazenar números, o que faz com que apenas uma quantidade reduzida de casas decimais seja armazenada. Esse truncamento do número gera uma perda que, mesmo minúscula, vai se acumulando com outros arredondamentos num processo conhecido matematicamente por "],["italic",["text","propagação de erro"]],["text","."],["br"]],["paragraph",["text","Em sistemas pequenos esse erro acumulado é irrelevante, mas em grandes sequencias de cálculos pode fazer com que o resultado seja distorcido e cause sérios problemas"],["ref",["text","round-error-1"]],["text","."],["br"]],["paragraph",["text","Nas listagens "],["ref-label",["text","cap05-ratio-0"]],["text"," e "],["ref-label",["text","cap05-ratio-1"]],["text"," podemos ver como uma operação matemática pode apresentar diferentes resultados se utilizarmos números decimais."],["br"]],["index",["text","repeat"]],["paragraph",["br"]],["paragraph",["text","Para termos uma boa quantidade de números para trabalhar, vamos usar a função "],["monospaced",["text","repeat"]],["text",", que recebe dois parâmetros e nos retorna uma lista. O primeiro é a quantidade de vezes que o item vai ser repetido, e o segundo parâmetro é o item a ser repetido:"],["br"]],["code","clojure",["br"],["code-text","(repeat 5 123)"],["br"],["code-text","; (123 123 123 123 123)"],["br"]],["paragraph",["br"]],["paragraph",["text","Usando o nosso já conhecido operador "],["monospaced",["text","->>"]],["text",", vamos somar cem mil ocorrências do número "],["monospaced",["text","0.3333333333333333"]],["text",", que é um dividido por três armazenado como um número decimal:"],["br"]],["code","clojure",["text"," \"Demonstrando um cálculo usando números decimais\" label=cap05-ratio-0"],["br"],["code-text","(double (/ 1 3)) ; temos um número decimal"],["br"],["code-text","; 0.3333333333333333"],["br"],["code-text","(->> 1/3             ; o valor de 1 / 3"],["br"],["code-text","     double          ; é convertido para decimal"],["br"],["code-text","     (repeat 100000) ; criamos uma lista com 100.000 repetições"],["br"],["code-text","     (reduce +))     ; e somamos"],["br"],["code-text","; 33333.33333328976"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos deixar para converter o valor para decimal apenas no final da operação:"],["br"]],["code","clojure",["text"," \"Demonstrando um cálculo usando números racionais\" label=cap05-ratio-1"],["br"],["code-text","(/ 1 3) ; temos um número racional"],["br"],["code-text","; 1/3"],["br"],["code-text","(->> 1/3              ; o valor de 1 / 3"],["br"],["code-text","      (repeat 100000) ; criamos uma lista com 100.000 repetições"],["br"],["code-text","      (reduce +)      ; e somamos"],["br"],["code-text","      double)         ; para só então convertemos para Double"],["br"],["code-text","; 33333.33333333333"],["br"]],["paragraph",["br"]],["paragraph",["text","Perceba que houve uma diferença perceptível nos resultados entre as duas formas de calcular. A conversão para decimal no final da operação adia até o último instante a perda de precisão do valor."],["br"]],["section",["text","Estruturas persistentes"]],["paragraph",["br"]],["paragraph",["text","Vamos criar uma lista com quatro elementos chamada "],["monospaced",["text","original"]],["text"," e vamos adicionar a ela um quinto elemento, guardando o resultado com o nome "],["monospaced",["text","nova"]],["text",":"],["br"]],["index",["text","conj"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","; criando o vetor original"],["br"],["code-text","(def original [1 2 3 4])"],["br"],["code-text","; adicionando um valor"],["br"],["code-text","(def novo (conj original 5))"],["br"],["code-text","original"],["br"],["code-text","; [1 2 3 4]"],["br"],["code-text","novo"],["br"],["code-text","; [1 2 3 4 5]"],["br"]],["paragraph",["br"]],["paragraph",["text","A função "],["monospaced",["text","conj"]],["text",", que adiciona um item ao final do vetor, retorna um novo valor e mantém o original inalterado, como já sabemos."],["br"]],["paragraph",["text","Aparentemente, "],["monospaced",["text","original"]],["text"," e "],["monospaced",["text","novo"]],["text"," são "],["italic",["text","arrays"]],["text"," diferentes. Isso significa que, ainda aparentemente, estamos ocupando memória com duas estruturas distintas, mas com grande parte dos valores repetidos. Isso soa como um belo "],["italic",["text","desperdício"]],["text"," de recursos."],["br"]],["paragraph",["text","Uma das vantagens de lidarmos com valores imutáveis é que, veja só, eles não mudam."],["br"]],["paragraph",["text","Isso significa que um valor imutável que está em um "],["italic",["text","array"]],["text"," imutável permanece o mesmo, não importando o que aconteça. Com isso não precisamos nos preocupar com efeitos colaterais e modificações inesperadas caso esse valor seja compartilhado entre duas estruturas diferentes. E é aí que está o princípio do que em Clojure é chamada de "],["italic",["text","estrutura persistente de dados"]],["text","."],["br"]],["paragraph",["text","Na figura "],["ref-label",["text","cap05-persistent-vector"]],["text"," podemos ter uma idéia do que acontece internamente. Não estamos vendo aqui exatamente como funciona um vetor no Clojure, mas a ideia é a mesma: compartilhar valores iguais entre dois ou mais vetores, otimizando o consumo de memória e melhorando a velocidade das operações."],["br"]],["img",["text","images/capitulo_05/persistent_vector.png \"Compartilhando partes em um vetor\" label=cap05-persistent-vector w=70%"]],["paragraph",["br"]],["paragraph",["text","Mapas e "],["italic",["text","sets"]],["text",", que veremos adiante, funcionam de forma parecida, sendo armazenados internamente em uma árvore e compartilhando partes conforme a necessidade."],["br"]],["paragraph",["text","Já uma lista é armazenada internamente como uma lista ligada, mas também compartilha parte de sua estrutura a cada operação."],["br"]],["section",["text","Coleções"]],["paragraph",["br"]],["paragraph",["text","Em Clojure, existe uma categoria de tipos de dados chamada genericamente de "],["italic",["text","coleções"]],["text",". Uma coleção nada mais é do que a "],["italic",["text","abstração de uma estrutura persistente que armazena um conjunto imutável de dados"]],["text","."],["br"]],["paragraph",["text","O que esse palavreado todo quer dizer?"],["br"]],["paragraph",["text","Quer dizer que uma coleção do Clojure, independente de qual seja, implementa internamente uma mesma interface Java. Essa interface declara operações comuns que permitem que você adicione, remova ou localize itens dentro de uma coleção usando as mesmas funções do Clojure."],["br"]],["paragraph",["text","Dessa forma você não precisa decorar dezenas de funções diferentes para conseguir trabalhar com cada tipo de coleção. Basta saber que uma função adiciona um item a uma coleção, e essa função vai adicionar itens em qualquer coleção que você esteja trabalhando."],["br"]],["img",["text","images/capitulo_05/colls.png \"Diagrama de classes das principais coleções do Clojure\" w=70% label=cap05-colls"]],["paragraph",["br"]],["paragraph",["text","Essas coleções podem ser classificadas, de uma maneira bem simplificada, de acordo com as interfaces Java que cada uma implementa internamente."],["br"]],["paragraph",["text","Apesar de cada tipo de dado em Clojure implementar uma avalanche de classes e interfaces Java, como podemos ver na figura "],["ref-label",["text","cap05-colls"]],["text",", podemos utilizar três delas para descrever cada um dos tipos principais de coleção: "],["monospaced",["text","Sequential"]],["text",", "],["monospaced",["text","Associative"]],["text"," e "],["monospaced",["text","Counted"]],["text",". Na imagem "],["ref-label",["text","cap05-venn"]],["text"," podemos ver mais claramente essa classificação."],["br"]],["img",["text","images/capitulo_05/collections_b.png \"Diagrama de Venn com as coleções do Clojure\" label=cap05-venn w=70%"]],["paragraph",["br"]],["paragraph",["text","Uma coleção sequencial, ou simplesmente uma "],["italic",["text","sequencia"]],["text",", é uma abstração que permite que você selecione tanto o primeiro item quanto o resto da sequencia sem o primeiro item, ou que você adicione um item na sequencia sem bagunçar a ordem que existe atualmente."],["br"]],["index",["text","range"]],["index",["text","first"]],["index",["text","rest"]],["index",["text","cons"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","; criando uma lazy sequence"],["br"],["code-text","(def lazy (range))"],["br"],["code-text","(first lazy)"],["br"],["code-text","; 0"],["br"],["code-text","; criando uma lista"],["br"],["code-text","(def sequencia '(1 2 3 4 5))"],["br"],["code-text","(rest sequencia)"],["br"],["code-text","; (2 3 4 5)"],["br"],["code-text","(last sequencia)"],["br"],["code-text","; 5"],["br"],["code-text","(cons sequencia 0)"],["br"],["code-text","; (0 1 2 3 4 5)"],["br"]],["paragraph",["br"]],["paragraph",["text","Uma coleção associativa permite que você acesse qualquer valor diretamente, bastando informar a sua posição ou a chave que faz referência àquela posição."],["br"]],["index",["text","nth"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","; criando um vetor"],["br"],["code-text","(def vetor [1 2 3 4 5])"],["br"],["code-text","(nth vetor 3)"],["br"],["code-text","; 4"],["br"],["code-text","; criando um mapa"],["br"],["code-text","(def cachorro {:cor \"azul\" :nome \"Bidu\"})"],["br"],["code-text","(cachorro :cor)"],["br"],["code-text","; \"azul\""],["br"]],["paragraph",["br"]],["paragraph",["text","Finalmente, uma coleção pode ser "],["italic",["text","contada"]],["text"," ou "],["italic",["text","mensurada"]],["text"," se nos permite saber a quantidade de itens que ela contém."],["br"]],["index",["text","count"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(def nomes [\"João\" \"José\" \"Nicolau\"])"],["br"],["code-text","(count nomes)"],["br"],["code-text","; 3"],["br"]],["paragraph",["br"]],["paragraph",["text","Essa divisão é apenas uma forma de ajudar a entender quando e como você deve usar cada coleção do Clojure. Vamos entrar em mais detalhes em cada um dos tipos, deixando claro que você pode criar suas próprias coleções se for necessário."],["br"]],["index",["text","listas"]],["index",["text","vetores"]],["paragraph",["br"]],["section",["text","Listas e vetores"]],["paragraph",["br"]],["paragraph",["text","Um código fonte escrito em Clojure é, basicamente, um conjunto de listas contendo operadores e operandos."],["br"]],["paragraph",["text","Por isso, a lista é a estrutura de dados mais comum, mas sua utilidade vai bem além das sequencias de instruções para o compilador."],["br"]],["paragraph",["text","Se você tentar trabalhar diretamente com uma lista, o compilador vai entender que estamos lidando com código fonte, e vai tentar executar o primeiro item como se fosse um operador."],["br"]],["code","clojure",["br"],["code-text","(1 2 3 4)"],["br"],["code-text","; ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn"],["br"]],["paragraph",["br"]],["index",["text","'"]],["index",["text","quote"]],["paragraph",["br"]],["paragraph",["text","Para que isso não aconteça, temos que informar ao compilador que o conteúdo da lista não deve ser avaliado. Para isso usamos o operador "],["monospaced",["text","'"]],["text",", conhecido como "],["italic",["text","quote"]],["text",". A forma especial "],["monospaced",["text","quote"]],["text"," causa o mesmo efeito."],["br"]],["paragraph",["text","Usar "],["italic",["text","quote"]],["text"," em uma lista faz com que ela seja transformada de código para dados."],["br"]],["code","clojure",["br"],["code-text","'(1 2 3 4)"],["br"],["code-text","; (1 2 3 4)"],["br"],["code-text","(quote (1 2 3 4))"],["br"],["code-text","; (1 2 3 4)"],["br"]],["paragraph",["br"]],["index",["text","~"]],["index",["text","unquote"]],["paragraph",["br"]],["paragraph",["text","É possível guardar código dentro de uma lista com "],["italic",["text","quote"]],["text",". Para executar a lista, efetuamos a operação inversa através do operador "],["monospaced",["text","~"]],["text",". O operador "],["monospaced",["text","~"]],["text",", chamado de "],["italic",["text","unquote"]],["text"," vai ser muito útil quando aprendermos sobre macros."],["br"]],["code","clojure",["br"],["code-text","(def lista '(+ 1 2 3))"],["br"],["code-text","lista"],["br"],["code-text","; (+ 1 2 3)"],["br"],["code-text","`~lista"],["br"],["code-text","; 6"],["br"]],["paragraph",["br"]],["paragraph",["text","Aqui nós criamos uma lista contendo uma instrução válida e fizemos o caminho oposto, transformando dados em código."],["br"]],["index",["text","`"]],["paragraph",["br"]],["paragraph",["text","O operador "],["monospaced",["text","`"]],["text",", conhecido entre nós como acento grave, significa "],["italic",["text","syntax-quote"]],["text",", e também será visto com mais atenção no capítulo sobre macros."],["br"]],["box",["text","Homoicônico"],["paragraph",["br"]],["paragraph",["text","Essa característica que o Clojure tem de tratar código e dados da mesma forma, chama-se "],["italic",["text","homoiconicidade"]],["text",". É isso que significa quando você ouve alguém dizer que os LISPs em geral, e o Clojure em particular, são "],["italic",["text","homoicônicos"]],["text","."],["br"]],["paragraph",["text","Linguagens como Java, Ruby, Python, PHP, C, que tratam código e dados de forma diferente, são chamadas "],["italic",["text","heteroicônicas"]],["text",", ou simplesmente de "],["italic",["text","não homoicônicas"]],["text","."],["br"]]],["paragraph",["br"]],["index",["text","vector"]],["paragraph",["br"]],["paragraph",["text","O Clojure oferece também um tipo chamado "],["italic",["text","vector"]],["text",", que assim como uma lista, pode ter qualquer posição acessada através da função "],["monospaced",["text","nth"]],["text",", começando por zero. Um "],["italic",["text","vector"]],["text"," é equivalente a um "],["italic",["text","array"]],["text"," nas demais linguagens."],["br"]],["code","clojure",["br"],["code-text","; acessando a posição na lista"],["br"],["code-text","(nth '(1 2 3 4) 3)"],["br"],["code-text","; 4"],["br"],["code-text","; acessando a posição no vetor"],["br"],["code-text","(nth [1 2 3 4] 3)"],["br"],["code-text","; 4"],["br"]],["paragraph",["br"]],["paragraph",["text","Um vetor também pode ser usado como função. Ao passar um valor numérico para um vetor, você obtém o valor contido naquela posição."],["br"]],["code","clojure",["br"],["code-text","([1 2 3 4] 3)"],["br"],["code-text","; 4"],["br"],["code-text","(= ([1 2 3 4] 3)"],["br"],["code-text","   (nth [1 2 3 4] 3))"],["br"],["code-text","; true"],["br"]],["paragraph",["br"]],["paragraph",["text","Assim você elimina a chamada a "],["monospaced",["text","nth"]],["text"," explícita ao acessar alguma posição de um vetor. Internamente o vetor vai continuar usando "],["monospaced",["text","nth"]],["text"," para acessar aquela posição, então usar ou não acaba sendo uma questão de estilo e legi bilidade."],["br"]],["paragraph",["text","Existem algumas diferenças importantes entre as listas e os vetores e que vale a pena conhecer."],["br"]],["paragraph",["text","A principal diferença é que vetores guardam apenas dados, diferente do que já aprendemos sobre listas e não é tão simples converter os itens de um vetor em uma expressão."],["br"]],["paragraph",["text","Vetores têm um tempo constante de acesso a qualquer posição, então uma lista leva mais tempo para acessar um item que está no meio do que um que está no começo."],["br"]],["paragraph",["text","Um vetor é alocado de uma única vez na memória, tornando impossível lidar com quantidades imensas de informação, enquanto com uma lista você pode alocar somente o que está sendo utilizado naquele momento. Veremos isso com detalhes ao tratar de "],["italic",["text","lazy sequences"]],["text","."],["br"]],["paragraph",["text","Listas são úteis em situações em que é necessário processar itens em sequencia, e por isso são chamadas na documentação de "],["italic",["text","sequences"]],["text",". Já vetores são preferíveis quando é necessário acessar posições aleatórias."],["br"]],["paragraph",["text","Devido à forma como listas e vetores são armazenados internamente, você obtém resultados diferentes ao adicionar um item a uma lista existente. Em uma lista você adiciona um item na primeira posição, enquanto num vetor o item é adicionado sempre no final."],["br"]],["code","clojure",["br"],["code-text","(conj [1 2 3 4] 5)"],["br"],["code-text","; [1 2 3 4 5]"],["br"],["code-text","(conj '(1 2 3 4) 5)"],["br"],["code-text","; (5 1 2 3 4)"],["br"]],["paragraph",["br"]],["paragraph",["text","Isso acontece porque uma lista pode ser entendida como uma estrutura de dados chamada de "],["italic",["text","lista ligada"]],["text",", onde você armazena uma referência para o primeiro item, e cada item armazena a referência para o próximo."],["br"]],["img",["text","images/capitulo_05/linked_list_1.png \"'(1 2 3 4)\" label=cap05-linked-list1 w=70%"]],["paragraph",["br"]],["paragraph",["text","Assim, é bem mais barato armazenar a referência para o item que está sendo adicionado e apontar o próximo item para a referência antiga, colocando o novo item como primeiro da lista."],["br"]],["img",["text","images/capitulo_05/linked_list_2.png \"(conj '(1 2 3 4) 5)\" label=cap05-linked-list2 w=70%"]],["paragraph",["br"]],["paragraph",["text","Na figura "],["ref-label",["text","cap05-linked-list1"]],["text"," podemos ver a lista "],["monospaced",["text","'(1 2 3 4)"]],["text"," como uma lista ligada, e em "],["ref-label",["text","cap05-linked-list2"]],["text"," podemos entender melhor como um item é adicionado à lista."],["br"]],["index",["text","map"]],["index",["text","mapv"]],["paragraph",["br"]],["index",["text","filter"]],["index",["text","filterv"]],["paragraph",["br"]],["paragraph",["text","Funções como "],["monospaced",["text","map"]],["text"," e "],["monospaced",["text","filter"]],["text"," aceitam tanto listas como vetores como parâmetros, mas retornam sempre uma sequencia como resultado. Caso você queira outro vetor como resposta, use as funções "],["monospaced",["text","mapv"]],["text"," e "],["monospaced",["text","filterv"]],["text",", respectivamente."],["br"]],["code","clojure",["br"],["code-text","(map inc [1 2 3 4 5 6])"],["br"],["code-text","; (2 3 4 5 6 7)"],["br"],["code-text","(mapv inc [1 2 3 4 5 6])"],["br"],["code-text","; [2 3 4 5 6 7]"],["br"],["code-text","(filter even? [1 2 3 4 5 6])"],["br"],["code-text","; (2 4 6)"],["br"],["code-text","(filterv even? [1 2 3 4 5 6])"],["br"],["code-text","; [2 4 6]"],["br"]],["paragraph",["br"]],["section",["text","Filas e pilhas"]],["paragraph",["br"]],["paragraph",["text","Uma fila é uma estrutura de dados onde o primeiro item inserido é o primeiro a ser retirado."],["br"]],["paragraph",["text","Vamos imaginar a fila do supermercado, onde a pessoa que chegou primeiro é a primeira a ser atendida. Ao ser atendida, a pessoa sai da fila e assim por diante até que a fila fique vazia, ou o supermercado encerre as atividades."],["br"]],["paragraph",["text","Apesar do Clojure ter uma implementação de fila, até a versão 1.6.0 ainda não estava disponível um conjunto de funções que nos permita criar essa estrutura de forma idiomática."],["br"]],["paragraph",["text","Felizmente, como já pudemos ver, Clojure e Java se conversam bem, então podemos usar a própria classe Java que implementa a fila do Clojure dentro do nosso código."],["br"]],["index",["text","clojure.lang.PersistentQueue"]],["paragraph",["br"]],["paragraph",["text","Para criarmos uma fila vazia, basta usarmos a classe Java "],["monospaced",["text","clojure.lang.PersistentQueue"]],["text",", que já nos oferece uma instância de uma fila vazia, chamada "],["monospaced",["text","EMPTY"]],["text","."],["br"]],["paragraph",["text","Vamos guardar essa fila num "],["italic",["text","var"]],["text"," chamado "],["monospaced",["text","fila-vazia"]],["text",":"],["br"]],["index",["text","empty?"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(def fila-vazia (clojure.lang.PersistentQueue/EMPTY))"],["br"],["code-text","(empty? fila-vazia)"],["br"],["code-text","; true"],["br"]],["paragraph",["br"]],["paragraph",["text","Usamos a função "],["monospaced",["text","empty?"]],["text"," para mostrar que a fila está vazia. Essa função retorna "],["monospaced",["text","true"]],["text"," sempre que uma coleção vazia qualquer for passada como parâmetro."],["br"]],["index",["text","conj"]],["paragraph",["br"]],["paragraph",["text","Vamos adicionar o valor "],["italic",["text","1"]],["text"," na fila, de acordo com a figura "],["ref-label",["text","cap05-queue1"]],["text",". Como estamos lidando com uma estrutura imutável, ao adicionarmos um item em uma fila teremos outra fila. Vamos salvar essa fila nova em "],["monospaced",["text","fila-1"]],["text",". Vamos usar a função "],["monospaced",["text","conj"]],["text",", que é a mesma que já utilizamos para adicionar itens em listas e vetores."],["br"]],["code","clojure",["br"],["code-text","(def fila-1 (conj fila-vazia 1))"],["br"],["code-text","(println \"Tamanho:\" (count fila-1))"],["br"],["code-text","; Tamanho: 1"],["br"],["code-text","(println \"Primeiro item: \" (peek fila-1))"],["br"],["code-text","; Primeiro item:  1"],["br"]],["paragraph",["br"]],["img",["text","images/capitulo_05/queue_1.png \"Entra 1 na fila\" label=cap05-queue1 w=60%"]],["paragraph",["br"]],["index",["text","count"]],["index",["text","peek"]],["paragraph",["br"]],["paragraph",["text","A função "],["monospaced",["text","count"]],["text",", nossa conhecida de outras coleções, nos retorna a quantidade de itens contidos na fila. Já a função "],["monospaced",["text","peek"]],["text"," nos mostra quem é o primeiro item da fila. Como a fila é imutável, é necessário termos uma função que pegue o primeiro item da fila e outra que nos retorne a fila sem esse primeiro elemento."],["br"]],["paragraph",["text","Sem muita pressa, vamos adicionar dois itens de uma vez na nossa fila. Vamos chamar a nova fila de "],["monospaced",["text","fila-2"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def fila-2 (conj fila-1 2 3))"],["br"],["code-text","(println \"Tamanho:\" (count fila-2))"],["br"],["code-text","; Tamanho: 3"],["br"],["code-text","(peek fila-2)"],["br"],["code-text","; 1"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora a pilha pode ser representada conforme a figura "],["ref-label",["text","cap05-queue2"]],["text",". Perceba que o valor "],["italic",["text","1"]],["text"," ainda é o primeiro da fila, já que foi o primeiro a entrar nela."],["br"]],["img",["text","images/capitulo_05/queue_2.png \"Entram 2 e 3 na fila\" label=cap05-queue2 w=60%"]],["paragraph",["br"]],["paragraph",["text","Agora vamos retirar o primeiro item da fila e guardar o resultado em "],["monospaced",["text","fila-3"]],["text","."],["br"]],["paragraph",["text","Para pegarmos o primeiro item da fila, usamos a nossa conhecida função "],["monospaced",["text","peek"]],["text",", mas para devolvermos a função sem esse item, devemos usar a função "],["monospaced",["text","pop"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def fila-3 (pop fila-2))"],["br"],["code-text","(println \"Tamanho:\" (count fila-3))"],["br"],["code-text","; 2"],["br"],["code-text","(peek fila-3)"],["br"],["code-text","; 2"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora temos a fila da figura "],["ref-label",["text","cap05-queue3"]],["text",", com dois elementos e o valor "],["italic",["text","2"]],["text"," como o primeiro da fila."],["br"]],["img",["text","images/capitulo_05/queue_3.png \"Sai um item da fila\" label=cap05-queue3 w=60%"]],["paragraph",["br"]],["title",["text","Uma forma idiomática"]],["paragraph",["br"]],["paragraph",["text","No início da explicação foi comentado que "],["italic",["text","não existe ainda uma forma idiomática de criar filas em Clojure"]],["text",". Uma forma idiomática é aquela que está de acordo com o "],["italic",["text","jeito Clojure de fazer as coisas"]],["text","."],["br"]],["paragraph",["text","A forma idiomática de se criar uma fila em Clojure seria, ao invés de usarmos diretamente uma classe Java para isso, utilizarmos uma função, que podemos escrever facilmente enquanto a biblioteca padrão não nos fornece esse recurso."],["br"]],["index",["text","queue"]],["paragraph",["br"]],["paragraph",["text","Vamos criar uma função "],["monospaced",["text","queue"]],["text"," que cria essa fila:"],["br"]],["code","clojure",["br"],["code-text","(defn queue []"],["br"],["code-text","  (clojure.lang.PersistentQueue/EMPTY))"],["br"],["code-text","(def fila (queue))"],["br"],["code-text","(empty? fila)"],["br"],["code-text","; true"],["br"]],["paragraph",["br"]],["paragraph",["text","Nossa função retorna uma fila vazia. Mas, e se quisermos criar uma fila que já contenha quantos elementos quisermos? Basta adicionar mais uma assinatura à função e usar a função "],["monospaced",["text","conj"]],["text"," para adicionar os valores passados por parâmetro."],["br"]],["code","clojure",["br"],["code-text","(defn queue"],["br"],["code-text","  ([]"],["br"],["code-text","    (clojure.lang.PersistentQueue/EMPTY))"],["br"],["code-text","  ([& items]"],["br"],["code-text","    (apply conj (queue) items)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Como podemos receber uma quantidade variável de parâmetros, os valores passados para "],["monospaced",["text","queue"]],["text"," ficam armazenados no vetor "],["monospaced",["text","items"]],["text",". Para convertermos esse vetor em uma lista de argumentos para a função "],["monospaced",["text","conj"]],["text",", usamos a função "],["monospaced",["text","apply"]],["text",", passando também uma lista vazia através da própria função "],["monospaced",["text","queue"]],["text"," sem parãmetros."],["br"]],["code","clojure",["br"],["code-text","(count (queue))"],["br"],["code-text","; 0"],["br"],["code-text","(count (queue 1 2 3 4 5))"],["br"],["code-text","; 5"],["br"]],["paragraph",["br"]],["index",["text","queue?"]],["index",["text","instance?"]],["paragraph",["br"]],["paragraph",["text","Para sabermos se um item é ou não uma fila, vamos criar uma função chamada "],["monospaced",["text","queue?"]],["text",", que simplesmente verifica se o valor informado é uma instância da classe "],["monospaced",["text","PersistentQueue"]],["text",". Para isso, vamos usar a função "],["monospaced",["text","instance?"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn queue? [val]"],["br"],["code-text","  (instance? clojure.lang.PersistentQueue val))"],["br"],["code-text","(queue? (queue))"],["br"],["code-text","; true"],["br"],["code-text","(queue? [])"],["br"],["code-text","; false"],["br"],["code-text","(queue? '())"],["br"],["code-text","; false"],["br"]],["paragraph",["br"]],["paragraph",["text","Mesmo quando o Clojure não te oferece algo por padrão, é fácil e rápido fazermos uma adaptação para que possamos trabalhar bem."],["br"]],["title",["text","Pilhas"]],["paragraph",["br"]],["paragraph",["text","Isso acontece com a estrutura de dados conhecida como "],["italic",["text","pilha"]],["text",". O Clojure não nos fornece uma função nativa ou uma classe Java para lidarmos com pilhas, mas podemos adaptar uma lista para termos as mesmas funcionalidades."],["br"]],["paragraph",["text","Para entendermos uma pilha, podemos pensar em uma pilha de pratos para lavar. O primeiro prato que você colocar na pilha vai ser o último que você vai conseguir tirar. Da mesma forma, o último prato que você colocar, que é aquele que vai estar no topo, é o primeiro a ser retirado."],["br"]],["paragraph",["text","Para utilizarmos pilhas em Clojure, basta usarmos a nossa já conhecida "],["italic",["text","lista"]],["text",". Como o último valor adicionado a uma lista fica sempre no começo, temos uma estrutura pronta para fazer o que queremos."],["br"]],["paragraph",["text","Vamos criar uma lista vazia e chamá-la de "],["monospaced",["text","pilha"]],["text",", para então adicionar o valor "],["italic",["text","1"]],["text",", conforme a figura "],["ref-label",["text","cap05-stack1"]],["text",", armazenando o resultado em "],["monospaced",["text","pilha-1"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def pilha '())"],["br"],["code-text","(def pilha-1 (conj pilha 1))"],["br"],["code-text","pilha-1"],["br"],["code-text","; (1)"],["br"],["code-text","(peek pilha-1)"],["br"],["code-text","; 1"],["br"]],["paragraph",["br"]],["img",["text","images/capitulo_05/stack_1.png \"Entra 1 na pilha\" label=cap05-stack1 w=50%"]],["paragraph",["br"]],["paragraph",["text","Usando as mesmas funções "],["monospaced",["text","conj"]],["text"," para adicionar, e "],["monospaced",["text","peek"]],["text"," para saber qual é o primeiro item, não conseguimos ver ainda nenhum comportamento de pilha."],["br"]],["paragraph",["text","Vamos então adicionar os valores "],["italic",["text","2"]],["text"," e "],["italic",["text","3"]],["text",", respectivamente, para termos a pilha da figura "],["ref-label",["text","cap05-stack2"]],["text"," e entendermos melhor como ela funciona. Vamos chamar a nova pilha de "],["monospaced",["text","pilha-2"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def pilha-2 (conj pilha-1 2 3))"],["br"],["code-text","pilha-2"],["br"],["code-text","; (3 2 1)"],["br"],["code-text","(peek pilha-2)"],["br"],["code-text","; 3"],["br"]],["paragraph",["br"]],["img",["text","images/capitulo_05/stack_2.png \"Entram 2 e 3 na pilha\" label=cap05-stack2 w=50%"]],["paragraph",["br"]],["paragraph",["text","Agora o primeiro item da pilha é o valor "],["italic",["text","3"]],["text",", que foi justamente o último a ser adicionado."],["br"]],["paragraph",["text","Vamos agora remover o primeiro item da pilha usando a função "],["monospaced",["text","pop"]],["text",", para termos a pilha representada na figura "],["ref-label",["text","cap05-stack3"]],["text",". Vamos armazenar a nova pilha em "],["monospaced",["text","pilha-3"]],["text","."],["br"]],["img",["text","images/capitulo_05/stack_3.png \"Sai um item da pilha\" label=cap05-stack3 w=50%"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(def pilha-3 (pop pilha-2))"],["br"],["code-text","pilha-3"],["br"],["code-text","; (2 1)"],["br"],["code-text","(peek pilha-3)"],["br"],["code-text","; 2"],["br"]],["paragraph",["br"]],["paragraph",["text","Usando "],["monospaced",["text","peek"]],["text"," agora nós vemos que o próximo valor da pilha é "],["italic",["text","2"]],["text",". O valor "],["italic",["text","1"]],["text",", que foi o primeiro a entrar na pilha, vai ser o último a sair."],["br"]],["section",["text","Mapas"]],["paragraph",["br"]],["paragraph",["text","Um mapa é uma coleção que relaciona uma chave a um valor. Em outras linguagens você pode encontrar a mesma estrutura com os nomes de "],["italic",["text","dicionário"]],["text","."],["br"]],["paragraph",["text","Clojure oferece duas formas principais de mapas: um "],["italic",["text","hashmap"]],["text",", que é o tipo mais comum e por padrão não garante a ordem dos itens, e "],["monospaced",["text","sorted-map"]],["text",", que ordena os dados conforme eles são adicionados."],["br"]],["paragraph",["text","Para criarmos um mapa, podemos utilizar os caracteres "],["monospaced",["text","{"]],["text"," e "],["monospaced",["text","}"]],["text"," entre os pares de valores, sendo que o primeiro item do par é a chave, e o segundo é o valor."],["br"]],["paragraph",["text","Vamos voltar ao nosso mapa com os nomes dos estados:"],["br"]],["code",["br"],["code-text","(def estados {:es \"Espírito Santo\""],["br"],["code-text","              :mg \"Minas Gerais\""],["br"],["code-text","              :rj \"Rio de Janeiro\""],["br"],["code-text","              :sp \"São Paulo\"})"],["br"]],["paragraph",["br"]],["paragraph",["text","Os "],["italic",["text","keywords"]],["text"," "],["monospaced",["text",":es"]],["text",", "],["monospaced",["text",":mg"]],["text",", "],["monospaced",["text",":rj"]],["text"," e "],["monospaced",["text",":sp"]],["text"," são as chaves e os nomes dos estados são os valores."],["br"]],["paragraph",["text","Para acessá-los, basta você informar o mapa e a respectiva chave."],["br"]],["code",["br"],["code-text","(estados :sp)"],["br"],["code-text","; \"São Paulo\""],["br"]],["paragraph",["br"]],["paragraph",["text","Ou a chave e o respectivo mapa, nessa ordem, uma vez que um "],["italic",["text","keyword"]],["text"," pode ser tratado como uma função. Lembra que comentamos isso lá no começo, ao apresentarmos o tipo "],["italic",["text","keyword"]],["text","?"],["br"]],["code",["br"],["code-text","(:sp estados)"],["br"],["code-text","; \"São Paulo\""],["br"]],["paragraph",["br"]],["paragraph",["text","Olhando assim, tanto faz uma forma como outra. Mas, e se ao invés de um mapa todo certinho e preenchido, como é o caso de "],["monospaced",["text","estados"]],["text",", recebermos um valor nulo?"],["br"]],["code","clojure",["br"],["code-text","(def estados-nulos nil)"],["br"],["code-text","(estados-nulos :sp)"],["br"],["code-text","; NullPointerException   user/eval677 (NO_SOURCE_FILE:1)"],["br"]],["paragraph",["br"]],["paragraph",["text","Ao tentar acessar "],["monospaced",["text","nil"]],["text"," como um mapa, nós vamos receber o famigerado "],["monospaced",["text","NullPointerException"]],["text",", e provavelmente vamos derrubar nossa aplicação."],["br"]],["paragraph",["text","Para resolver isso, basta trocarmos a ordem, usando o "],["italic",["text","keyword"]],["text"," "],["bold",["text","antes"]],["text"," do mapa. É aí que começa a fazer sentido um "],["italic",["text","keyword"]],["text"," ser tratado como função, e é por isso também que eu disse antes que é uma boa prática:"],["br"]],["code","clojure",["br"],["code-text","(def estados-nulos nil)"],["br"],["code-text","(:sp estados-nulos)"],["br"],["code-text","; nil"],["br"]],["paragraph",["br"]],["paragraph",["text","Essa segunda forma também auxilia muito ao acessarmos mapas dentro de mapas. Vamos imaginar que alguma função tenha convertido um arquivo "],["italic",["text","XML"]],["text"," vindo de um sistema comercial em um mapa Clojure para podermos trabalhar melhor."],["br"]],["paragraph",["text","O nosso "],["italic",["text","XML"]],["text"," original teria essa estrutura:"],["br"]],["code",["text","html"],["br"],["code-text","<xml>"],["br"],["code-text","  <compra>"],["br"],["code-text","    <valor>1000.00</valor>"],["br"],["code-text","    <produto>Banana</produto>"],["br"],["code-text","    <quantidade>2000</quantidade>"],["br"],["code-text","    <unidade>kg</unidade>"],["br"],["code-text","  </compra>"],["br"],["code-text","</xml>"],["br"]],["paragraph",["br"]],["paragraph",["text","Que convertido para um mapa Clojure ficaria com a seguinte estrutura:"],["br"]],["code","clojure",["br"],["code-text","(def transacao {:compra {:valor 1000.0"],["br"],["code-text","                         :produto \"Banana\""],["br"],["code-text","                         :quantidade 2000.0"],["br"],["code-text","                         :unidade \"kg\"}})"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora precisamos exibir um texto contendo a descrição do produto que foi comprado."],["br"]],["paragraph",["text","Podemos usar a forma comum, com o mapa antes da chave:"],["br"]],["code","clojure",["br"],["code-text","(println \"O cliente comprou\" ((transacao :compra) :produto))"],["br"],["code-text","; O cliente comprou Banana"],["br"]],["paragraph",["br"]],["paragraph",["text","Ou podemos usar a forma em que a chave vem antes do mapa:"],["br"]],["code","clojure",["br"],["code-text","(println \"O cliente comprou\" (:produto (:compra transacao)))"],["br"],["code-text","; O cliente comprou Banana"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos usar o que aprendemos até agora sobre mapas, "],["italic",["text","keywords"]],["text"," e funções e vamos deixar essa expressão ainda mais simples e legível:"],["br"]],["code","clojure",["br"],["code-text","(let [descricao (-> transacao"],["br"],["code-text","                    :compra"],["br"],["code-text","                    :produto)]"],["br"],["code-text","  (println \"O cliente comprou\" descricao))"],["br"]],["paragraph",["br"]],["paragraph",["text","Como "],["italic",["text","keywords"]],["text"," também são reconhecidos pelo compilados como funções, podemos usá-los sem problema algum com os "],["italic",["text","thread macros"]],["text","."],["br"]],["paragraph",["text","A chave de um mapa pode ser qualquer valor válido em Clojure, e não apenas um "],["italic",["text","keyword"]],["text","."],["br"]],["paragraph",["text","Podemos usar um número como chave:"],["br"]],["code","clojure",["br"],["code-text","(def mapa-num {1 2 3 4 5 6 7 8})"],["br"],["code-text","(mapa-num 3)"],["br"],["code-text","; 4"],["br"]],["paragraph",["br"]],["paragraph",["text","Podemos usar um texto, ou qualquer outro valor que quisermos:"],["br"]],["code","clojure",["br"],["code-text","(def mapa-str {\"SP\" \"São Paulo\""],["br"],["code-text","               \"RJ\" \"Rio de Janeiro\""],["br"],["code-text","               \"MG\" \"Minas Gerais\"})"],["br"],["code-text","(mapa-str \"SP\")"],["br"],["code-text","; \"São Paulo\""],["br"],["code-text","(def mapa-bool {true \"Verdadeiro\" false \"Falso\"})"],["br"],["code-text","(mapa-bool true)"],["br"],["code-text","; \"Verdadeiro\""],["br"]],["paragraph",["br"]],["title",["text","Mapas ordenados e não ordenados"]],["paragraph",["br"]],["paragraph",["text","Foi dito anteriormente que mapas, por padrão, não garantem a ordem dos itens. Isso acontece por conta da forma como os mapas são implementados internamente."],["br"]],["paragraph",["text","Ao criar um mapa vazio usando "],["monospaced",["text","{ }"]],["text",", estamos criando um "],["monospaced",["text","array-map"]],["text",". Essa forma de mapa é recomendada para pequenas quantidades de dados, já que mantem a ordem dos itens no momento de sua criação, mas aumenta o tempo de acesso a cada um deles conforme você vai avançando para o final da coleção."],["br"]],["paragraph",["text","A partir de um certo tamanho, que varia de acordo com a implementação, é recomendado trabalhar com "],["monospaced",["text","hash-map"]],["text",", que já é otimizado para quantidades maiores de informação, mas não garante a ordem dos elementos."],["br"]],["index",["text","{}"]],["index",["text","array-map"]],["index",["text","hash-map"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","{ }"],["br"],["code-text","; {}"],["br"],["code-text","(array-map)"],["br"],["code-text","; {}"],["br"],["code-text","(hash-map)"],["br"],["code-text","; {}"],["br"]],["paragraph",["br"]],["paragraph",["text","As três formas, "],["monospaced",["text","{ }"]],["text",", "],["monospaced",["text","array-map"]],["text"," e "],["monospaced",["text","hash-map"]],["text"," criam um mapa. Internamente podemos perceber que as duas últimas formas armazenam os valores de formas diferentes."],["br"]],["code",["br"],["code-text","{:a 1 :b 2 :c 3 :d 4}"],["br"],["code-text","; {:c 3, :b 2, :d 4, :a 1}"],["br"],["code-text","(array-map :a 1 :b 2 :c 3 :d 4)"],["br"],["code-text","; {:a 1, :b 2, :c 3, :d 4}"],["br"],["code-text","(hash-map :a 1 :b 2 :c 3 :d 4)"],["br"],["code-text","; {:c 3, :b 2, :d 4, :a 1}"],["br"]],["paragraph",["br"]],["paragraph",["text","Qual formas devemos utilizar então?"],["br"]],["paragraph",["text","Quando você cria a forma "],["monospaced",["text","{ }"]],["text"," para criar um mapa, o próprio Clojure seleciona a melhor estrutura de acordo com a quantidade de itens. O mesmo acontece com as funções que manipulam mapas, e é onde não podemos confiar que o mapa terá a ordem dos valores mantida."],["br"]],["index",["text","assoc"]],["paragraph",["br"]],["paragraph",["text","Vamos criar um mapa usando "],["monospaced",["text","array-map"]],["text",", que manteve a ordem dos itens no nosso exemplo. Em seguida vamos usar a função "],["monospaced",["text","assoc"]],["text"," para criar um novo mapa com dois novos itens que queremos adicionar."],["br"]],["code","clojure",["br"],["code-text","(def mapa-1 (array-map :a 1 :b 2 :c 3 :d 4))"],["br"],["code-text","mapa-1"],["br"],["code-text","(assoc mapa-1 :e 5 :f 6)"],["br"],["code-text","; {:f 6, :e 5, :a 1, :b 2, :c 3, :d 4}"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que a ordem do novo mapa já começa a ficar bagunçada. O fato de termos escolhido a função "],["monospaced",["text","array-map"]],["text"," não significa que os novos mapas que criarmos vão manter a ordem."],["br"]],["paragraph",["text","Caso a ordem seja realmente importante, você deve criar o mapa usando a função "],["monospaced",["text","sorted-map"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def mapa-ordenado (sorted-map :a 1 :b 2 :c 3 :d 4))"],["br"],["code-text","mapa-ordenado"],["br"],["code-text","; {:a 1, :b 2, :c 3, :d 4}"],["br"],["code-text","(assoc mapa-ordenado :e 5 :f 6)"],["br"],["code-text","; {:a 1, :b 2, :c 3, :d 4, :e 5, :f 6}"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora podemos adicionar quantos itens quisermos e o mapa estará sempre ordenado."],["br"]],["index",["text","sorted-map-by"]],["paragraph",["br"]],["paragraph",["text","Vamos bagunçar um pouco mais e criar um mapa que esteja ordenado de forma decrescente. Para isso vamos usar "],["monospaced",["text","sorted-map-by"]],["text",", que recebe uma função como primeiro parâmetros e os itens do mapa em seguida."],["br"]],["index",["text","compare"]],["paragraph",["br"]],["paragraph",["text","A nossa função vai comparar as chaves usando a função da biblioteca padrão chamada "],["monospaced",["text","compare"]],["text",". Essa função retorna "],["italic",["text","1"]],["text"," se o segundo item for maior que o primeiro, "],["monospaced",["text","-1"]],["text"," se o primeiro for maior que o segundo e "],["italic",["text","0"]],["text"," se os itens forem iguais."],["br"]],["paragraph",["text","Como queremos inverter o funcionamento da função "],["monospaced",["text","compare"]],["text",", vamos multiplicar o resultado por "],["monospaced",["text","-1"]],["text"," em nossa função "],["monospaced",["text","ordena"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn ordena [a b]"],["br"],["code-text","  (* -1 (compare a b)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora passamos "],["monospaced",["text","ordena"]],["text"," como parâmetro para "],["monospaced",["text","sorted-map-by"]],["text"," e eis o nosso mapa ordenado decrescente."],["br"]],["code","clojure",["br"],["code-text","(def mapa-ordenado-2 (sorted-map-by ordena :a 1 :b 2 :c 3 :d 4))"],["br"],["code-text","mapa-ordenado-2"],["br"],["code-text","; {:d 4, :c 3, :b 2, :a 1}"],["br"]],["paragraph",["br"]],["paragraph",["text","Podemos adicionar quantos itens quisermos no nosso novo mapa e a ordem será mantida."],["br"]],["code","clojure",["br"],["code-text","(assoc mapa-ordenado-2 :e 5 :f 6 :g 7)"],["br"],["code-text","; {:g 7, :f 6, :e 5, :d 4, :c 3, :b 2, :a 1}"],["br"]],["paragraph",["br"]],["title",["text","Manipulando mapas"]],["paragraph",["br"]],["paragraph",["text","Quando manipulamos mapas, tanto faz se são ordenados ou não. As funções que tratam de um tipo também tratam de outro, tornando mais fácil memorizar ou pesquisar aquela que precisamos."],["br"]],["paragraph",["text","O nosso já conhecido "],["monospaced",["text","conj"]],["text"," também tem utilidade aqui. Como acontece com as demais coleção, essa função junta um mapa com outro, retornando um terceiro."],["br"]],["code","clojure",["br"],["code-text","(def sudeste {:es \"Espírito Santo\""],["br"],["code-text","              :mg \"Minas Gerais\""],["br"],["code-text","              :rj \"Rio de Janeiro\""],["br"],["code-text","              :sp \"São Paulo\"})"],["br"],["code-text","(def sul {:pr \"Paraná\""],["br"],["code-text","          :sc \"Santa Catarina\""],["br"],["code-text","          :rs \"Rio Grande do Sul\"})"],["br"],["code-text","(def sul-sudeste (conj sul sudeste))"],["br"],["code-text","sul-sudeste"],["br"],["code-text","; {:es \"Espírito Santo\", :sp \"São Paulo\", :rs \"Rio Grande do Sul\", "],["br"],["code-text",";  :sc \"Santa Catarina\", :mg \"Minas Gerais\", :pr \"Paraná\","],["br"],["code-text",";  :rj \"Rio de Janeiro\"}"],["br"]],["paragraph",["br"]],["paragraph",["text","A diferença para a função "],["monospaced",["text","assoc"]],["text",", que conhecemos há pouco, é que "],["monospaced",["text","conj"]],["text"," junta um mapa com outro, enquanto "],["monospaced",["text","assoc"]],["text"," associa um mapa a um ou mais pares de chave e valor."],["br"]],["code","clojure",["br"],["code-text","(assoc {:raiz \"Batata\"} :fruta \"Pera\")"],["br"],["code-text","; {:fruta \"Pera\", :raiz \"Batata\"}"],["br"],["code-text","(conj {:raiz \"Batata\"} {:fruta \"Pera\"})"],["br"],["code-text","; {:fruta \"Pera\", :raiz \"Batata\"}"],["br"],["code-text","(merge {:raiz \"Batata\"} {:fruta \"Pera\"})"],["br"],["code-text","; {:fruta \"Pera\", :raiz \"Batata\"}"],["br"]],["paragraph",["br"]],["index",["text","merge"]],["paragraph",["br"]],["paragraph",["text","É mais comum usarmos a função "],["monospaced",["text","merge"]],["text"," do que a função "],["monospaced",["text","conj"]],["text"," para unirmos dois mapas. Internamente a função "],["monospaced",["text","merge"]],["text"," usa "],["monospaced",["text","conj"]],["text",", o que acaba nos dando o mesmo resultado. Isso acontece porque o termo "],["italic",["text","merge"]],["text"," é normalmente usado quando combinamos um conjunto de coisas com outro para formarmos um terceiro conjunto."],["br"]],["paragraph",["text","Se os dois mapas tiverem algum item com a mesma chave, será escolhido o item do mapa da direita."],["br"]],["code","clojure",["br"],["code-text","(assoc {:verdura \"Alface\" :raiz \"Batata\"}"],["br"],["code-text","       :fruta \"Pera\""],["br"],["code-text","       :raiz \"Mandioca\")"],["br"],["code-text","; {:fruta \"Pera\", :verdura \"Alface\", :raiz \"Mandioca\"}"],["br"],["code-text","(conj {:verdura \"Alface\" :raiz \"Batata\"}"],["br"],["code-text","      {:fruta \"Pera\" :raiz \"Mandioca\"})"],["br"],["code-text","; {:fruta \"Pera\", :verdura \"Alface\", :raiz \"Mandioca\"}"],["br"],["code-text","(merge {:verdura \"Alface\" :raiz \"Batata\"}"],["br"],["code-text","       {:fruta \"Pera\" :raiz \"Mandioca\"})"],["br"],["code-text","; {:fruta \"Pera\", :verdura \"Alface\", :raiz \"Mandioca\"}"],["br"]],["paragraph",["br"]],["paragraph",["text","É comum em Clojure termos duas funções que fazem praticamente a mesma coisa. Enquanto isso pode parecer desperdício ou redundância, acaba sendo uma forma de tornar o código mais expressivo e fácil de ler. Vamos ter outro exemplo disso mais adiante, ao estudarmos "],["italic",["text","sets"]],["text","."],["br"]],["index",["text","merge-with"]],["paragraph",["br"]],["paragraph",["text","A função "],["monospaced",["text","merge"]],["text"," tem ainda uma irmã, chamada "],["monospaced",["text","merge-with"]],["text"," que, além do mapa original, recebe também uma função como parâmetro e finalmente os dados a serem combinados ao mapa original."],["br"]],["paragraph",["text","Ao invés de simplesmente substituir o valor atual pelo valor novo, a função "],["monospaced",["text","merge-with"]],["text"," aplica a função para os valores que tiverem a mesma chave."],["br"]],["paragraph",["text","Vamos aplicar os nossos mapas verduras e raizes, concatenando os textos contidos nas chaves repetidas."],["br"]],["code","clojure",["br"],["code-text","(merge-with str"],["br"],["code-text","            {:verdura \"Alface\" :raiz \"Batata\"}"],["br"],["code-text","            {:fruta \"Pera\" :raiz \"Mandioca\"})"],["br"],["code-text","; {:fruta \"Pera\", :verdura \"Alface\", :raiz \"BatataMandioca\"}"],["br"]],["paragraph",["br"]],["paragraph",["text","Acho que "],["italic",["text","BatataMandioca"]],["text"," não fica legal. Podemos então escrever uma função que adicione vírgulas entre as palavras, para deixarmos o resultado mais legível."],["br"]],["code","clojure",["br"],["code-text","(merge-with #(str %1 \", \" %2)"],["br"],["code-text","            {:verdura \"Alface\" :raiz \"Batata\"}"],["br"],["code-text","            {:fruta \"Pera\" :raiz \"Mandioca\"})"],["br"],["code-text","; {:fruta \"Pera\", :verdura \"Alface\", :raiz \"Batata, Mandioca\"}"],["br"]],["paragraph",["br"]],["paragraph",["text","Ficou bem melhor agora, certo?"],["br"]],["paragraph",["text","Podemos também usar "],["monospaced",["text","merge-with"]],["text"," para agregar resultados de inúmeros mapas em um único."],["br"]],["paragraph",["text","Considere que, passada a primeira fase de um campeonato de futebol você tenha a quantidade de gols que cada time marcou. Porém, como cada jogo acontece independente do outro, você terá um mapa para cada jogo, onde o time é a chave, e a quantidade de gols é o valor."],["br"]],["code","clojure",["br"],["code-text","(def jogos [{\"Brasil\"   3 \"Croácia\"  1}"],["br"],["code-text","            {\"México\"   1 \"Camarões\" 0}"],["br"],["code-text","            {\"Brasil\"   0 \"México\"   0}"],["br"],["code-text","            {\"Camarões\" 0 \"Croácia\"  4}"],["br"],["code-text","            {\"Camarões\" 1 \"Brasil\"   4}"],["br"],["code-text","            {\"Croácia\"  1 \"México\"   3}])"],["br"]],["paragraph",["br"]],["paragraph",["text","Como os jogos estão dentro de um vetor, vamos usar a nossa conhecida função "],["monospaced",["text","apply"]],["text"," para transformá-lo em uma lista de parâmetros para "],["monospaced",["text","merge-with"]],["text",". A função "],["monospaced",["text","+"]],["text"," vai somar as quantidades de gols de cada time por jogo e pronto, temos o total de gols de cada um."],["br"]],["code","clojure",["br"],["code-text","(def gols (apply merge-with + jogos))"],["br"],["code-text","gols"],["br"],["code-text","; {\"México\" 4, \"Croácia\" 6, \"Brasil\" 7, \"Camarões\" 1}"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora sabemos que o Brasil marcou sete gols, enquanto Camarões marcou apenas um."],["br"]],["paragraph",["text","Se quisermos remover um item do mapa, usaremos o oposto de "],["monospaced",["text","assoc"]],["text",", que é a função "],["monospaced",["text","dissoc"]],["text",". Enquanto uma "],["italic",["text","associa"]],["text",", a outra "],["italic",["text","dissocia"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(dissoc {:verdura \"Alface\" :raiz \"Batata\" :fruta \"Pera\"} :raiz)"],["br"],["code-text","; {:verdura \"Alface\", :fruta \"Pera\"}"],["br"]],["paragraph",["br"]],["title",["text","Chaves e valores"]],["paragraph",["br"]],["paragraph",["text","Como já foi dito, um mapa é uma coleção que relaciona chaves com seus respectivos valores, sendo um valor para cada chave."],["br"]],["paragraph",["text","Podemos retornar sequencias contendo todas as chaves e também contendo todos os valores."],["br"]],["paragraph",["text","Para extrairmos as chaves, vamos usar a função "],["monospaced",["text","keys"]],["text",", informando o mapa como parâmetro."],["br"]],["paragraph",["text","Vamos extrair a lista de times que participaram do campeonato que citamos, usando a função "],["monospaced",["text","keys"]],["text"," e o nosso mapa "],["monospaced",["text","gols"]],["text",", que contém a quantidade de gols marcados por cada time."],["br"]],["code","clojure",["br"],["code-text","(keys gols)"],["br"],["code-text","; (\"México\" \"Croácia\" \"Brasil\" \"Camarões\")"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos somar a quantidade de gols que tivemos naquela fase do campeonato extraindo os valores do mapa "],["monospaced",["text","gols"]],["text"," através da função "],["monospaced",["text","vals"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(vals gols)"],["br"],["code-text","; (4 6 7 1)"],["br"],["code-text","(apply + (vals gols))"],["br"],["code-text","; 18"],["br"]],["paragraph",["br"]],["paragraph",["text","Finalmente, vamos brincar um pouco com o que aprendemos, calculando a média de gols por partida. Para isso vamos somar a quantidade total de gols marcados e então dividir pela quantidade de jogos."],["br"]],["code","clojure",["br"],["code-text","(def jogos [{\"Brasil\"   3 \"Croácia\"  1}"],["br"],["code-text","            {\"México\"   1 \"Camarões\" 0}"],["br"],["code-text","            {\"Brasil\"   0 \"México\"   0}"],["br"],["code-text","            {\"Camarões\" 0 \"Croácia\"  4}"],["br"],["code-text","            {\"Camarões\" 1 \"Brasil\"   4}"],["br"],["code-text","            {\"Croácia\"  1 \"México\"   3}])"],["br"],["code-text","(def media-de-gols (/ (apply + (vals (apply merge-with + jogos)))"],["br"],["code-text","                      (count jogos)))"],["br"],["code-text","media-de-gols"],["br"],["code-text","; 3"],["br"]],["paragraph",["br"]],["paragraph",["text","E eis que tivemos uma média de três gols por partida."],["br"]],["paragraph",["text","A operação oposta, de criarmos um mapa através de duas coleções, uma de chaves e outra de valores, também é possível se utilizarmos a função "],["monospaced",["text","zipmap"]],["text","."],["br"]],["paragraph",["text","Como exemplo, vamos sortear uma cor para cada participante de um jogo de tabuleiros. Existem quatro cores e cinco amigos para jogar, mas um deles terá que ficar de fora."],["br"]],["code","clojure",["br"],["code-text","(def cores [\"vermelho\" \"branco\" \"azul\" \"verde\"])"],["br"],["code-text","(def amigos [\"João\" \"José\" \"Júlia\" \"Jurandir\", \"Jailson\"])"],["br"]],["paragraph",["br"]],["index",["text","shuffle"]],["paragraph",["br"]],["paragraph",["text","Vamos usar a função "],["monospaced",["text","shuffle"]],["text"," para embaralhar as listas de cores e de amigos, fazendo com que o sorteio seja realmente imprevisível."],["br"]],["code","clojure",["br"],["code-text","cores"],["br"],["code-text","; [\"vermelho\" \"branco\" \"azul\" \"verde\"]"],["br"],["code-text","(shuffle cores)"],["br"],["code-text","; [\"verde\" \"branco\" \"vermelho\" \"azul\"]"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos usar "],["monospaced",["text","zipmap"]],["text"," para associarmos cada cor a um jogador. Como são quatro cores para cinco amigos, o último vai ficar só assistindo."],["br"]],["code","clojure",["br"],["code-text","(zipmap (shuffle cores)"],["br"],["code-text","        (shuffle amigos))"],["br"],["code-text","; {\"verde\" \"Júlia\", \"azul\" \"Jurandir\", \"branco\" \"João\","],["br"],["code-text",";  \"vermelho\" \"Jailson\"}"],["br"]],["paragraph",["br"]],["paragraph",["text","E José vai esperar a próxima rodada para poder jogar."],["br"]],["section",["text","Sets"]],["paragraph",["br"]],["paragraph",["text","Um "],["italic",["text","set"]],["text"," é uma coleção de valores únicos. Podemos visualizar melhor o que é um "],["italic",["text","set"]],["text"," se lembrarmos das aulas de teorias dos conjuntos. Cada "],["italic",["text","set"]],["text"," seria um conjunto, e temos à nossa disposição boa parte das operações matemáticas que usamos com conjuntos."],["br"]],["paragraph",["text","Como este não é um livro de matemática ou de teoria dos conjuntos, não vamos cobrir todas essas operações, mas usaremos o assunto como analogia sempre que necessário."],["br"]],["index",["text","set"]],["paragraph",["br"]],["paragraph",["text","Podemos criar um "],["italic",["text","set"]],["text"," usando a função "],["monospaced",["text","set"]],["text",", passando uma sequencia ou um vetor como argumento, ou delimitando os itens entre os caracteres "],["monospaced",["text","#{ }"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(set \"aeiou\")"],["br"],["code-text","; #{\\a \\e \\i \\o \\u}"],["br"],["code-text","(set [\\a \\e \\i \\o \\u])"],["br"],["code-text","; #{\\a \\e \\i \\o \\u}"],["br"],["code-text","#{\\a \\e \\i \\o \\u}"],["br"],["code-text","; #{\\a \\e \\i \\o \\u}"],["br"]],["paragraph",["br"]],["paragraph",["text","Um "],["italic",["text","set"]],["text"," é usado normalmente para verificar se um determinado item pertence a um conjunto. Aproveitando os exemplos acima, podemos usar a nossa já conhecida técnica de verificar se um caracter é uma vogal."],["br"]],["index",["text","contains?"]],["paragraph",["br"]],["paragraph",["text","Podemos fazer isso usando a função "],["monospaced",["text","contains?"]],["text",", que vai retornar "],["monospaced",["text","true"]],["text"," ou "],["monospaced",["text","false"]],["text",", ou usando um "],["italic",["text","set"]],["text"," como se fosse uma função, que vai retornar o próprio valor pesquisado caso ele pertença ao conjunto ou "],["monospaced",["text","nil"]],["text"," caso ele não pertença."],["br"]],["code","clojure",["br"],["code-text","(def vogal? (set \"aeiouAEIOU\"))"],["br"],["code-text","(contains? vogal? \\a)"],["br"],["code-text","; true"],["br"],["code-text","(contains? vogal? \\b)"],["br"],["code-text","; false"],["br"],["code-text","(vogal? \\a)"],["br"],["code-text","; \\a"],["br"],["code-text","(vogal? \\b)"],["br"],["code-text","; nil"],["br"]],["paragraph",["br"]],["index",["text","conj"]],["index",["text","disj"]],["paragraph",["br"]],["paragraph",["text","As funções "],["monospaced",["text","conj"]],["text"," e "],["monospaced",["text","disj"]],["text"," também funcionam com "],["italic",["text","sets"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(conj (set \"aeiouAEIOU\") \\á)"],["br"],["code-text","; #{\\A \\a \\á \\E \\e \\I \\i \\O \\o \\U \\u}"],["br"],["code-text","(disj (set \"aeiouAEIOU\") \\a \\A)"],["br"],["code-text","; #{\\E \\e \\I \\i \\O \\o \\U \\u}"],["br"]],["paragraph",["br"]],["index",["text","hash-set"]],["index",["text","sorted-set"]],["paragraph",["br"]],["paragraph",["text","Para criarmos um "],["italic",["text","set"]],["text"," a partir de uma lista de argumentos, podemos usar as funções "],["monospaced",["text","hash-set"]],["text"," e "],["monospaced",["text","sorted-set"]],["text","."],["br"]],["paragraph",["text","Da mesma maneira que acontece com os mapas, um "],["italic",["text","hash-set"]],["text"," não garante a ordem dos elementos, mas é otimizado para encontrar rapidamente qualquer elemento."],["br"]],["code","clojure",["br"],["code-text","(hash-set :c :a :v :a :l :o)"],["br"],["code-text","; #{:v :o :l :c :a}"],["br"],["code-text","(sorted-set :c :a :v :a :l :o)"],["br"],["code-text","; #{:a :c :l :o :v}"],["br"]],["paragraph",["br"]],["paragraph",["text","Também como já vimos com os mapas, é possível criar uma função para ordenar o "],["italic",["text","set"]],["text"," de acordo com as nossas necessidades."],["br"]],["paragraph",["text","Vamos criar uma função chamada "],["monospaced",["text","inverso"]],["text"," para podemos ordenar o "],["italic",["text","set"]],["text"," em ordem descrescente e depois criar um "],["italic",["text","set"]],["text"," ordenado através da função "],["monospaced",["text","sorted-set"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn inverso [a b]"],["br"],["code-text","  (* -1 (compare a b)))"],["br"],["code-text","(sorted-set :c :l :o :j :u :r :e)"],["br"],["code-text","; #{:c :e :j :l :o :r :u}"],["br"],["code-text","(sorted-set-by inverso :c :l :o :j :u :r :e)"],["br"],["code-text","; #{:u :r :o :l :j :e :c}"],["br"]],["paragraph",["br"]],["title",["text","Um pouco de teoria dos conjuntos"]],["paragraph",["br"]],["paragraph",["text","Existe um "],["italic",["text","namespace"]],["text"," apenas para lidar com "],["italic",["text","sets"]],["text",". Com ele temos acesso a funções Clojure que reproduzem algumas operações da Teoria dos Conjuntos."],["br"]],["paragraph",["text","Vamos criar dois conjuntos e vamos chamá-los de "],["monospaced",["text","A"]],["text"," e "],["monospaced",["text","B"]],["text",". Através de "],["italic",["text","diagramas de Venn"]],["ref",["text","venn-paper"]],["text"," podemos exibir graficamente os conjuntos e suas respectivas interações."],["br"]],["paragraph",["text","Vamos declarar nossos conjuntos, conforme a figura "],["ref-label",["text","cap05-venn-a-b"]],["text",", usando "],["italic",["text","sets"]],["text"," para fazermos o paralelo com código Clojure."],["br"]],["img",["text","images/capitulo_05/diagram_venn_a_b.png \"Conjuntos A e B\" label=cap05-venn-a-b w=60%"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(def a #{:a :b :c :d})"],["br"],["code-text","(def b #{:c :d :e :f})"],["br"]],["paragraph",["br"]],["index",["text","clojure.set/union"]],["paragraph",["br"]],["paragraph",["text","A união de dois grupos acontece quando juntamos todos os elementos de "],["monospaced",["text","A"]],["text"," com todos os elementos de "],["monospaced",["text","B"]],["text",", mantendo apenas uma ocorrência do elemento caso haja repetição, como ocorre na figura "],["ref-label",["text","cap05-venn-a-U-b"]],["text",". Para isso podemos usar a função "],["monospaced",["text","union"]],["text","."],["br"]],["img",["text","images/capitulo_05/diagram_venn_a_U_b.png \"União de A com B\" label=cap05-venn-a-U-b w=50%"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(clojure.set/union a b)"],["br"],["code-text","; #{:e :c :b :d :f :a}"],["br"]],["paragraph",["br"]],["index",["text","clojure.set/intersection"]],["paragraph",["br"]],["paragraph",["text","Já na intersecção só mantemos os elementos em comum entre os conjuntos "],["monospaced",["text","A"]],["text"," e "],["monospaced",["text","B"]],["text",", como podemos ver na figura "],["ref-label",["text","cap05-venn-a-V-b"]],["text",". A função "],["monospaced",["text","intersection"]],["text"," faz esse trabalho."],["br"]],["img",["text","images/capitulo_05/diagram_venn_a_V_b.png \"Intersecção de A com B\" label=cap05-venn-a-V-b w=50%"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(clojure.set/intersection a b)"],["br"],["code-text","; #{:c :d}"],["br"]],["paragraph",["br"]],["index",["text","clojure.set/difference"]],["paragraph",["br"]],["paragraph",["text","Já na diferença entre "],["monospaced",["text","A"]],["text"," e "],["monospaced",["text","B"]],["text"," você remove todos os itens de "],["monospaced",["text","A"]],["text"," que pertençam a "],["monospaced",["text","B"]],["text",", como podemos ver na figura "],["ref-label",["text","cap05-venn-a-diff-b"]],["text",". Para isso usamos a função "],["monospaced",["text","difference"]],["text","."],["br"]],["img",["text","images/capitulo_05/diagram_venn_a_-_b.png \"Diferença de A com B\" label=cap05-venn-a-diff-b w=50%"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(clojure.set/difference a b)"],["br"],["code-text","; #{:b :a}"],["br"]],["paragraph",["br"]],["paragraph",["text","É importante perceber que a função "],["monospaced",["text","difference"]],["text"," não é comutativa. Isso significa que a diferença entre "],["monospaced",["text","A"]],["text"," e "],["monospaced",["text","B"]],["text"," é diferente da diferença entre "],["monospaced",["text","B"]],["text"," e "],["monospaced",["text","A"]],["text",", como podemos ver na figura "],["ref-label",["text","cap05-venn-b-diff-a"]],["text","."],["br"]],["img",["text","images/capitulo_05/diagram_venn_b_-_a.png \"Diferença de B com A\" label=cap05-venn-b-diff-a w=50%"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(clojure.set/difference b a)"],["br"],["code-text","; #{:e :f}"],["br"]],["paragraph",["br"]],["paragraph",["text","É possível também utilizar as operações de "],["italic",["text","está contido em"]],["text"," e "],["italic",["text","contém"]],["text",", além de saber se um elemento pertence ou não ao "],["italic",["text","set"]],["text",". A diferença entre estar contido e pertencer, é que "],["italic",["text","um elemento "],["bold",["text","pertence a"]],["text"," um conjunto"]],["text",", enquanto "],["italic",["text","um conjunto "],["bold",["text","está contido em"]],["text"," outro conjunto"]],["text","."],["br"]],["index",["text","clojure.set/subset?"]],["paragraph",["br"]],["paragraph",["text","Para saber se um elemento pertence a um grupo, usamos a função "],["monospaced",["text","contains?"]],["text",", como já vimos no início da explicação sobre "],["italic",["text","sets"]],["text",". Já para ver se um conjunto está contido em outro, usamos a função "],["monospaced",["text","subset?"]],["text","."],["br"]],["paragraph",["text","Olhando a figura "],["ref-label",["text","cap05-venn-a-diff-b"]],["text",", podemos perceber que "],["italic",["monospaced",["text","A - B"]],["text"," está contido em "],["monospaced",["text","A"]]],["text","."],["br"]],["paragraph",["text","Podemos representar isso usando Clojure da seguinte forma:"],["br"]],["code","clojure",["br"],["code-text","(clojure.set/subset? (clojure.set/difference a b) a)"],["br"],["code-text","; true"],["br"]],["paragraph",["br"]],["paragraph",["text","Pela mesma figura podemos ver que "],["italic",["monospaced",["text","A - B"]],["text"," não está contido em B"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(clojure.set/subset? (clojure.set/difference a b) b)"],["br"],["code-text","; false"],["br"]],["paragraph",["br"]],["index",["text","clojure.set/superset?"]],["paragraph",["br"]],["paragraph",["text","Já a função "],["monospaced",["text","superset?"]],["text"," faz o oposto, verificando se "],["italic",["text","um grupo contém outro grupo"]],["text","."],["br"]],["paragraph",["text","Sabendo que "],["italic",["monospaced",["text","A - B"]],["text"," está contido em "],["monospaced",["text","A"]]],["text",", podemos afirmar que "],["italic",["monospaced",["text","A"]],["text"," contém "],["monospaced",["text","A - B"]]],["text",", e podemos afirmar também que "],["monospaced",["text","B"]],["text"," não o contém."],["br"]],["code","clojure",["br"],["code-text","(clojure.set/superset? a (clojure.set/difference a b))"],["br"],["code-text","; true"],["br"],["code-text","(clojure.set/superset? b (clojure.set/difference a b))"],["br"],["code-text","; false"],["br"]],["paragraph",["br"]],["section",["text","Estruturas transientes"]],["paragraph",["br"]],["paragraph",["text","As estruturas persistentes são excelentes para lidarmos com ambientes com várias threads e para manter a consistência das informações mas, em casos em que a velocidade é importante, podemos fazer uma concessão e utilizar estruturas mutáveis para tornar o processamento mais rápido."],["br"]],["paragraph",["text","É aí que entram as "],["italic",["text","estruturas transientes"]],["text",", que permite que você modifique valores dentro da própria estrutura, sem a necessidade de criar uma nova para cada modificação."],["br"]],["paragraph",["text","Para manter as coisas organizadas, uma estrutura transiente é obrigada a trabalhar em uma única thread, evitando todos os problemas relacionados a mutabilidade e "],["italic",["text","multithreading"]],["text"," que temos de sobra no Java e nas demais linguagens imperativas."],["br"]],["index",["text","transient"]],["paragraph",["br"]],["index",["text","persistent!"]],["paragraph",["br"]],["paragraph",["text","O uso é bem simples. Primeiro pegamos uma estrutura persistente qualquer e a convertemos em transiente através da função "],["monospaced",["text","transient"]],["text",", manipulamos da maneira que bem entendermos e criamos uma estrutura persistente através da função "],["monospaced",["text","persistent!"]],["text",". Perceba o ponto de exclamação no final do nome da função. Isso indica que a função ou macro causa algum tipo de efeito colateral e deve ser usada com atenção."],["br"]],["paragraph",["text","Vamos apresentar um exemplo bem simples criando uma função que recebe um número e retorna um vetor contendo todos os valores inteiros entre "],["italic",["text","1"]],["text"," e o número informado."],["br"]],["paragraph",["text","Usando o que já sabemos sobre "],["monospaced",["text","loop"]],["text"," e "],["monospaced",["text","recur"]],["text",", vamos escrever a função desta maneira:"],["br"]],["code","clojure",["br"],["code-text","(defn numeros [tamanho]             ; 1"],["br"],["code-text","  (loop [lista []                   ; 2"],["br"],["code-text","         contador 1]                ; 3"],["br"],["code-text","    (if (> contador tamanho)        ; 4"],["br"],["code-text","      lista                         ; 5"],["br"],["code-text","      (recur (conj lista contador)  ; 6"],["br"],["code-text","             (inc contador)))))     ; 7"],["br"]],["paragraph",["br"]],["paragraph",["text","Os números de linha foram adicionados para facilitar a explicação e para entendermos melhor onde o código vai precisar ser alterado."],["br"]],["paragraph",["text","Criamos um vetor vazio chamado "],["monospaced",["text","lista"]],["text",", e um contador que vai de "],["italic",["text","1"]],["text"," até "],["monospaced",["text","tamanho"]],["text",". No meio do laço, verificamos se "],["monospaced",["text","contador"]],["text"," é maior que "],["monospaced",["text","tamanho"]],["text",", retornando "],["monospaced",["text","lista"]],["text"," com os números ou então adicionando o valor seguinte a um novo vetor, repetindo a operação."],["br"]],["paragraph",["text","Vamos agora usar a função "],["monospaced",["text","time"]],["text",". Vamos roubar um pouco no resultado e usar a forma "],["monospaced",["text","do"]],["text"," para que o "],["italic",["text","REPL"]],["text"," não exiba os milhões de números contidos na lista."],["br"]],["paragraph",["text","A forma "],["monospaced",["text","do"]],["text"," permite que executemos uma série de instruções, retornando o resultado da última. Vamos retornar "],["monospaced",["text","nil"]],["text"," como última expressão e assim resumimos em muito o que vai ser apresentado na tela."],["br"]],["code","clojure",["br"],["code-text","(do (time (numeros 10000000))"],["br"],["code-text","    nil)"],["br"],["code-text","\"Elapsed time: 8645.947068 msecs\""],["br"]],["paragraph",["br"]],["paragraph",["text","Na máquina que estou usando enquanto escrevo o livro o processo levou quase nove segundos."],["br"]],["paragraph",["text","Vamos ver agora o que podemos melhorar usando uma estrutura transiente."],["br"]],["code","clojure",["br"],["code-text","(defn numeros-2 [tamanho]           ; 1"],["br"],["code-text","  (loop [lista (transient [])       ; 2"],["br"],["code-text","         contador 1]                ; 3"],["br"],["code-text","    (if (> contador tamanho)        ; 4"],["br"],["code-text","      (persistent! lista)           ; 5"],["br"],["code-text","      (recur (conj! lista contador) ; 6"],["br"],["code-text","             (inc contador)))))     ; 7"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos alterar um pouco o código para poder usar uma estrutura transiente. Perceba que a aparência do código é a mesma, não perdendo a clareza."],["br"]],["index",["text","conj!"]],["paragraph",["br"]],["paragraph",["text","Na linha 2 nós vamos atribuir um vetor vazio transiente para "],["monospaced",["text","lista"]],["text",", ao invés de um vetor persistente do código original. Na linha 6 nós vamos utilizar a função "],["monospaced",["text","conj!"]],["text",", que altera o próprio vetor ao invés de retornar um novo. Isso só é possível com estruturas transientes, que não são imutáveis."],["br"]],["paragraph",["text","Finalmente, para retornarmos o vetor, utilizamos a função "],["monospaced",["text","persistent!"]],["text",", que cria uma estrutura persistente com o conteúdo de "],["monospaced",["text","lista"]],["text","."],["br"]],["paragraph",["text","Vamos executar agora o código usando "],["monospaced",["text","time"]],["text",", para medirmos o tempo gasto para retornar o vetor com os números. Note que externamente a função parece igual mas, usando mutabilidade de maneira controlada, tivemos um grande ganho de desempenho."],["br"]],["code","clojure",["br"],["code-text","(do (time (numeros-2 10000000))"],["br"],["code-text","    nil)"],["br"],["code-text","\"Elapsed time: 727.179826 msecs\""],["br"]],["paragraph",["br"]],["paragraph",["text","Agora tivemos o mesmo resultado em menos de um décimo do tempo."],["br"]],["title",["text","Transiente e multithread"]],["paragraph",["br"]],["paragraph",["text","Existem duas formas de evitar que informações sejam corrompidos ou alterados indevidamente em um ambiente com que várias "],["italic",["text","threads"]],["text","."],["br"]],["paragraph",["text","A primeira forma é fazer com que a informação não possa ser alterada, e isso o Clojure já faz por padrão."],["br"]],["paragraph",["text","A segunda forma é permitir que a informação seja alterada, como acontece com as estruturas transientes, mas impedir que mais de uma "],["italic",["text","thread"]],["text"," possa modificá-la. E os criadores do Clojure tiveram o cuidado de fazer as duas coisas."],["br"]],["paragraph",["text","Vamos criar uma função chamada "],["monospaced",["text","thread-atual"]],["text",", que simplesmente retorna o nome da "],["italic",["text","thread"]],["text"," atual."],["br"]],["code","clojure",["br"],["code-text","(defn thread-atual []"],["br"],["code-text","  (.getName (Thread/currentThread)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Essa função executa o método estático "],["monospaced",["text","currentThread"]],["text"," da classe "],["monospaced",["text","Thread"]],["text",", que retorna um objeto. Então pegamos esse objeto e acessamos o método "],["monospaced",["text","getName"]],["text",". Veremos nos próximos capítulos como acessar objetos Java dentro do Clojure em detalhes, mas por enquanto é suficiente saber que o código acima faz o mesmo que "],["monospaced",["text","Thread.currentThread().getName()"]],["text"," em Java."],["br"]],["paragraph",["text","Vamos criar um vetor transiente chamado "],["monospaced",["text","trans"]],["text"," e adicionar o nome da "],["italic",["text","thread"]],["text"," atual texto, para sabermos onde foi feita a alteração;"],["br"]],["code","clojure",["br"],["code-text","(def trans (transient []))"],["br"],["code-text","(conj! trans thread-atual)"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos criar uma função chamada "],["monospaced",["text","altera-trans!"]],["text",", que vai modificar "],["monospaced",["text","trans"]],["text"," adicionando ao vetor o nome da "],["italic",["text","thread"]],["text"," atual. Perceba o ponto de exclamação no nome da função, para deixarmos claro de que causaremos um efeito colateral em sua execução."],["br"]],["code","clojure",["br"],["code-text","(defn altera-trans! []"],["br"],["code-text","  (conj! trans (thread-atual)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos executar a função "],["monospaced",["text","altera-trans!"]],["text"," para ver se tudo corre bem."],["br"]],["code","clojure",["br"],["code-text","(altera-trans!)"],["br"],["code-text","; #<TransientVector"],["br"],["code-text","; clojure.lang.PersistentVector$TransientVector@211132ec>"],["br"],["code-text","(println (.nth trans 0))"],["br"],["code-text","; nREPL-worker-7"],["br"],["code-text","(thread-atual)"],["br"],["code-text","; \"nREPL-worker-7\""],["br"]],["paragraph",["br"]],["paragraph",["text","Aqui usamos um pouco de magia negra para termos certeza do que aconteceu. Como uma estrutura transiente não oferece meios limpos de lermos o seu conteúdo, utilizamos o método "],["monospaced",["text","nth"]],["text"," que está dentro da classe "],["monospaced",["text","TransientVector"]],["text",", tratanto a estrutura como um objeto Java. É feio, mas serve ao nosso propósito educativo."],["br"]],["paragraph",["text","Podemos ver que tanto a primeira posição quanto a "],["italic",["text","thread"]],["text"," atual retornam o texto "],["italic",["text","nREPL-worker-7"]],["text",". O nome pode variar de acordo com o momento em que você estiver utilizando o "],["italic",["text","REPL"]],["text"," ou a quantidade de sessões do "],["italic",["text","nREPL"]],["text"," que você já abriu."],["br"]],["paragraph",["text","Agora sabemos que nossa função "],["monospaced",["text","altera-trans!"]],["text"," funciona, vamos à parte realmente interessante, que é ver como o Clojure se comporta ao tentarmos misturar mutabilidade e diferentes "],["italic",["text","threads"]],["text","."],["br"]],["paragraph",["text","Você ainda não sabia, mas toda função Clojure pode ser passada para uma "],["italic",["text","thread"]],["text"," para que possa ser executada em paralelo. Relaxe, pois veremos isso em detalhes em um capítulo específico. O que você precisa saber agora é que pode jogar uma função numa "],["italic",["text","thread"]],["text"," e fica tudo bem."],["br"]],["paragraph",["text","Vamos criar uma "],["italic",["text","thread"]],["text"," usando novamente a classe Java, e então invocaremos o método "],["monospaced",["text","start"]],["text"," do objeto que tivermos em mãos. Nosso código vai ficar com essa cara:"],["br"]],["code","clojure",["br"],["code-text","(.start (Thread. altera-trans!))"],["br"]],["paragraph",["br"]],["paragraph",["text","Esse código Clojure é equivalente ao código Java abaixo:"],["br"]],["code","java",["br"],["code-text","(new Thread(new Runnable() {"],["br"],["code-text","  @Override"],["br"],["code-text","  public void run() {"],["br"],["code-text","    user$altera_trans_BANG_.invoke();"],["br"],["code-text","  }"],["br"],["code-text","})).start()"],["br"]],["paragraph",["br"]],["paragraph",["text","Em Clojure fica bem mais bonito, não?"],["br"]],["paragraph",["text","Voltando ao nosso código, ao tentarmos executar "],["monospaced",["text","altera-trans!"]],["text"," dentro de outra "],["italic",["text","thread"]],["text",", o Clojure vai puxar nossa orelha."],["br"]],["code","clojure",["br"],["code-text","(.start (Thread. altera-trans!))"],["br"],["code-text","; Exception in thread \"Thread-76\" java.lang.IllegalAccessError:"],["br"],["code-text",";  Transient used by non-owner thread"],["br"],["code-text",";   ... um monte de chamadas ..."],["br"],["code-text",";   at clojure.core$conj_BANG_.invoke(core.clj:3077)"],["br"],["code-text",";   at user$altera_trans_BANG_.invoke(NO_SOURCE_FILE:2)"],["br"],["code-text",";   at clojure.lang.AFn.run(AFn.java:22)"],["br"],["code-text",";   at java.lang.Thread.run(Unknown Source)"],["br"]],["paragraph",["br"]],["paragraph",["text","Mesmo que você tente fazer algo errado, o Clojure toma os cuidados possíveis para que as coisas continuem na linha."],["br"]],["box",["text","Chega de threads e de Java por enquanto"],["paragraph",["br"]],["paragraph",["text","No capítulo "],["ref-label",["text","capitulo-concorrencia"]],["text",", veremos tudo o que você sempre quis saber sobre concorrência, "],["italic",["text","multithread"]],["text"," e estruturas imutáveis mas tinha vergonha de perguntar, inclusive reescrevendo o código que fizemos agora do jeito certo."],["br"]],["paragraph",["text","Já no capítulo "],["ref-label",["text","capitulo-integracao-java"]],["text"," veremos em detalhes como integrar aquele código Java que funciona muito bem há anos (ou talvez não tão bem) na sua aplicação Clojure cheirando a nova e com plástico no banco."],["br"]]],["paragraph",["br"]],["section",["text","Metadados"]],["paragraph",["br"]],["index",["text","clojure.lang.IMeta"]],["paragraph",["br"]],["paragraph",["italic",["text","Metadata"]],["text",", ou metadados são "],["italic",["text","dados a respeitos de dados"]],["text",". Clojure permite que você adicione informações adicionais a "],["italic",["text","vars"]],["text",", símbolos, coleções, "],["italic",["text","namespaces"]],["text",", "],["italic",["text","atoms"]],["text",", "],["italic",["text","refs"]],["text",", "],["italic",["text","agents"]],["text"," ou qualquer classe Java que implemente a interface "],["monospaced",["text","IMeta"]],["text",". Numa comparação bem rasa, uma anotação do Java ou do C# é uma forma de de utilizarmos metadados, visto que a classe, método ou membro anotado passa a levar uma informação que não afeta diretamente o uso daquele código."],["br"]],["paragraph",["text","Esses metadados são utilizados pelo compilador, por ferramentas que analizam o código ou por funções e macros que auxiliam a utilização do "],["italic",["text","REPL"]],["text",", como as nossas conhecidas "],["monospaced",["text","doc"]],["text"," e "],["monospaced",["text","source"]],["text","."],["br"]],["index",["text","with-meta"]],["paragraph",["br"]],["paragraph",["text","Podemos adicionar metadados a uma lista usando a função "],["monospaced",["text","with-meta"]],["text",", que recebe como parâmetros o valor e um mapa contendo os metadados:"],["br"]],["code","clojure",["br"],["code-text","(def numeros (with-meta '(1 2 3 4 5 6)"],["br"],["code-text","                        {:descricao \"Numeros de um a seis\"}))"],["br"]],["paragraph",["br"]],["paragraph",["text","Para acessarmos os metadados que acabamos de adicionar a "],["monospaced",["text","numeros"]],["text",", usamos a função "],["monospaced",["text","meta"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(meta numeros)"],["br"],["code-text","; {:descricao \"Numeros de um a seis\"}"],["br"]],["paragraph",["br"]],["paragraph",["text","Os metadados ficam guardados em um mapa, e podemos acessá-los como um mapa qualquer. Vamos exibir apenas a descrição:"],["br"]],["code","clojure",["br"],["code-text","(:descricao (meta numeros))"],["br"],["code-text","; \"Numeros de um a seis\""],["br"]],["paragraph",["br"]],["paragraph",["text","Agora sabemos que podemos adicionar qualquer informação que acharmos relevante a uma lista ou qualquer outra coleção do Clojure, e já sabíamos que a macro "],["monospaced",["text","doc"]],["text"," busca o texto explicativo das funções em seus respectivos metadados."],["br"]],["paragraph",["text","Vamos experimentar extrair por conta própria a documentação da função "],["monospaced",["text","filter"]],["text",". Escolhemos essa função aleatóriamente. Você pode tentar com qualquer outra que pertença à biblioteca padrão do Clojure."],["br"]],["paragraph",["text","Primeiro vamos exibir a documentação, para termos uma noção do que esperamos encontrar. Em seguida vamos acessar os metadados usando a função "],["monospaced",["text","meta"]],["text"," para começarmos a vasculhar as informações que queremos."],["br"]],["code","clojure",["br"],["code-text","(doc filter)"],["br"],["code-text","; clojure.core/filter"],["br"],["code-text","; ([pred coll])"],["br"],["code-text",";   Returns a lazy sequence of the items in coll for which"],["br"],["code-text",";   (pred item) returns true. pred must be free of side-effects."],["br"],["code-text","(meta filter)"],["br"],["code-text","; nil"],["br"]],["paragraph",["br"]],["paragraph",["text","Enquanto "],["monospaced",["text","doc"]],["text"," retornou um texto explicativo, a função "],["monospaced",["text","meta"]],["text"," retornou apenas "],["monospaced",["text","nil"]],["text",". O que fizemos de errado?"],["br"]],["paragraph",["text","Vamos olhar como a função foi declarada para entendermos exatamente o que acontece. Vou adicionar novamente números de linhas para poder explicar todo o processo."],["br"]],["code","clojure",["br"],["code-text","(defn filter                                ;  1"],["br"],["code-text","  \"Returns a lazy sequence of               ;  2"],["br"],["code-text","  the items in coll for which"],["br"],["code-text","  (pred item) returns true.                 ;  3"],["br"],["code-text","  pred must be free of side-effects.\""],["br"],["code-text","  {:added \"1.0\"                             ;  4"],["br"],["code-text","   :static true}                            ;  5"],["br"],["code-text","  ([pred coll]                              ;  6"],["br"],["code-text","    ;; código fonte da função               ;  7..19"],["br"],["code-text","    ))                                      ; 20"],["br"]],["paragraph",["br"]],["paragraph",["text","As linhas "],["italic",["text","2"]],["text"," e "],["italic",["text","3"]],["text"," foram quebradas para poderem caber na página do livro, mas isso não vai afetar a explicação. O código fonte, que fica entre as linhas "],["italic",["text","7"]],["text"," e "],["italic",["text","19"]],["text",", foi removido para mantermos o foco no que é importante para explicação."],["br"]],["paragraph",["text","Podemos ver que entre as linhas "],["italic",["text","2"]],["text"," e "],["italic",["text","5"]],["text"," estão sendo declarados o texto da documentação e mais duas informações em forma de mapa. Internamente isso vai ser adicionado aos metadados da função "],["monospaced",["text","filter"]],["text",", também usando a função "],["monospaced",["text","with-meta"]],["text","."],["br"]],["paragraph",["text","Mas, se internamente o Clojure também usa "],["monospaced",["text","with-meta"]],["text",", como fizemos no exemplo, por que ao usarmos "],["monospaced",["text","meta"]],["text"," não encontramos nada?"],["br"]],["paragraph",["text","Primeiro precisamos entender como a linguagem trabalha com o código por baixo dos panos."],["br"]],["paragraph",["text","Em Clojure, como na maioria das linguagens, temos dois momentos distintos na execução de um programa: um chamado "],["italic",["text","tempo de compilação"]],["text"," e outro chamado "],["italic",["text","tempo de execução"]],["text","."],["br"]],["paragraph",["text","No chamado "],["italic",["text","tempo de compilação"]],["text",", o código Clojure é lido, interpretado e as macros são expandidas. Veremos esse passo com detalhes num capítulo todinho sobre macros."],["br"]],["paragraph",["text","Nesse período de "],["italic",["text","compilação"]],["text"," os "],["italic",["text","vars"]],["text"," declarados pelo operador "],["monospaced",["text","def"]],["text"," são criados e o código que está dentro das macros é executado."],["br"]],["paragraph",["text","Em seguida, em "],["italic",["text","tempo de execução"]],["text",", o conteúdo das funções e expressões que serão atribuídas aos "],["italic",["text","vars"]],["text"," serão executados."],["br"]],["paragraph",["text","Para fixar melhor como funciona, pense que em "],["italic",["text","tempo de compilação"]],["text"," é criada a panela, em "],["italic",["text","tempo de execução"]],["text"," é feita a comida. Escrever com fome causa essas coisas."],["br"]],["paragraph",["text","Quando executamos "],["monospaced",["text","with-meta"]],["text"," no "],["italic",["text","REPL"]],["text",", estamos criando metadados em tempo de execução, já que estamos avaliando uma expressão. Com isso associamos o metadado à lista que foi criada. Se você passar essa lista como parâmetro para alguma função, o metadado vai junto."],["br"]],["paragraph",["text","Para demonstrar isso, vamos criar uma função chamada "],["monospaced",["text","extrair-descricao"]],["text"," que vai procurar dentro dos metadados do valor a chave "],["monospaced",["text","descricao"]],["text"," que adicionamos no exemplo anterior."],["br"]],["code","clojure",["br"],["code-text","(defn extrair-descricao [valor]"],["br"],["code-text","  (:descricao (meta valor)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Como relembrar é viver, e ficar voltando página no livro é muito chato, vamos criar novamente a lista com a respectiva descrição."],["br"]],["code","clojure",["br"],["code-text","(def numeros (with-meta '(1 2 3 4 5 6)"],["br"],["code-text","                        {:descricao \"Numeros de um a seis\"}))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos juntar as partes."],["br"]],["code","clojure",["br"],["code-text","(extrair-descricao numeros)"],["br"],["code-text","; \"Numeros de um a seis\""],["br"]],["paragraph",["br"]],["paragraph",["text","Nesse caso, "],["bold",["text","o metadado foi associado ao valor"]],["text",". Como o valor foi passado por parâmetro, o metadado foi junto."],["br"]],["paragraph",["text","Quando atribuimos o metadado em "],["italic",["text","tempo de compilação"]],["text",", o valor ainda não foi criado. Fica óbvio se você pensar que o valor só existirá quando a aplicação estiver sendo executada, ou seja, em "],["italic",["text","tempo de execução"]],["text","."],["br"]],["paragraph",["text","Como o valor ainda não foi criado, o metadado é atribuido ao "],["italic",["text","var"]],["text"," que vai armazená-lo. Lembre-se que o "],["italic",["text","var"]],["text"," é criado em tempo de compilação."],["br"]],["paragraph",["text","Quando tentamos acessar os metadados de "],["monospaced",["text","filter"]],["text",", estamos acessando o valor contido no "],["italic",["text","var"]],["text"," "],["monospaced",["text","filter"]],["text",", que é uma função. Esse valor, de fato, não tem metadado nenhum, e é onde recebemos "],["monospaced",["text","nil"]],["text"," como resposta."],["br"]],["index",["text","var"]],["paragraph",["br"]],["paragraph",["text","Se quisermos acessar diretamente o "],["italic",["text","var"]],["text"," "],["monospaced",["text","filter"]],["text",", ao invés de acessarmos a função, precisamos utilizar a forma especial "],["monospaced",["text","var"]],["text",", que funciona de forma bem parecida com a função "],["monospaced",["text","symbol"]],["text"," que já conhecemos."],["br"]],["code","clojure",["br"],["code-text","(var filter)"],["br"],["code-text","; #'clojure.core/filter"],["br"]],["paragraph",["br"]],["paragraph",["text","A forma "],["monospaced",["text","var"]],["text"," nos retornou o nome completo da função "],["monospaced",["text","filter"]],["text",", incluindo o "],["italic",["text","namespace"]],["text"," em que a função foi declarada."],["br"]],["index",["text","#'"]],["paragraph",["br"]],["paragraph",["text","Perceba que o retorno contém também os caracteres "],["monospaced",["text","#'"]],["text"," antes do nome completo da função. Esses dois caracteres são "],["italic",["text","reader macros"]],["text",", ou atalhos da linguagem que são executados em tempo de compilação. Internamente a "],["italic",["text","reader macros"]],["text"," "],["monospaced",["text","#'"]],["text"," vai ser substituido por "],["monospaced",["text","var"]],["text"," e executado durante a compilação do código."],["br"]],["box",["text","Readers macros"],["paragraph",["br"]],["paragraph",["italic",["text","Reader macro"]],["text"," é uma sequencia de caracteres que informa ao "],["italic",["text","reader"]],["text"," do Clojure, aquele responsável pelo R do "],["italic",["text","REPL"]],["text",", que ele deve executar uma instrução previamente determinada antes do tempo de compilação. Por conta disso as "],["italic",["text","reader macros"]],["text"," são executadas ainda antes das macros comuns."],["br"]],["paragraph",["text","Veremos "],["italic",["text","reader macros"]],["text"," em detalhes no capítulo sobre macros."],["br"]]],["paragraph",["br"]],["code","clojure",["br"],["code-text","#'filter"],["br"],["code-text","; #'clojure.core/filter"],["br"],["code-text","(var filter)"],["br"],["code-text","; #'clojure.core/filter"],["br"]],["paragraph",["br"]],["paragraph",["text","Usando a nossa recém apresentada forma "],["monospaced",["text","var"]],["text",", vamos tentar acessar novamente os metadados de "],["monospaced",["text","filter"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(meta #'filter)"],["br"],["code-text","; {:ns #<Namespace clojure.core>, :name filter, :added \"1.0\","],["br"],["code-text",";  :file \"clojure/core.clj\", :static true, :column 1, :line 2588,"],["br"],["code-text",";  :arglists ([pred coll]), :doc \"Returns a lazy sequence of the"],["br"],["code-text","; items in coll for which\\n  (pred item) returns true. pred must"],["br"],["code-text","; be free of side-effects.\"}"],["br"]],["paragraph",["br"]],["paragraph",["text","Veja que agora conseguimos acessar os metadados de "],["monospaced",["text","filter"]],["text",", que estão associados ao "],["italic",["text","var"]],["text",", e não ao corpo da função propriamente dita. Sendo assim, se passarmos "],["monospaced",["text","filter"]],["text"," como parâmetro para uma função, os metadados não irão junto."],["br"]],["code","clojure",["br"],["code-text","(defn extrair-doc [valor]"],["br"],["code-text","  (:doc (meta valor)))"],["br"],["code-text","(extrair-doc filter)"],["br"],["code-text","; nil"],["br"],["code-text","(extrair-doc #'filter)"],["br"],["code-text","; \"Returns a lazy sequence of the items in coll for which"],["br"],["code-text","; (pred item) returns true. pred must be free of side-effects.\""],["br"]],["paragraph",["br"]],["paragraph",["text","Agora sim conseguimos extrair a documentação de "],["monospaced",["text","filter"]],["text","."],["br"]],["paragraph",["text","Lembra quando foi dito que "],["italic",["text","macros"]],["text"," são executadas em "],["italic",["text","tempo de compilação"]],["text"," e funções são executadas em "],["italic",["text","tempo de execução"]],["text","? Pois "],["italic",["text","reader macros"]],["text"," são tipos especias de macros e, como tal, são executadas durante a compilação."],["br"]],["paragraph",["text","Estou repetindo isso para poder deixar claro dois conceitos importantes aqui, antes de irmos para o próximo passo. Saber diferenciar quando seu código será executado em tempo de compilação ou de execução é importante. Saber que existem "],["italic",["text","reader macros"]],["text"," também vai tornar o conceito mais fácil de entender."],["br"]],["paragraph",["text","Assim como existe um "],["italic",["text","reader macro"]],["text"," que nos permite acessar diretamente um "],["italic",["text","var"]],["text",", também existe um que adiciona metadados em tempo de compilação."],["br"]],["index",["text","^{ }"]],["paragraph",["br"]],["paragraph",["text","O nosso "],["italic",["text","reader macro"]],["text"," da vez é o "],["monospaced",["text","^{ }"]],["text",", que vai conter o mapa de metadados na declaração do "],["italic",["text","var"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def ^{:descricao \"Numeros de um a seis\"} numeros '(1 2 3 4 5 6))"],["br"],["code-text","numeros"],["br"],["code-text","; (1 2 3 4 5 6)"],["br"],["code-text","(meta numeros)"],["br"],["code-text","; {:line 1, :column 52}"],["br"],["code-text","(meta #'numeros)"],["br"],["code-text","; {:ns #<Namespace user>, :name numeros, :file \"NO_SOURCE_PATH\","],["br"],["code-text",";  :descricao \"Numeros de um a seis\", :column 1, :line 1}"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que ao utilizar "],["monospaced",["text","^{ }"]],["text",", os metadados foram informados antes do nome do "],["italic",["text","var"]],["text","."],["br"]],["paragraph",["text","Agora os metadados estão associados ao "],["italic",["text","var"]],["text"," ao invés do valor. Perceba que o próprio Clojure adiciona metadados que são utilizados para indicar onde ocorreu um erro ou por ferramentas de análise de código."],["br"]],["paragraph",["text","Se olharmos novamente os metadados de "],["monospaced",["text","filter"]],["text",", veremos duas informações interessantes: "],["monospaced",["text","file"]],["text"," e "],["monospaced",["text","line"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(meta #'filter)"],["br"],["code-text","; {:ns #<Namespace clojure.core>, :name filter, :added \"1.0\","],["br"],["code-text",";  :file \"clojure/core.clj\", :static true, :column 1, :line 2588,"],["br"],["code-text",";  :arglists ([pred coll]), :doc \"Returns a lazy sequence of the"],["br"],["code-text","; items in coll for which\\n  (pred item) returns true. pred must"],["br"],["code-text","; be free of side-effects.\"}"],["br"],["code-text","(:file (meta #'filter))"],["br"],["code-text","; \"clojure/core.clj\""],["br"],["code-text","(:line (meta #'filter))"],["br"],["code-text","; 2588"],["br"]],["paragraph",["br"]],["paragraph",["text","De acordo com os metadados, o código fonte da função "],["monospaced",["text","filter"]],["text"," está no arquivo "],["monospaced",["text","clojure/core.clj"]],["text"," e começa na linha "],["italic",["text","2588"]],["text","."],["br"]],["paragraph",["text","Ao acessarmos http://git.io/rGpXXw, que vai nos direcionar para o código fonte da biblioteca padrão do Clojure, veremos que, a partir da linha "],["italic",["text","2588"]],["text"," do arquivo "],["monospaced",["text","core.clj"]],["text"," temos a função "],["monospaced",["text","filter"]],["text","."],["br"]],["paragraph",["text","Note que é exatamente o mesmo conteúdo que teríamos ao usar "],["monospaced",["text","doc"]],["text",", já que é assim que a macro faz para encontrar o código fonte."],["br"]],["box",["text","Olhando os fontes do Clojure"],["paragraph",["br"]],["paragraph",["text","Boa parte do Clojure está escrita em Clojure, então vá sem medo algum. Dê uma boa olhada sempre que quiser. É uma experiência que vai fazer com que você aprenda bem mais depressa."],["br"]]],["paragraph",["br"]],["paragraph",["text","Caso você esteja usando uma versão do Clojure diferente da versão do livro, o número da linha pode variar. Basta localizar os fontes da versão que você estiver usando e você vai ver o mesmo resultado."],["br"]],["paragraph",["text","E o que acontece se informarmos os metadados após o nome do "],["italic",["text","var"]],["text","?"],["br"]],["paragraph",["text","Nada. Até a versão utilizada nesse livro, os metadados são simplesmente ignorados. Então, se você tentar adicionar metadados a um "],["italic",["text","var"]],["text"," e nada acontecer, verifique se você não inverteu a ordem."],["br"]],["code","clojure",["br"],["code-text",";; vamos adicionar os metadados ANTES do nome"],["br"],["code-text","(def ^{:descricao \"Antes do nome\"} antes '())"],["br"],["code-text","(meta antes)"],["br"],["code-text","; nil"],["br"],["code-text","(meta #'antes)"],["br"],["code-text","; {:ns #<Namespace user>, :name antes, :file \"NO_SOURCE_PATH\","],["br"],["code-text","; :descricao \"Antes do nome\", :column 1, :line 1}"],["br"],["code-text",";; agora vamos adicionar depois"],["br"],["code-text","(def depois ^{:descricao \"Depois do nome\"} '())"],["br"],["code-text","(meta depois)"],["br"],["code-text","; nil"],["br"],["code-text","(meta #'depois)"],["br"],["code-text","; {:ns #<Namespace user>, :name depois, :file \"NO_SOURCE_PATH\","],["br"],["code-text","; :column 1, :line 1}"],["br"]],["paragraph",["br"]],["title",["text","Manipulando metadados"]],["paragraph",["br"]],["paragraph",["text","É possível também alterar os metadados já existentes. Isso pode ser útil caso você desenvolva alguma ferramenta de análise de código, por exemplo. Você poderia marcar os dados já observados com um metadado específico."],["br"]],["paragraph",["text","Vamos alterar uma função da biblioteca padrão do Clojure, por exemplo."],["br"]],["index",["text","alter-meta!"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(alter-meta! #'count #(assoc % :avaliado true))"],["br"],["code-text","; {:avaliado true, :added \"1.0\", :ns #<Namespace clojure.core>,"],["br"],["code-text","; ...}"],["br"]],["paragraph",["br"]],["paragraph",["text","Para usarmos a função "],["monospaced",["text","alter-meta!"]],["text"," precisamos informar o "],["italic",["text","var"]],["text"," a ser alterado e uma função que vai alterar o "],["italic",["text","hashmap"]],["text"," que contém os metadados. Então "],["monospaced",["text","alter-meta!"]],["text"," retorna os metadados alterados."],["br"]],["index",["text","reset-meta!"]],["paragraph",["br"]],["paragraph",["text","Já para desfazer uma modificação nos metadados ou mesmo para limpar qualquer metadado existe, devemos usar a função "],["monospaced",["text","reset-meta!"]],["text",", que recebe como argumentos o "],["italic",["text","var"]],["text"," a ser modificado e um "],["italic",["text","hashmap"]],["text"," contendo os valores pelos quais você vai substituir o mapa de metadados atual."],["br"]],["paragraph",["text","Vamos alterar os metadados de "],["monospaced",["text","map"]],["text"," no nosso exemplo."],["br"]],["code","clojure",["br"],["code-text",";; vamos gravar os metadados em algum lugar"],["br"],["code-text","(def metadados-antigos (meta #'map))"],["br"],["code-text",";; como era antes"],["br"],["code-text","(meta #'map)"],["br"],["code-text","; {:ns #<Namespace clojure.core>, :name map, :added \"1.0\","],["br"],["code-text","; ..."],["br"],["code-text","; accept number-of-colls arguments.\"}"],["br"],["code-text","(alter-meta! #'map #(assoc % :alterado true))"],["br"],["code-text","; {:added \"1.0\", ... , :alterado true, :column 1, :line 2541,"],["br"],["code-text","; ..."],["br"],["code-text","; f should accept number-of-colls arguments.\"}"],["br"],["code-text",";; tudo certo de novo"],["br"],["code-text","(reset-meta! #'map metadados-antigos)"],["br"],["code-text","; {:ns #<Namespace clojure.core>, :name map, :added \"1.0\","],["br"],["code-text","; ..."],["br"],["code-text","; accept number-of-colls arguments.\"}"],["br"],["code-text",";; tudo certo de novo"],["br"],["code-text","(meta #'map)"],["br"],["code-text","; {:ns #<Namespace clojure.core>, :name map, :added \"1.0\","],["br"],["code-text","; ..."],["br"],["code-text","; accept number-of-colls arguments.\"}"],["br"],["code-text",";; agora vamos zerar os metadados"],["br"],["code-text","(reset-meta! #'map {})"],["br"],["code-text","; {}"],["br"]],["paragraph",["br"]],["title",["text","A seguir"]],["paragraph",["br"]],["paragraph",["text","Nenhuma função ou estrutura de dados fica solta no Clojure. Toda vez que você cria um "],["monospaced",["text","var"]],["text",", uma função ou uma estrutura de dados global, ou referencia uma biblioteca ou pacote externo, você tem que lidar com "],["italic",["text","namespaces"]],["text",". E é isso que veremos em detalhes no próximo capítulo."],["br"]],["box",["text","Crédito"],["paragraph",["br"]],["paragraph",["text","A imagem "],["ref-label",["text","cap05-venn"]],["text"," foi fortemente baseada no trabalho"],["ref",["text","seqs-and-colls"]],["text"," de Tim McCormack e usada com sua gentil permissão neste livro."],["br"]],["paragraph",["text","Thank you very much, Tim."],["br"]]],["paragraph",["br"]]]