["document",["chapter",["text"," O REPL é tão importante..."]],["paragraph",["br"]],["quote",["text","\"A única forma de se aprender uma nova linguagem é escrevendo programas nela\""],["text","  -- Brian Kernighan, coautor do UNIX e da linguagem C"]],["paragraph",["br"]],["section",["text","... que merece um capítulo a parte"]],["paragraph",["br"]],["index",["text","REPL"]],["paragraph",["br"]],["paragraph",["text","O "],["monospaced",["text","REPL"]],["text"," é uma das ferramentas mais úteis para se programar em Clojure. Se você está chegando do Ruby ou do Python está mais do que acostumado a usar o "],["monospaced",["text","IRB"]],["text"," ou o modo interativo do Python. Veremos no decorrer do capítulo que o REPL é bem mais do que um prompt da linguagem, que serve apenas para que instruções sejam testadas."],["br"]],["paragraph",["text","O termo "],["monospaced",["text","REPL"]],["text",", pronuncia-se "],["italic",["text","Répol"]],["text"," com aquele "],["italic",["text","R"]],["text"," do Chico Bento, é formado pelas iniciais de "],["italic",["text","Read-Eval-Print-Loop"]],["text",", que é o ciclo efetuado pela ferramenta ao "],["bold",["text","Ler"]],["text"," a instrução digitada pelo programador, "],["bold",["text","avaliar"]],["text"," e executar a instrução, "],["bold",["text","imprimir"]],["text"," o resultado e "],["bold",["text","voltar"]],["text"," ao início, aguardando a próxima instrução, como na figura "],["ref-label",["text","repl-diagram"]],["text","."],["br"]],["img",["text","images/capitulo_03/repl_diagram.png \"Read-eval-print-loop\" w=40% label=repl-diagram"]],["paragraph",["br"]],["box",["text","O que é avaliar?"],["paragraph",["br"]],["index",["text","avaliar"]],["paragraph",["br"]],["paragraph",["text","Quando estamos usando algum dialeto LISP, como é o caso do Clojure, é comum usarmos o termo "],["bold",["text","avaliar"]],["text"," para descrever o momento em que o comando é analisado e executado pelo interpretador da linguagem."],["br"]],["paragraph",["text","Então, sempre que você se deparar com o verbo "],["bold",["text","avaliar"]],["text",", entenda que a instrução está sendo lida e interpretada."],["br"]]],["paragraph",["br"]],["paragraph",["text","A grande vantagem dessa abordagem é que o desenvolvedor vê o resultado imediatamente, sem a necessidade de compilar o projeto, executar e esperar a resposta. Com isso, você pode testar diferentes abordagens e até mesmo brincar com instruções para chegar ao resultado esperado num período muito curto."],["br"]],["paragraph",["text","Após instalarmos o Leiningen, como vimos no capítulo passado, vamos abrir o REPL executando o comando abaixo no seu terminal:"],["br"]],["code",["br"],["code-text","lein repl"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos ver mensagens parecidas com a da figura "],["ref-label",["text","lein-repl"]],["text","."],["br"]],["img",["text","images/capitulo_03/lein_repl.png \"REPL do Clojure\" w=70% label=lein-repl"]],["paragraph",["br"]],["paragraph",["text","Essas mensagens foram adicionadas na versão 1.5 do Clojure e te dão algumas dicas sobre como se achar dentro da ferramenta. Para nós, o importante agora vai ser a última linha, que tem o cursor piscando, aguardando os nossos comandos."],["br"]],["code",["br"],["code-text","user=>"],["br"]],["paragraph",["br"]],["index",["text","namespace"]],["index",["text","user"]],["paragraph",["br"]],["paragraph",["text","O texto "],["monospaced",["text","user"]],["text"," indica o "],["italic",["text","namespace"]],["text"," em que estamos trabalhando. Vamos falar disso mais para frente, mas por enquanto é suficiente saber que um "],["italic",["text","namespace"]],["text"," é como se fosse um pacote contendo funções que lidam com determinada parte do trabalho. Outras linguagens implementam essa forma de organização, como o Java com "],["italic",["text","packages"]],["text",", C# e C++ também com "],["italic",["text","namespaces"]],["text"," ou Ruby e Python com "],["italic",["text","modules"]],["text","."],["br"]],["paragraph",["text","Vamos começar exibindo valores simples, omitindo a exibição do namespace para evitar confusão ao digitar. Perceba que não estamos usando parênteses, já que se tratam de valores, e não expressões a serem avaliadas:"],["br"]],["code","clojure",["br"],["code-text","1"],["br"],["code-text","true"],["br"],["code-text","\"Texto\""],["br"]],["paragraph",["br"]],["paragraph",["text","Exibimos um número inteiro, um valor lógico e um texto. A saída dos dados pode ser vista na figura "],["ref-label",["text","repl-values"]],["text","."],["br"]],["img",["text","images/capitulo_03/repl_values.png \"Exibindo valores simples\" w=90% label=repl-values"]],["paragraph",["br"]],["paragraph",["text","Vamos agora executar algumas expressões. Como já dissemos, uma expressão deve estar entre parênteses para ser executada, ou se preferir, avaliada."],["br"]],["index",["text","not"]],["index",["text","or"]],["paragraph",["br"]],["code","clojure",["br"],["code-text",";; uma soma simples"],["br"],["code-text","(+ 1 2)"],["br"],["code-text","; 3"],["br"],["code-text",";; o operador not e um valor booleano"],["br"],["code-text","(not true)"],["br"],["code-text","; false"],["br"],["code-text",";; o operador or e dois valores booleanos"],["br"],["code-text","(or false true)"],["br"],["code-text","; true"],["br"]],["paragraph",["br"]],["paragraph",["text","Podemos ver o resultado na figura "],["ref-label",["text","repl-expressions"]],["text","."],["br"]],["img",["text","images/capitulo_03/repl_expressions.png \"Exibindo os resultados de expressões\" w=90% label=repl-expressions"]],["paragraph",["br"]],["paragraph",["text","Uma coisa interessante que o uso da notação prefixa permite é que um operador não precisa trabalhar com os valores de dois em dois, como acontece com uma adição ou um operador lógico na notação infixa."],["br"]],["paragraph",["text","É possível, por exemplo, somar inúmeros valores de uma vez só, tendo o resultado da figura "],["ref-label",["text","repl-multiple-values"]],["text","."],["br"]],["code","clojure",["br"],["code-text","; uma soma com vários valores"],["br"],["code-text","(+ 1 2 3 4 5 6)"],["br"],["code-text","; o operador or com vários valores"],["br"],["code-text","(or true false true false true true)"],["br"]],["paragraph",["br"]],["img",["text","images/capitulo_03/repl_multiple_values.png w=90% \"Múltiplos valores\" label=repl-multiple-values"]],["paragraph",["br"]],["index",["text","println"]],["index",["text","print"]],["paragraph",["br"]],["paragraph",["text","Existe uma função chamada "],["monospaced",["text","println"]],["text"," que, veja só, imprime valores na tela e pula uma linha. Há uma irmã dela que não pula linha e chama-se "],["monospaced",["text","print"]],["text",", mas dificilmente vamos usá-la aqui."],["br"]],["index",["text","nil"]],["paragraph",["br"]],["paragraph",["text","Essa função "],["monospaced",["text","println"]],["text"," retorna "],["monospaced",["text","nil"]],["text",", que é a representação de um valor nulo no Clojure. Por conta disso, não se preocupe com o "],["monospaced",["text","nil"]],["text"," que é exibido após a impressão do valor."],["br"]],["paragraph",["text","Você pode passar quantos parâmetros quiser para essa função, e ela vai imprimir um a um, até terminar."],["br"]],["code","clojure",["br"],["code-text","(println 3)"],["br"],["code-text","(println \"Um texto\" \"Outro texto\")"],["br"]],["paragraph",["br"]],["paragraph",["text","Primeiro mandamos imprimir na tela um valor qualquer e, em seguida, mandamos exibir dois textos. Podemos ver como ficou na figura "],["ref-label",["text","repl-println"]],["text","."],["br"]],["paragraph",["text","Perceba que os valores são impressos e, logo abaixo, é exibido "],["monospaced",["text","nil"]],["text",". A impressão é o "],["italic",["text","efeito colateral"]],["text"," da função, e "],["monospaced",["text","nil"]],["text"," é o retorno."],["br"]],["img",["text","images/capitulo_03/repl_println.png \"Usando a função println\" w=90% label=repl-println"]],["paragraph",["br"]],["paragraph",["text","Agora vamos imprimir o resultado da soma entre os números "],["italic",["text","1"]],["text"," e "],["italic",["text","2"]],["text",", conforme a figura "],["ref-label",["text","repl-println-expression-fail"]],["br"]],["img",["text","images/capitulo_03/repl_println_expression_fail.png \"Não imprimiu o que queríamos\" w=90% label=repl-println-expression-fail"]],["paragraph",["br"]],["paragraph",["text","Ao invés do número "],["italic",["text","3"]],["text",", foram exibidos os três itens da nossa expressão: o sinal de adição, que nada mais é do que o nome de uma função, e os números "],["italic",["text","1"]],["text"," e "],["italic",["text","2"]],["text","."],["br"]],["index",["text","+"]],["index",["text","-"]],["index",["text","*"]],["index",["text","/"]],["index",["text","="]],["index",["text",">"]],["index",["text","<"]],["index",["text","_"]],["paragraph",["br"]],["paragraph",["text","Em Clojure, os sinais "],["monospaced",["text","+"]],["text",", "],["monospaced",["text","-"]],["text",", "],["monospaced",["text","*"]],["text",", "],["monospaced",["text","/"]],["text",", "],["monospaced",["text","="]],["text",", "],["monospaced",["text",">"]],["text",", "],["monospaced",["text","<"]],["text"," e "],["monospaced",["text","_"]],["text",", e as combinações entre eles, são considerados nomes válidos de função."],["br"]],["index",["text","if"]],["paragraph",["br"]],["paragraph",["text","O aprendizado fica muito mais fácil quando você percebe que os operadores aritméticos, lógicos e de comparação são funções como quaisquer outras. De certo modo, até mesmo um "],["monospaced",["text","if"]],["text"," é uma função em Clojure."],["br"]],["paragraph",["text","Aí você pergunta: "],["italic",["text","\"mas, se + é um nome válido de função, por que foi que o REPL imprimiu "],["monospaced",["text","#<core$_PLUS_ ...>"]],["text"," ao invés do sinal de adição?\""]],["br"]],["index",["text","bytecode"]],["paragraph",["br"]],["paragraph",["text","Simplesmente porque o Clojure gera "],["italic",["text","bytecode"]],["text"," que é executado na JVM (ou na máquina virtual do .NET), e os símbolos citados acima não são nomes válidos nesses ambientes. Então a linguagem é obrigada a criar uma função interna chamada "],["monospaced",["text","_PLUS_"]],["text"," que ganha o apelido "],["monospaced",["text","+"]],["text"," para que o seu código fique fácil de ler."],["br"]],["box",["text","O que é "],["italic",["text","bytecode"]],["paragraph",["br"]],["paragraph",["text","Uma das ideias mais fortes por trás do Java é "],["italic",["text","escreva uma vez, rode em qualquer lugar"]],["text","."],["br"]],["paragraph",["text","Para que isso aconteça, o compilador do Java gera um código intermediário, independente de plataforma, que será executado pela máquina virtual. Esse codigo intermediário é chamado genericamente de "],["italic",["text","bytecode"]],["text","."],["br"]],["paragraph",["text","Como aplicações escritas em Java puro e Clojure geram o mesmo tipo de bytecode, é bem simples integrarmos o código de um com o outro, como vamos ver mais no capítulo "],["ref-label",["text","capitulo-integracao-java"]],["text","."],["br"]]],["paragraph",["br"]],["paragraph",["text","Vamos corrigir o nosso código para que possamos ver o resultado da soma."],["br"]],["paragraph",["text","Fica fácil se você pensar que queremos imprimir o resultado de "],["monospaced",["text","+ 1 2"]],["text",", e não os itens da operação separadamente. "],["br"]],["paragraph",["text","Para trabalharmos com o resultado da soma, vamos colocar os membros entre parênteses. Assim, o "],["monospaced",["text","REPL"]],["text"," vai avaliar primeiro a soma e depois vai mandar imprimir o resultado."],["br"]],["paragraph",["text","Nosso código então vai ficar da forma abaixo, e podemos ver o resultado na figura "],["ref-label",["text","repl-println-expression-ok"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(println (+ 1 2))"],["br"]],["paragraph",["br"]],["img",["text","images/capitulo_03/repl_println_expression_ok.png \"Agora deu certo\" w=90% label=repl-println-expression-ok"]],["paragraph",["br"]],["paragraph",["text","Agora que você já sabe usar o "],["monospaced",["text","REPL"]],["text"," o suficiente para poder seguir os exemplos do livro, vamos aprender a sair."],["br"]],["paragraph",["text","Para sair do REPL existem duas formas: o jeito "],["italic",["text","novo"]],["text",", incluído na versão 1.5 do Clojure, e o jeito antigo, que ainda é a utilizada no Clojure CLR e nas versões anteriores do Clojure."],["br"]],["index",["text","exit"]],["paragraph",["br"]],["paragraph",["text","Para sair pelo jeito novo, basta digitar "],["monospaced",["text","exit"]],["text",". Como é um comando do "],["monospaced",["text","REPL"]],["text",", e não do Clojure, não fique preocupado com o fato de não ter que usar parênteses, como podemos ver na figura "],["ref-label",["text","repl-exit-new"]],["text","."],["br"]],["img",["text","images/capitulo_03/repl_exit_new.png \"Saindo do REPL pelo jeito novo\" w=90% label=repl-exit-new"]],["paragraph",["br"]],["paragraph",["text","Caso você esteja com uma versão antiga, execute o método "],["monospaced",["text","exit"]],["text"," da classe "],["monospaced",["text","System"]],["text"," do Java, passando o número "],["italic",["text","0"]],["text"," como código para informar ao sistema operacional que saída ocorreu sem erros."],["br"]],["code","clojure",["br"],["code-text","(System/exit 0)"],["br"]],["paragraph",["br"]],["paragraph",["text","Ao sair por esse modo, não temos a simpática mensagem de adeus, como vemos na figura "],["ref-label",["text","repl-exit-old"]],["text","."],["br"]],["img",["text","images/capitulo_03/repl_exit_old.png \"Saindo do REPL pelo jeito anterior\" w=90% label=repl-exit-old"]],["paragraph",["br"]],["section",["text","Alguns truques rápidos com o REPL"]],["paragraph",["br"]],["paragraph",["text","Existem alguns atalhos e funções auxiliares que tornam o uso do REPL bem mais produtivo. Por mais que escrever diretamente no REPL não seja tão confortável quando no seu editor preferido, algumas vezes isso acaba sendo necessário."],["br"]],["title",["text","Qual é mesmo o nome daquela função?"]],["paragraph",["br"]],["paragraph",["text","As funções da biblioteca padrão do Clojure vem com um texto explicativo, onde você pode se situar sobre como utilizá-las."],["br"]],["index",["text","find-doc"]],["paragraph",["br"]],["paragraph",["text","Podemos pesquisar alguma palavra que estiver dentro desses textos para encontrar a função que queremos, mas não lembramos o nome. Para isso, usamos "],["monospaced",["text","find-doc"]],["text",", seguido da palavra ou trecho de texto relacionado ao que queremos."],["br"]],["paragraph",["text","Vamos supor que eu esteja procurando algo sobre "],["italic",["text","sockets"]],["text",". Basta digitar "],["monospaced",["text","(find-doc \"socket\")"]],["text"," no REPL."],["br"]],["code","clojure",["br"],["code-text","(find-doc \"socket\")"],["br"],["code-text","; -------------------------"],["br"],["code-text","; clojure.tools.nrepl/connect"],["br"],["code-text","; ([& {:keys [port host transport-fn], :or {transport-fn"],["br"],["code-text",";  transport/bencode, host \"localhost\"}}])"],["br"],["code-text",";  Connects to a socket-based REPL at the given host (defaults"],["br"],["code-text","; to localhost) and port, returning the Transport (by default"],["br"],["code-text","; clojure."],["br"],["code-text","; e mais um monte de coisas"],["br"]],["paragraph",["br"]],["index",["text","connect"]],["paragraph",["br"]],["paragraph",["text","No nosso exemplo, encontramos a função "],["monospaced",["text","connect"]],["text",", que está no namespace "],["monospaced",["text","clojure.tools.nrepl"]],["text","."],["br"]],["index",["text","apropos"]],["paragraph",["br"]],["paragraph",["text","Se você lembra de alguma parte do nome da função, então pode usar a função "],["monospaced",["text","apropos"]],["text",", passando como parâmetros o trecho do nome ou uma expressão regular. Não se preocupe com expressões regulares agora, pois veremos esse assunto em detalhes mais para frente."],["br"]],["index",["text","vector"]],["paragraph",["br"]],["paragraph",["text","Vamos supor que eu esteja manipulando vetores e não lembre o nome da função, mas saiba que a estrutura chama-se "],["monospaced",["text","vector"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(apropos \"vector\")"],["br"],["code-text","; (vector-of vector vector? vector-zip)"],["br"]],["paragraph",["br"]],["index",["text","apropos-better"]],["paragraph",["br"]],["paragraph",["text","Existe uma variação de "],["monospaced",["text","apropos"]],["text"," chamada "],["monospaced",["text","apropos-better"]],["text",", que informa também o namespace da função quando ela não estiver dentro do namespace "],["monospaced",["text","clojure.core"]],["text"," ou dentro do namespace em que você estiver no momento:"],["br"]],["code","clojure",["br"],["code-text","(apropos-better \"vector\")"],["br"],["code-text","; (vector vector-of vector? clojure.zip/vector-zip)"],["br"]],["paragraph",["br"]],["index",["text","doc"]],["paragraph",["br"]],["paragraph",["text","Agora você pode usar a função "],["monospaced",["text","doc"]],["text"," para ver a documentação daquela que mais se parecer com o que você estiver procurando:"],["br"]],["code","clojure",["br"],["code-text","(doc vector?)"],["br"],["code-text","; -------------------------"],["br"],["code-text","; clojure.core/vector?"],["br"],["code-text","; ([x])"],["br"],["code-text",";   Return true if x implements IPersistentVector"],["br"]],["paragraph",["br"]],["index",["text","javadoc"]],["paragraph",["br"]],["paragraph",["text","Caso você queira ver a documentação de uma classe ou objeto Java, a função "],["monospaced",["text","doc"]],["text"," não pode te ajudar. Felizmente é possível consultar o "],["italic",["text","Javadoc"]],["text",", que é a forma padrão de documentação do Java"],["ref",["text","oracle-javadoc"]],["text",". Para isso usamos a função "],["monospaced",["text","javadoc"]],["text",", obviamente:"],["br"]],["code","clojure",["br"],["code-text","(source java.io.File)"],["br"],["code-text","Source not found"],["br"],["code-text","(javadoc java.io.File)"],["br"],["code-text","; \"http://java.sun.com/javase/7/docs/api/java/io/File.html\""],["br"]],["paragraph",["br"]],["paragraph",["text","Além de retornar um texto com a localização da documentação, a função "],["monospaced",["text","javadoc"]],["text"," também abre o seu browser padrão na página indicada, como podemos ver na figura "],["ref-label",["text","cap03-javadoc"]],["text",":"],["br"]],["img",["text","images/capitulo_03/javadoc.png \"E a função abre o browser para você\" label=cap03-javadoc w=70%"]],["paragraph",["br"]],["paragraph",["text","Eu sempre gostei da forma como a documentação do pacote "],["monospaced",["text","java.io"]],["text"," foi escrita e achei que daria um bom exemplo."],["br"]],["title",["text","Um pouco de Bash na sua vida"]],["paragraph",["br"]],["paragraph",["text","Quando você usa o REPL por dentro do Leiningen, alguns atalhos já conhecidos pelos usuários de Bash estão disponíveis, mesmo para quem está usando o Leiningen no Windows."],["br"]],["index",["text","Bash"]],["paragraph",["br"]],["box",["text","O que é Bash"],["paragraph",["br"]],["paragraph",["italic",["text","Bash"]],["text"," é um dos "],["italic",["text","shells"]],["text"," mais conhecidos por quem usa sistemas operacionais baseados em UNIX ou Linux. Shell é a camada mais externa do sistema operacional e onde você insere comandos e recebe os resultados, de modo similar ao que acontece no REPL."],["br"]]],["paragraph",["br"]],["paragraph",["text","O primeiro deles é a tecla "],["italic",["text","TAB"]],["text",", que exibe os nomes de funções que começam com o que você já digitou."],["br"]],["index",["text","map"]],["paragraph",["br"]],["paragraph",["text","Por exemplo, vou digitar "],["monospaced",["text","map"]],["text"," e pressionar "],["italic",["text","TAB"]],["br"]],["code","clojure",["br"],["code-text","(map"],["br"],["code-text","; map           map-indexed   map?          mapcat        mapv"],["br"]],["paragraph",["br"]],["paragraph",["text","É possível também encontrar algum "],["italic",["text","namespace"]],["text"," específico da mesma maneira que foi feita para procurar a função:"],["br"]],["code","clojure",["br"],["code-text","(clojure.s"],["br"],["code-text","; clojure.set          clojure.stacktrace   clojure.string "],["br"]],["paragraph",["br"]],["paragraph",["text","Você pode usar a tecla "],["italic",["text","TAB"]],["text"," para ver todas as funções disponíveis em determinado "],["italic",["text","namespace"]],["text",", bastando adicionar uma barra após o nome:"],["br"]],["code","clojure",["br"],["code-text","(clojure.set/"],["br"],["code-text","; clojure.set/difference clojure.set/index clojure.set/join"],["br"],["code-text","; clojure.set/intersection clojure.set/map-invert"],["br"],["code-text","; clojure.set/project clojure.set/rename clojure.set/rename-keys"],["br"],["code-text","; clojure.set/select clojure.set/subset? clojure.set/superset?"],["br"],["code-text","; clojure.set/union"],["br"]],["paragraph",["br"]],["paragraph",["text","Outra combinação que agiliza bastante o trabalho é a combinação "],["italic",["text","Control L"]],["text",", ou "],["italic",["text","Command L"]],["text"," se você estiver usando MacOS, que limpa os resultados das expressões anteriores e mantém apenas a expressão que você estiver digitando no momento."],["br"]],["paragraph",["text","Existe também a combinação "],["italic",["text","Control R"]],["text",", ou "],["italic",["text","Command R"]],["text",", que completa o que você estiver digitando usando o histórico de comandos do REPL. Pressionando essa combinação mais de uma vez vai alternar entre todas as combinações já utilizadas que contenham o texto que você já digitou."],["br"]],["paragraph",["text","Usar as setas "],["italic",["text","para cima"]],["text"," ou "],["italic",["text","para baixo"]],["text"," permite que você navegue nos comandos utilizados recentemente."],["br"]],["title",["text","Recuperando os últimos resultados"]],["paragraph",["br"]],["index",["text","*1"]],["index",["text","*2"]],["index",["text","*3"]],["index",["text","*e"]],["paragraph",["br"]],["paragraph",["text","Existem também símbolos especiais que guardam os resultados das últimas expressões e exceções. Eles são "],["monospaced",["text","*1"]],["text",", "],["monospaced",["text","*2"]],["text"," e "],["monospaced",["text","*3"]],["text"," para os valores e "],["monospaced",["text","*e"]],["text"," para a última exceção, ou erro, que ocorreu:"],["br"]],["code","clojure",["br"],["code-text","(+ 1 2)"],["br"],["code-text","; 3"],["br"],["code-text","(* 2 4)"],["br"],["code-text","; 8"],["br"],["code-text","(/ 8 2)"],["br"],["code-text","; 4"],["br"],["code-text","(println \"Resultados anteriores:\" *1 *2 *3)"],["br"],["code-text","; Resultados anteriores: 4 8 3"],["br"],["code-text","(/ 1 0)"],["br"],["code-text","; ArithmeticException Divide by zero"],["br"],["code-text","(println \"Último erro:\" *e)"],["br"],["code-text","; Último erro: #<ArithmeticException java.lang.ArithmeticException:"],["br"],["code-text",";   Divide by zero>"],["br"]],["paragraph",["br"]],["index",["text","pst"]],["paragraph",["br"]],["paragraph",["text","Caso você queira ver a lista de chamadas, ou "],["italic",["text","stacktrace"]],["text",", do último erro, basta utilizar a função "],["monospaced",["text","pst"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(/ 1 0)"],["br"],["code-text","; ArithmeticException Divide by zero"],["br"],["code-text","(println \"Último erro:\" *e)"],["br"],["code-text","; Último erro: #<ArithmeticException java.lang.ArithmeticException:"],["br"],["code-text",";   Divide by zero>"],["br"],["code-text","user=> (pst)"],["br"],["code-text","; java.lang.ArithmeticException: Divide by zero"],["br"],["code-text","; Numbers.java:156 clojure.lang.Numbers.divide"],["br"],["code-text","; Numbers.java:3691 clojure.lang.Numbers.divide"],["br"],["code-text","; ... um monte de linhas ..."],["br"],["code-text","; Thread.java:745 java.lang.Thread.run"],["br"]],["paragraph",["br"]],["title",["text","Consultando o código fonte"]],["paragraph",["br"]],["paragraph",["text","Algumas vezes é bom ter acesso ao código fonte de determinada função ou macro para que possamos entender melhor como ela funciona. Enquanto eu escrevia este livro, fiz isso constantemente para descobrir como as coisas funcionam por baixo dos panos."],["br"]],["paragraph",["text","Infelizmente, nem sempre é simples ir até o site onde o código fonte do Clojure está disponível e procurar o arquivo em que aquela função está definida. "],["br"]],["paragraph",["text","Pior ainda quando a versão que está lá é diferente da versão que você está usando no momento. E fica ainda pior quando você não tem acesso ao código fonte da biblioteca que estiver utilizando."],["br"]],["index",["text","source"]],["paragraph",["br"]],["paragraph",["text","Para nos ajudar, existe a macro "],["monospaced",["text","source"]],["text",", que recebe como parâmetro o nome da função, sem aspas, e exibe o respectivo código fonte, quando possível."],["br"]],["paragraph",["text","Existem casos em que isso não é possível, como quando você tentar ler o fonte de uma forma especial ou de um código que foi compilado utilizando AOT (veremos isso em detalhes mais para frente)."],["br"]],["paragraph",["text","Vamos exibir o código fonte da função "],["monospaced",["text","+"]],["text",", responsável por somar dois ou mais números:"],["br"]],["code","clojure",["br"],["code-text","(source +)"],["br"],["code-text","; (defn +"],["br"],["code-text",";   \"Returns the sum of nums. (+) returns 0. Does not auto-promote"],["br"],["code-text",";   longs, will throw on overflow. See also: +'\""],["br"],["code-text",";   {:inline (nary-inline 'add 'unchecked_add)"],["br"],["code-text",";    :inline-arities >1?"],["br"],["code-text",";    :added \"1.2\"}"],["br"],["code-text",";   ([] 0)"],["br"],["code-text",";   ([x] (cast Number x))"],["br"],["code-text",";   ([x y] (. clojure.lang.Numbers (add x y)))"],["br"],["code-text",";   ([x y & more]"],["br"],["code-text",";      (reduce1 + (+ x y) more)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que temos acesso a todos os detalhes internos da função "],["monospaced",["text","+"]],["text",", incluindo sua documentação e mais algumas informações que são úteis para o compilador ou para alguma função que gere documentação automaticamente."],["br"]],["paragraph",["text","Ao tentarmos ver o código fonte de uma forma especial ou de algum código escrito nativamente em Java, receberemos uma mensagem de que o código fonte não foi encontrado:"],["br"]],["code","clojure",["br"],["code-text","(source Thread/sleep)"],["br"],["code-text","; Source not found"],["br"]],["paragraph",["text"," "],["br"]],["section",["text","Desenvolvimento baseado no REPL"]],["paragraph",["br"]],["paragraph",["text","Uma das características que faz o Clojure tão interessante para desenvolvermos software é que o REPL não é apenas um "],["italic",["text","console"]],["text"," da linguagem. Ele não serve apenas para que você teste expressões ou funções de uma biblioteca. Com o REPL você pode "],["bold",["text","alterar o programa enquanto ele está sendo executado"]],["text","."],["br"]],["paragraph",["text","Se você trabalha com Java e utiliza TDD, o seu workflow pode ser resumido em escrever um teste, rodar o teste e vê-lo falhar. Em seguida você escreve o código necessário para que o teste passe e então recomeça o ciclo até concluir o desenvolvimento. "],["br"]],["index",["text","warmup"]],["paragraph",["br"]],["paragraph",["text","A cada vez que você roda os testes, a JVM demora algum tempo carregando a si mesma até começar a executar o conjunto de testes que você selecionou. Esse tempo é chamado de "],["italic",["text","warmup"]],["text",". Existem técnicas para reduzir esse tempo, mas é inevitável que ele exista."],["br"]],["paragraph",["text","Para executar a aplicação há um tempo gasto com a compilação, o tempo de warmup da JVM e só então sua aplicação começa a ser executada."],["br"]],["paragraph",["text","Quando você desenvolve em Ruby, mais especificamente quando está utilizando Rails, o console da linguagem permite que você altere dados da aplicação enquanto ela está sendo executada, mas você não pode alterar a estrutura do que já foi carregado, como objetos e funções."],["br"]],["paragraph",["text","É aqui que o Clojure começa a mostrar a sua diferença: você pode alterar código e dados durante a execução do programa, mesmo que eles já tenham sido carregados, sem que para isso você perca tempo esperando o warmup da JVM ou recompilando a aplicação."],["br"]],["section",["text","Criando uma aplicação de exemplo"]],["paragraph",["br"]],["paragraph",["text","Vamos criar uma pequena aplicação para demonstrar como isso funciona na prática."],["br"]],["index",["text","lein new"]],["paragraph",["br"]],["paragraph",["text","Primeiro, execute o comando "],["monospaced",["text","lein new capitulo03"]],["text"," para criar um novo projeto. Será criado um diretório chamado "],["monospaced",["text","capitulo03"]],["text"," com um esqueleto dessa aplicação. Não se preocupe com a estrutura que foi criada, pois mais para frente vamos explicar em detalhes o que é cada arquivo e cada diretório."],["br"]],["index",["text","namespace"]],["paragraph",["br"]],["paragraph",["text","Dentro do diretório "],["monospaced",["text","src/capitulo03"]],["text"," existe um arquivo chamado "],["monospaced",["text","core.clj"]],["text",". Ele contém o "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","capitulo03.core"]],["text",", que informamos dentro do arquivo "],["monospaced",["text","project.clj"]],["text",", e isso é declarado logo na primeira linha, por meio da instrução "],["monospaced",["text","(ns capitulo03.core)"]],["text","."],["br"]],["paragraph",["text","Vamos criar agora uma função chamada "],["monospaced",["text","texto"]],["text",". Essa função apenas imprime "],["italic",["text","\"Texto original\""]],["text"," na tela. Para isso usaremos a função "],["monospaced",["text","println"]],["text",", que imprime os valores passados por parâmetro para saída padrão. Nossa função ficará assim:"],["br"]],["code","clojure",["br"],["code-text","(defn texto []"],["br"],["code-text","  (println \"Texto original\"))"],["br"]],["paragraph",["br"]],["index",["text","entry point"]],["index",["text","loop"]],["paragraph",["br"]],["paragraph",["text","Em seguida, vamos criar a função "],["monospaced",["text","-main"]],["text",", que é a função inicial da aplicação, ou "],["italic",["text","entry point"]],["text",". Nela vamos criar um "],["italic",["text","loop"]],["text"," infinito que invoca a função "],["monospaced",["text","texto"]],["text"," e faz uma pausa de dois segundos. Não se preocupe com os detalhes, já que vamos explicar todos eles mais para frente."],["br"]],["index",["text",";"]],["index",["text","comentários"]],["paragraph",["br"]],["paragraph",["text","Os comentários, iniciados pelo caracter "],["monospaced",["text",";"]],["text"," foram adicionados para que você não se perca logo no terceiro capítulo do livro:"],["br"]],["index",["text","Thread/sleep"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(defn -main [& args]"],["br"],["code-text","  (loop []              ; inicia o loop"],["br"],["code-text","    (texto)             ; chama a função texto"],["br"],["code-text","    (Thread/sleep 2000) ; espera dois segundos"],["br"],["code-text","    (recur)))           ; retorna ao início do loop"],["br"]],["paragraph",["br"]],["index",["text","lein repl"]],["paragraph",["br"]],["paragraph",["text","Agora salve o arquivo e volte ao diretório "],["monospaced",["text","capitulo03"]],["text",", execute o comando "],["monospaced",["text","lein repl"]],["text"," para abrir o "],["italic",["text","REPL"]],["text",". Note que na primeira linha é exibido um texto dizendo que o "],["italic",["text","nREPL"]],["text"," foi iniciado em uma determinada porta, no IP "],["italic",["text","127.0.0.1"]],["text",". Anote o número dessa porta, pois vamos precisar daqui a pouco."],["br"]],["paragraph",["text","Execute a instrução "],["italic",["text","(use 'capitulo03.core)"]],["text"," para importar as funções do namespace "],["italic",["text","capitulo03.core"]],["text",". Isso vai ser necessário para que possamos executar as duas funções que acabamos de criar."],["br"]],["paragraph",["text","Agora execute a instrução "],["monospaced",["text","(-main)"]],["text"," para iniciar nossa aplicação. A cada dois segundos será impresso "],["italic",["text","Texto original"]],["text","."],["br"]],["section",["text","Modificando a aplicação através do REPL"]],["paragraph",["br"]],["paragraph",["text","Abra uma nova janela do Terminal, vá ao diretório "],["monospaced",["text","capitulo03"]],["text"," e execute o comando "],["monospaced",["text","lein repl :connect 127.0.0.1:XXXX"]],["text",", substituindo "],["monospaced",["text","XXXX"]],["text"," pela porta que você anotou. "],["br"]],["paragraph",["text","Execute a instrução "],["monospaced",["text","(ns capitulo03.core)"]],["text"," para que possamos trabalhar dentro do namespace em que criamos nossas funções e, em seguida, execute "],["monospaced",["text","(texto)"]],["text"," para que seja exibido o texto atual, conforme programamos anteriormente."],["br"]],["paragraph",["text","Agora, usando esse REPL que acabamos de abrir, vamos modificar a aplicação que está sendo executada na outra janela. Digite o código a seguir e vamos analisar o que acontece:"],["br"]],["code","clojure",["br"],["code-text","(defn texto []"],["br"],["code-text","  (println \"Agora mudou\"))"],["br"]],["paragraph",["br"]],["paragraph",["text","Ao executar novamente a instrução "],["monospaced",["text","(texto)"]],["text",", veremos que o texto exibido foi alterado. Agora volte à janela onde a aplicação está sendo executada e veja o que aconteceu."],["br"]],["paragraph",["text","O texto exibido a cada dois segundos mudou instantaneamente de "],["italic",["text","Texto original"]],["text"," para "],["italic",["text","Agora mudou"]],["text","."],["br"]],["paragraph",["text","Mas o que aconteceu?"],["br"]],["index",["text","nREPL"]],["paragraph",["br"]],["paragraph",["text","A aplicação estava sendo executada em uma janela, por dentro de um REPL. O REPL disponibilizado pelo Leiningen vem com uma biblioteca embutida chamada nREPL, que permite que possamos conectar remotamente outro REPL em uma aplicação, e por isso são exibidos um endereço IP e o número de uma porta."],["br"]],["paragraph",["text","Quando conectamos o REPL da segunda janela na aplicação que imprime o texto a cada dois segundos, estamos conectados "],["italic",["text","dentro"]],["text"," da aplicação. Então, toda alteração que você fizer dentro da segunda janela, será instantaneamente refletida na aplicação da primeira janela."],["br"]],["index",["text","Vim"]],["index",["text","Emacs"]],["index",["text","Cider"]],["index",["text","Fireplace"]],["index",["text","Lighttable"]],["paragraph",["br"]],["paragraph",["text","Esse recurso fica ainda mais interessante quando você utiliza um editor de texto que se conecte automaticamente ao REPL, como é o caso do "],["italic",["text","Vim"]],["text"," através do plugin "],["monospaced",["text","fireplace"]],["text",", do "],["italic",["text","Emacs"]],["text"," através do pacote "],["monospaced",["text","Cider"]],["text",", ou do "],["italic",["text","Lighttable"]],["text",", editor utilizado nesse livro, que já vem com esse recurso instalado por padrão."],["br"]],["paragraph",["text","Essa integração com o editor permite que o seu código seja enviado de forma transparente ao REPL, sem que você precise escrever a mesma coisa no editor e depois no REPL, fazendo com que você tenha todas as vantagens do seu editor preferido somado à agilidade que ganhamos ao alterar a aplicação enquanto ela está sendo executada, sem necessidade de a recompilarmos ou esperarmos que ela seja carregada novamente."],["br"]],["paragraph",["text","Existem vários textos pela Internet explicando como os autores usam esse recurso para criar um fluxo de trabalho ágil e produtivo. Fique à vontade para experimentar e descobrir seu próprio jeito de trabalhar."],["br"]],["paragraph",["text","Caso seu editor preferido não dê suporte ao nREPL, não se preocupe. Durante o livro vamos explicar cada exemplo sem a necessidade de usarmos esse recurso. Se você não usar, tudo bem. Mas se resolver usar, vai ser melhor ainda."],["br"]],["paragraph",["text","A partir do próximo capítulo vamos aumentar o ritmo e entrar a fundo na linguagem, apresentando todos os recursos necessários para que você consiga usar Clojure para resolver problemas de verdade e, de repente, até mesmo convencer seus colegas de que vale a pena aprender e usar no trabalho."]]]