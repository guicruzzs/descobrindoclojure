["document",["chapter",["text"," Uma introdução gentil ao Clojure"]],["paragraph",["br"]],["label",["text","capitulo-introducao-clojure"]],["paragraph",["br"]],["quote",["text","\"Qualquer pessoa pode aprender LISP em um dia, exceto os que aprenderam FORTRAN. Esses demorarão três dias.\""],["text","  -- Marvin Minsky"],["ref",["text","bio-marvin-minsky"]]],["paragraph",["br"]],["section",["text","O que é Clojure?"]],["paragraph",["br"]],["index",["text","CLR"]],["index",["text","JVM"]],["index",["text","Hickey, Rich"]],["paragraph",["br"]],["paragraph",["text","A linguagem Clojure foi criada por Rich Hickey e lançada em 2007, focando o desenvolvimento na JVM, mas hoje em dia é possível executar a linguagem sobre a CLR (a máquina virtual do .NET) e mesmo sobre alguma "],["italic",["text","engine"]],["text"," JavaScript, como o V8, que é a base do "],["italic",["text","Node.js"]],["text","."],["br"]],["index",["text","concorrência"]],["index",["text","multithreading"]],["index",["text","programação funcional"]],["index",["text","JavaScript"]],["index",["text","Scala"]],["paragraph",["br"]],["paragraph",["text","É uma linguagem funcional, como o JavaScript e o Scala, e foi pensada para facilitar o desenvolvimento de aplicações que dependam de concorrência de processos e "],["italic",["text","multithreading"]],["ref",["text","clojure-rationale"]],["text",", o que não significa que não possa ser usada para criar outras aplicações que não dependam disso. Sistemas concorrentes que podem ser bem difíceis de desenvolver com Java acabam se tornando mais simples e concisos."],["br"]],["paragraph",["text","É também um dialeto LISP"],["ref",["text","history-lisp"]],["text",", mas com mudanças interessantes na forma de apresentar a linguagem, o que elimina uma porção de parênteses"],["ref",["text","lisp-differences"]],["text"," quando comparamos códigos equivalentes escritos em Common Lisp ou Scheme, que são os dois dialetos LISP historicamente mais conhecidos."],["br"]],["section",["text","Configurando o ambiente"]],["paragraph",["br"]],["paragraph",["text","No decorrer do livro, vamos escrever código o tempo todo e é importante que você já tenha o ambiente instalado antes mesmo de inserir sua primeira instrução."],["br"]],["paragraph",["text","A primeira coisa que precisamos nos certificar é que você tenha o JDK instalado em sua máquina. Ele pode ser baixado no seguinte link:"],["br"]],["paragraph",["text","http://www.oracle.com/technetwork/java/javase/downloads/index.html"],["br"]],["paragraph",["text","Verifique se a versão instalada do Java é a 1.6 ou mais recente. As versões mais recentes do Clojure não funcionam com versões mais antigas do Java."],["br"]],["paragraph",["text","Digite "],["monospaced",["text","java -version"]],["text"," em seu Prompt de Comandos ou Terminal para verificar se você está com a máquina virtual instalada e qual sua respectiva versão."],["br"]],["paragraph",["text","Após termos o JDK funcionando, vamos instalar uma ferramenta chamada "],["italic",["text","Leiningen"]],["text",", que vai ser nosso grande companheiro mesmo depois que você terminar o livro. "],["br"]],["paragraph",["text","O "],["italic",["text","Leiningen"]],["text"," automatiza uma série de tarefas, gerencia dependências, agiliza a execução de testes, compilação e pode ser estendido com o uso de plugins. Existem plugins para praticamente todas as tarefas comuns que você precise executar ao desenvolver com Clojure. Para quem está vindo do Java, podemos entender o Leiningen como um primo turbinado do "],["italic",["text","Maven"]],["text","."],["br"]],["paragraph",["text","Acesse http://leiningen.org/#install e leia as instruções para instalação do script. Em seguida, execute o comando "],["italic",["text","lein -v"]],["text"," para verificar a versão atual e baixar as dependências que serão usadas inicialmente."],["br"]],["paragraph",["text","Durante a escrita desse livro, o Leiningen estava em sua versão "],["monospaced",["text","2.5.1"]],["text",", mas não se preocupe se a sua versão for mais recente enquanto você estiver lendo o livro."],["br"]],["paragraph",["text","Execute "],["monospaced",["text","lein"]],["text"," sem nenhum parâmetro para ver as opções de uso do Leiningen. Voltaremos a elas assim que explicarmos a sintaxe da linguagem."],["br"]],["section",["text","Explicando a sintaxe"]],["paragraph",["br"]],["paragraph",["text","É bem provável que você se assuste na primeira vez que ver um código Clojure, mas fique tranquilo, pois existe uma lógica muito simples por trás dessa cara diferentona."],["br"]],["paragraph",["text","É comum pensar num primeiro momento que o Clojure é invertido em relação às outras linguagens por conta da ordem em que as expressões são escritas, mas você vai acabar percebendo que, na verdade, a linguagem é consistente até demais se olharmos em perspectiva."],["br"]],["paragraph",["text","Relembrando das aulas de matemática, nós expressamos funções dessa forma:"],["br"]],["code","javascript",["br"],["code-text","y = f(x)"],["br"]],["paragraph",["br"]],["paragraph",["text","Para calcular o dobro, teríamos "],["monospaced",["text","y = f(x) = x * 2"]],["text",", ou "],["monospaced",["text","y = x * 2"]],["text","."],["br"]],["paragraph",["text","Para calcularmos o dobro de um número, onde internamente calcularíamos o valor de um parâmetro "],["monospaced",["text","x"]],["text"," multiplicado por "],["italic",["text","2"]],["text",", teríamos:"],["br"]],["code","javascript",["br"],["code-text","y = dobro(21)"],["br"]],["paragraph",["br"]],["index",["text","notação prefixa"]],["index",["text","operador"]],["index",["text","operando"]],["paragraph",["br"]],["paragraph",["text","Note que estamos usando uma notação diferente: primeiro vem o "],["italic",["text","operador"]],["text"," "],["monospaced",["text","dobro"]],["text"," e, em seguida, vem o "],["italic",["text","operando"]],["text",", ou parâmetro, "],["italic",["text","21"]],["text",". Chamamos isso de "],["italic",["text","notação prefixa"]],["text","."],["br"]],["box",["text","Notação prefixa, ou simbólica"],["paragraph",["br"]],["paragraph",["text","A notação prefixa utilizada no Clojure, e em qualquer outro LISP, é conhecida também como "],["italic",["text","S-Expression"]],["text",". Esse nome vem do termo "],["italic",["text","Symbolic Expression"]],["text",", ou expressão simbólica, onde uma lista contendo outras listas pode ser representada internamente como uma árvore."],["br"]],["paragraph",["text","O termo foi utilizado pela primeira vez por John McCarthy, o criador do "],["italic",["text","LISP"]],["ref",["text","lisp-1"]],["text",". Antes das "],["italic",["text","S-Expressions"]],["text",", McCarthy tinha trabalhado com a ideia de "],["italic",["text","M-Expressions"]],["text",", ou "],["italic",["text","meta-expressions"]],["text",", mas a ideia foi descartada"],["ref",["text","history-lisp"]],["text","."],["br"]]],["paragraph",["br"]],["paragraph",["text","Já para executar um cálculo aritmético, usamos a forma abaixo:"],["br"]],["code","javascript",["br"],["code-text","y = 21 * 2"],["br"]],["paragraph",["br"]],["index",["text","notação infixa"]],["paragraph",["br"]],["paragraph",["text","Primeiro temos um operando "],["italic",["text","21"]],["text",", depois temos um operador responsável pela multiplicação e, finalmente, o segundo operando "],["italic",["text","2"]],["text",". Chamamos essa forma de "],["italic",["text","notação infixa"]],["text","."],["br"]],["box",["text","Se você veio do Ruby..."],["paragraph",["br"]],["index",["text","Ruby"]],["paragraph",["br"]],["paragraph",["text","Se você é um desenvolvedor Ruby, ignore esta última expressão."],["br"]],["paragraph",["text","No Ruby, o cálculo acima utiliza internamente a notação prefixa onde "],["italic",["text","21"]],["text"," é um objeto, "],["monospaced",["text","*"]],["text"," é um método (ou uma mensagem, se preferir) e "],["italic",["text","2"]],["text"," é um parâmetro."],["br"]],["code","ruby",["br"],["code-text","x = 21 * 2"],["br"],["code-text","y = 21.*(2)"],["br"]],["paragraph",["br"]],["paragraph",["text","As duas formas são válidas e equivalentes, apesar da segunda ser mais difícil de ler."],["br"]]],["paragraph",["br"]],["paragraph",["text","A coisa fica bagunçada quando misturamos as duas formas:"],["br"]],["code","javascript",["br"],["code-text","y = dobro(7 * 3)"],["br"]],["paragraph",["br"]],["paragraph",["text","Na expressão acima misturamos notação prefixa com infixa. Não há problema algum com isso, mas não é um bom exemplo de consistência."],["br"]],["paragraph",["text","Quando falamos em Clojure, ou qualquer outra forma de LISP, o primeiro item de uma lista é um operador e todos os demais são operandos."],["br"]],["index",["text","função"]],["index",["text","macros"]],["index",["text","forma especial"]],["paragraph",["br"]],["paragraph",["text","Todo operador é uma "],["italic",["text","função"]],["text",", "],["italic",["text","macro"]],["text"," ou "],["italic",["text","forma especial"]],["text",", inclusive os operadores matemáticos. Não se preocupe em entender agora o que são macros ou formas especiais. "],["br"]],["paragraph",["text","Todo os itens do resto da lista são considerados valores, parâmetros ou operandos."],["br"]],["paragraph",["text","Imagine agora que o símbolo + é uma função. Para calcularmos uma soma usaríamos o seguinte código:"],["br"]],["code","javascript",["br"],["code-text","+(1, 2)"],["br"]],["paragraph",["br"]],["paragraph",["text","Movendo os parênteses e removendo as vírgulas, a nossa soma inicial ficaria:"],["br"]],["code","clojure",["br"],["code-text","(+ 1 2)"],["br"]],["paragraph",["br"]],["box",["text","Molhando os dedos"],["paragraph",["br"]],["paragraph",["text","Vamos usar uma ferramenta muito importante do Clojure chamada REPL. Não se preocupe agora em saber o que significa, pois teremos um capítulo todo só para isso."],["br"]],["paragraph",["text","No Terminal do seu sistema operacional, execute o comando "],["monospaced",["text","lein repl"]],["text"," para carregar o REPL do Clojure. Se for a primeira vez que você o abre, algumas dependências ainda serão baixadas para o seu computador."],["br"]],["paragraph",["text","Digite a instrução "],["monospaced",["text","(+ 1 2)"]],["text"," e pressione ENTER. A linha de baixo trará o resultado, "],["italic",["text","3"]],["text","."],["br"]],["paragraph",["text","Parabéns, você acabou de escrever seu primeiro código em Clojure e nós ainda nem começamos a aprender a linguagem."],["br"]],["paragraph",["text","Use o REPL para acompanhar os exemplos desse livro enquanto for lendo, digitando e vendo os resultados conforme você aprende."],["br"]],["paragraph",["text","Quando quiser sair do REPL, digite "],["monospaced",["text","exit"]],["text"," e pressione ENTER."],["br"]]],["paragraph",["br"]],["paragraph",["text","Sabemos que "],["monospaced",["text","dobro"]],["text"," também é uma função. Para calcular "],["monospaced",["text","dobro"]],["text",", usaríamos:"],["br"]],["code","clojure",["br"],["code-text","(dobro 21)"],["br"]],["paragraph",["br"]],["paragraph",["text","Percebam que agora temos uma regra que se aplica a todos os casos. Repetindo a expressão acima que mistura as notações infixa e prefixa usando as regras do LISP, teríamos:"],["br"]],["code","clojure",["br"],["code-text","(dobro (* 7 3))"],["br"]],["paragraph",["br"]],["box",["text","Testando 'dobro'"],["paragraph",["br"]],["paragraph",["text","Para que possamos testar todos os exemplos desse capítulo, precisamos criar uma função chamada "],["monospaced",["text","dobro"]],["text",", que recebe um parâmetro "],["monospaced",["text","x"]],["text"," e devolve seu valor multiplicado por dois."],["br"]],["paragraph",["text","Em Clojure, criamos uma função "],["monospaced",["text","dobro"]],["text"," da seguinte forma:"],["br"]],["code","clojure",["br"],["code-text","(defn dobro [x] "],["br"],["code-text","  (* x 2))"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos abrir o REPL e digitar as linhas abaixo:"],["br"]],["code","clojure",["br"],["code-text","(dobro 21)"],["br"],["code-text","(dobro (* 7 3))"],["br"]],["paragraph",["br"]],["paragraph",["text","Em ambos os casos, você obterá o número "],["italic",["text","42"]],["text"," como resposta."],["br"]],["paragraph",["text","Ah, e comemore: você acabou de escrever sua primeira função em Clojure. As funções são parte importantíssima de uma linguagem funcional."],["br"]]],["paragraph",["br"]],["paragraph",["text","Talvez pela sua origem acadêmica e fortemente influenciada pela matemática, as implementações de LISP levam muito a sério a questão da consistência."],["br"]],["section",["text","Explicando os parênteses"]],["paragraph",["br"]],["index",["text","expressões numéricas"]],["paragraph",["br"]],["paragraph",["text","Quando eu estava na quarta série, aprendi algo chamado de "],["italic",["text","expressão numérica"]],["text",", que consiste em resolver um cálculo extenso atacando um pedaço por vez, organizadamente."],["br"]],["paragraph",["text","Cada pedaço desse cálculo fica dentro de parênteses, colchetes ou chaves, dependendo do quão aninhado esteja a expressão. Eu nunca mais vi esse tipo de hierarquia, mas sempre considerei como um jeito bacana de manter a organização."],["br"]],["paragraph",["text","Uma expressão numérica tem essa cara:"],["br"]],["code","javascript",["br"],["code-text","x = {1 + [3 * (5 + 7)]}"],["br"]],["paragraph",["br"]],["paragraph",["text","Resolve a expressão de dentro para fora:"],["br"]],["code","javascript",["br"],["code-text","x = {1 + [3 * (12)]}"],["br"],["code-text","x = {1 + [36]}"],["br"],["code-text","x = {37}"],["br"],["code-text","x = 37"],["br"]],["paragraph",["br"]],["paragraph",["text","Simples, não?"],["br"]],["paragraph",["text","Agora vamos extrapolar o que aprendemos na quarta série para uma linguagem de programação, trocando chaves e colchetes por parênteses:"],["br"]],["code","javascript",["br"],["code-text","x = (1 + (3 * (5 + 7)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos substituir a nossa conhecida notação infixa pela prefixa:"],["br"]],["code","clojure",["br"],["code-text","x = (+ 1 (* 3 (+ 5 7)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Pronto. Você tem uma expressão numérica com a cara do LISP, resolvendo da forma como a professora ensinou lá na quarta série: primeiro você resolve os parênteses de dentro, depois os próximos, até terminar. "],["br"]],["paragraph",["text","Pode parecer estranho, mas não se preocupe, com o tempo essa notação não te trará dificuldades na leitura e entendimento do código. E há sim mais razões pela qual ela é dessa maneira, que desvendaremos aos poucos."],["br"]],["paragraph",["text","Qualquer LISP que você encontrar pela frente, incluindo o Clojure, funciona exatamente dessa maneira."],["br"]],["index",["text","precedência de operadores"]],["paragraph",["br"]],["paragraph",["text","Uma vantagem que isso traz é que você não precisa ficar se preocupando com precedência de operadores. Imagine que você tem o código abaixo:"],["br"]],["code","javascript",["br"],["code-text","x = 3 * 2 + 1"],["br"],["code-text","y = 1 + 2 * 3"],["br"]],["paragraph",["br"]],["paragraph",["text","Os valores de "],["monospaced",["text","x"]],["text"," e "],["monospaced",["text","y"]],["text"," serão iguais? Sim, ambas as variáveis contém o número "],["italic",["text","7"]],["text",", mas para saber disso você precisou ler em algum outro lugar que "],["italic",["text","o operador de multiplicação tem precedência sobre o operador de adição"]],["text",". É algo que você espera que seja assim e age como se realmente fosse."],["br"]],["paragraph",["text","E o que aconteceria se você estiver usando uma linguagem em que a adição tem precedência sobre a multiplicação? Ou pior ainda: os operadores são executados da esquerda para a direita conforme forem aparecendo."],["br"]],["paragraph",["text","No primeiro caso, "],["monospaced",["text","x"]],["text"," e "],["monospaced",["text","y"]],["text"," continuariam sendo iguais, mas ambos teriam o valor "],["italic",["text","9"]],["text",". No segundo caso, "],["monospaced",["text","x"]],["text"," seria igual a "],["italic",["text","7"]],["text"," e "],["monospaced",["text","y"]],["text"," seria igual a "],["italic",["text","9"]],["text","."],["br"]],["paragraph",["text","Seria mais fácil se as expressões fossem escritas assim:"],["br"]],["code","javascript",["br"],["code-text","x = (3 * 2) + 1"],["br"],["code-text","y = 1 + (2 * 3)"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora está claro para qualquer pessoa o que vai ser executado primeiro, independente do modo como a expressão seja interpretada pela linguagem. Pois saiba que é exatamente assim que um LISP trabalha. Usando a notação prefixa, as expressões acima ficariam da forma a seguir, que você pode testar usando o REPL:"],["br"]],["code","clojure",["br"],["code-text","(+ (* 3 2) 1)"],["br"],["code-text","(+ 1 (* 3 2))"],["br"]],["paragraph",["br"]],["paragraph",["text","Primeiro será executada a multiplicação, que está nos parênteses mais internos e, em seguida, será executada a adição. Tudo isso sem se preocupar com regras ocultas ou peculiaridades do compilador."],["br"]],["paragraph",["text","No capítulo a seguir, vamos aprender mais sobre o REPL para que possamos utilizar Clojure de uma forma rápida e produtiva."]]]