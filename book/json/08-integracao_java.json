["document",["chapter",["text"," Integrando Clojure com Java"]],["paragraph",["br"]],["label",["text","capitulo-integracao-java"]],["paragraph",["br"]],["quote",["text","\"The apprentice avoids all use of Java classes. The journeyman embraces Java classes. The master knows which classes to embrace and which to avoid.\""],["text","  -- Michael Fogus, coautor do livro 'The Joy of Clojure'"],["ref",["text","joy-of-clojure"]]],["paragraph",["br"]],["section",["text","Unindo forças"]],["paragraph",["br"]],["paragraph",["text","O primeiro LISP surgiu em 1959 e, desde então, versões e dialetos vem surgindo e sendo utilizados em projetos avançados e nichos. Com o Clojure parece ser a primeira vez que o LISP caminha para se tornar uma linguagem conhecida e utilizada mesmo em grandes empresas."],["br"]],["paragraph",["text","O grande diferencial é a integração com a Máquina Virtual do Java, ou simplesmente "],["italic",["text","JVM"]],["text","."],["br"]],["paragraph",["text","Empresas pelo mundo inteiro, de gigantes como IBM e Oracle até empresas pequenas, dependem de alguma forma da "],["italic",["text","JVM"]],["text"," e de algum código escrito em Java. Ao escolher uma outra linguagem de programação, você corre o risco de ter que jogar toda essa base e todo esse investimento no lixo."],["br"]],["paragraph",["text","Vieram então o Clojure e tantas outras linguagens que se integram da mesma maneira, trazendo ganhos de produtividade e aproveitando todo o código que já existe há mais de uma década."],["br"]],["paragraph",["text","Com isso você tem o melhor dos dois mundos: a maturidade da JVM, com toda sua base de código, ferramentas e bibliotecas já existentes, testadas e estáveis; e uma linguagem moderna que permite o desenvolvimento rápido e simples de aplicações concorrentes sem muitos dos problemas que a linguagem Java traz."],["br"]],["paragraph",["text","Já tive experiências em que determinada empresa só trabalhava com Java. Resolvi o problema com poucas linhas de código Clojure, gerei um pacote "],["italic",["text","JAR"]],["text"," e enviei para instalação. Sendo o conteúdo do arquivo "],["italic",["text","JAR"]],["text"," uma aplicação Java como qualquer outra, a instalação ocorreu sem qualquer problema e a aplicação está sendo executada em produção. No final estão todos satisfeitos, independente da linguagem que tenha sido utilizada para resolver o problema."],["br"]],["paragraph",["text","Aquela biblioteca que faz cálculos complexos e que levou anos para ficar redonda pode ser utilizada com Clojure sem problemas. Aquele seu servidor de aplicações que custa uma fortuna de suporte pode rodar a sua aplicação Clojure também sem problemas."],["br"]],["paragraph",["text","A outra equipe só programa em Java e a sua em Clojure? Sem problemas. Você pode integrar ambas para rodar macio."],["br"]],["title",["text","Convencendo o chefe"]],["paragraph",["br"]],["paragraph",["text","Por experiência própria, evite todo o falatório técnico se quiser convencer um chefe não-técnico a usar Clojure ou qualquer outra tecnologia que pareça diferente do que é usado atualmente."],["br"]],["paragraph",["text","Eu recomendo primeiro resolver um problema, mostrar resultados, causar o mínimo de danos possível, ou de preferência nenhum dano, e só depois apresentar números. Quanto tempo foi economizado, quantas linhas de código foram reduzidas e quanto do investimento da empresa foi aproveitado."],["br"]],["paragraph",["text","De qualquer maneira, avalie bem o terreno. Em algumas empresas uma nova linguagem não costuma ser bem aceita, mesmo com todos os benefícios."],["br"]],["section",["text","Bytecodes: os blocos de montar da JVM"]],["paragraph",["br"]],["index",["text","bytecode"]],["paragraph",["br"]],["paragraph",["text","Simplificando ao máximo"],["ref",["text","jvm8-spec"]],["text",", a "],["italic",["text","JVM"]],["text"," trabalha processando pilhas de códigos chamados "],["italic",["text","bytecodes"]],["text",". Cada "],["italic",["text","bytecode"]],["text"," pode ter um ou dois bytes, sendo que existem 256 códigos possíveis, mesmo que nem todos sejam utilizados."],["br"]],["paragraph",["text","Esses "],["italic",["text","bytecodes"]],["text"," são processados pela "],["italic",["text","JVM"]],["text",", que faz o meio de campo com a plataforma onde o código está sendo executado. Dessa forma você pode ter o mesmo "],["italic",["text","bytecode"]],["text"," sendo executado em diferentes plataformas sem qualquer alteração."],["br"]],["paragraph",["text","Para você ter ideia da cara que tem o "],["italic",["text","bytecode"]],["text",", vamos pegar o seguinte código Java:"],["br"]],["code","java",["br"],["code-text","public class Hello {"],["br"],["code-text","  public static void main(String[] arg) {"],["br"],["code-text","    System.out.println(\"Olá Java\");"],["br"],["code-text","  }"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["index",["text","javap"]],["paragraph",["br"]],["paragraph",["text","Após compilar o código, você pode inspecionar o arquivo "],["monospaced",["text",".class"]],["text"," gerado com a ferramenta "],["italic",["text","javap"]],["ref",["text","javap-manual"]],["text",", que serve para inspecionar classes compiladas, e vem junto com o compilador do Java."],["br"]],["paragraph",["text","Usando o "],["italic",["text","javap"]],["text"," teremos uma saída parecida com essa:"],["br"]],["code",["br"],["code-text","#2 //  java/lang/System.out:Ljava/io/PrintStream;"],["br"],["code-text","#3 //  Olá Java"],["br"],["code-text","#4 //  java/io/PrintStream.println:(Ljava/lang/String;)V"],["br"],["code-text","{"],["br"],["code-text","  public Hello();"],["br"],["code-text","  public static void main(java.lang.String[]);"],["br"],["code-text","    0: getstatic     #2"],["br"],["code-text","    3: ldc           #3"],["br"],["code-text","    5: invokevirtual #4"],["br"],["code-text","    8: return"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["paragraph",["text","Esses códigos "],["monospaced",["text","getstatic"]],["text",", "],["monospaced",["text","ldc"]],["text",", "],["monospaced",["text","invokevirtual"]],["text"," e "],["monospaced",["text","return"]],["text"," são "],["italic",["text","mnemônicos"]],["text"," para os bytecodes. Isso quer dizer que eles são nomes com algum significado para indicar que ali, na verdade, existem números. Cada número é uma instrução diferente, ou um "],["italic",["text","bytecode"]],["text"," diferente."],["br"]],["paragraph",["text","Conhecer a fundo os "],["italic",["text","bytecodes"]],["text"," pode não ser útil num primeiro momento, seja para aprender Java ou para aprender Clojure, mas é o tipo de conhecimento que pode acabar se tornando um grande diferencial profissional. É aquela história de que você não precisa saber como um motor funciona para dirigir um carro, mas em uma situação atípica isso pode acabar salvando sua pele."],["br"]],["paragraph",["text","Se você tiver tempo e disposição, é um assunto bem interessante para se estudar."],["br"]],["section",["text","Instanciando e invocando objetos Java"]],["paragraph",["br"]],["paragraph",["text","Todo o código Clojure que você escrever, mesmo que no "],["italic",["text","REPL"]],["text",", vai ser compilado para "],["italic",["text","bytecode"]],["text"," Java. Todo o código Java que você escrever, mesmo aquele "],["italic",["text","Hello world"]],["text"," simples de tudo, vai ser compilado para "],["italic",["text","bytecode"]],["text"," Java."],["br"]],["paragraph",["text","Como tudo o que a "],["italic",["text","JVM"]],["text"," enxerga é bytecode, tanto vai fazer se ele foi gerado pelo Clojure ou pelo Java. E é aí que está o pulo do gato na hora de integrar as duas linguagens. Para a "],["italic",["text","JVM"]],["text"," ambos são a mesma coisa."],["br"]],["paragraph",["text","Então você pode incluir classes Java no seu código Clojure sem custo adicional, nem gambiarras."],["br"]],["index",["text","java.awt.Point"]],["paragraph",["br"]],["paragraph",["text","Vamos começar instanciando a classe "],["monospaced",["text","java.awt.Point"]],["text",". Essa classe representa logicamente um ponto num plano cartesiano e contém duas propriedades: "],["monospaced",["text","x"]],["text"," e "],["monospaced",["text","y"]],["text","."],["br"]],["index",["text","."]],["paragraph",["br"]],["paragraph",["text","Para instanciar um objeto, basta utilizar o operador "],["monospaced",["text","."]],["text"," logo após o nome da classe."],["br"]],["code","clojure",["br"],["code-text",";; em Java = new java.awt.Point()"],["br"],["code-text","(java.awt.Point.)"],["br"],["code-text","; #<Point java.awt.Point[x=0,y=0]>"],["br"]],["paragraph",["br"]],["index",["text","new"]],["paragraph",["br"]],["paragraph",["text","Podemos usar também o operador "],["monospaced",["text","new"]],["text"," para criar um objeto. Com isso temos uma cara mais familiar para quem está recém chegando do Java. Note que aqui não usamos o operador "],["monospaced",["text","."]],["text"," após o nome da classe."],["br"]],["code","clojure",["br"],["code-text",";; em Java = new java.awt.Point()"],["br"],["code-text","(new java.awt.Point)"],["br"],["code-text","; #<Point java.awt.Point[x=0,y=0]>"],["br"]],["paragraph",["br"]],["paragraph",["text","Se quisermos instanciar um objeto usando um "],["italic",["text","constructor"]],["text"," que receba argumentos, basta passá-los logo após o nome da classe. Da mesma forma que instanciamos com o construtor sem argumentos, podemos usar o operador "],["monospaced",["text","."]],["text"," ou o operador "],["monospaced",["text","new"]],["text","."],["br"]],["code","clojure",["br"],["code-text"," ;; em Java = new java.awt.Point(3, 4)"],["br"],["code-text","(java.awt.Point. 3 4)"],["br"],["code-text","; #<Point java.awt.Point[x=3,y=4]>"],["br"],["code-text","(new java.awt.Point 3 4)"],["br"],["code-text","; ; #<Point java.awt.Point[x=3,y=4]>"],["br"]],["paragraph",["br"]],["paragraph",["text","Para invocarmos um método do objeto, também existem duas formas, sendo ambas com o operador "],["monospaced",["text","."]],["text",". A primeira também tem similaridade com o Java, posicionando o nome do objeto à esquerda do método ou do campo."],["br"]],["code","clojure",["br"],["code-text","(def ponto (java.awt.Point.))"],["br"],["code-text","(. ponto x)            ;; em Java = ponto.x"],["br"],["code-text","; 0"],["br"],["code-text","(. ponto toString)     ;; em Java = ponto.toString()"],["br"],["code-text","; \"java.awt.Point[x=0,y=0]"],["br"],["code-text","(. ponto distance 3 4) ;; em Java = ponto.distance(3, 4)"],["br"],["code-text","; 5.0"],["br"]],["paragraph",["br"]],["paragraph",["text","A segunda forma é mais coerente com o modo de trabalhar do Clojure, deixando a ação como primeiro item da lista e o objeto como o segundo."],["br"]],["paragraph",["text","Os parâmetros são passados em seguida, como numa expressão qualquer do Clojure."],["br"]],["code","clojure",["br"],["code-text","(def ponto (java.awt.Point.))"],["br"],["code-text","(.x ponto)             ;; em Java = ponto.x"],["br"],["code-text","; 0"],["br"],["code-text","(.toString ponto)      ;; em Java = ponto.toString()"],["br"],["code-text","; \"java.awt.Point[x=0,y=0]"],["br"],["code-text","(.distance ponto 3 4)  ;; em Java = ponto.distance(3, 4)"],["br"],["code-text","; 5.0"],["br"]],["paragraph",["br"]],["paragraph",["text","Para acessar um método ou um campo estático, basta usar "],["monospaced",["text","/"]],["text"," entre o nome da classe e o nome do método ou do campo."],["br"]],["index",["text","Math/PI"]],["paragraph",["br"]],["index",["text","Byte/MAX_VALUE"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(java.awt.Point/distance 0 0 3 4))"],["br"],["code-text","; 5.0"],["br"],["code-text","java.lang.Math/PI         ;; em Java = java.lang.Math.PI"],["br"],["code-text","; 3.141592653589793"],["br"],["code-text","Byte/MAX_VALUE            ;; em Java = Byte.MAX_VALUE"],["br"],["code-text","; 127"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que, ao executar um método estático, você deve delimitar a expressão entre parênteses, como se estivesse executando uma função Clojure. Ao acessar o valor de um campo, você não utiliza parênteses, como se você estivesse acessando um "],["italic",["text","var"]],["text"," ou um "],["italic",["text","binding"]],["text"," qualquer."],["br"]],["index",["text","import"]],["paragraph",["br"]],["paragraph",["text","Você deve concordar que está chato ter que escrever o nome do pacote toda vez que você precisar instanciar a classe. Felizmente existe uma forma importar a classe para que não seja necessário informar o pacote, parecida com o "],["monospaced",["text","import"]],["text"," do Java."],["br"]],["paragraph",["text","Basta usar, adivinhe, "],["monospaced",["text","import"]],["text"," e o nome completo da classe. Atenção para o sinal de "],["monospaced",["text","quote"]],["text"," antes do nome da classe."],["br"]],["code","clojure",["br"],["code-text","(import 'java.awt.Point)"],["br"],["code-text","(new Point)"],["br"],["code-text","; #<Point java.awt.Point[x=0,y=0]>"],["br"],["code-text","(Point.)"],["br"],["code-text","; #<Point java.awt.Point[x=0,y=0]>"],["br"]],["paragraph",["br"]],["paragraph",["text","Essa forma de importar uma classe Java, utilizando o operador "],["monospaced",["text","import"]],["text"," é usada normalmente dentro do "],["italic",["text","REPL"]],["text",". Para utilizarmos num código fonte, recomendo que você use a forma "],["monospaced",["text",":import"]],["text",", com dois-pontos, como opção da forma "],["monospaced",["text","ns"]],["text",". Veremos um exemplo assim mais para frente."],["br"]],["index",["text","java.util.Calendar"]],["paragraph",["br"]],["paragraph",["text","Agora vamos pegar como exemplo um código Java que acesse um método de um objeto retornado por outro método e assim por diante. Vamos usar a classe "],["monospaced",["text","Calendar"]],["text"," para extrair a data e hora atuais. O comando é longo intencionalmente, para demonstrarmos diferentes formas de efetuar essas chamadas encadeadas."],["br"]],["code","java",["br"],["code-text","// foram removidas as declarações de classes e"],["br"],["code-text","// métodos para simplificar o código"],["br"],["code-text","System.out.println(Calendar.getInstance().getTime().toString());"],["br"],["code-text","// Sat Jul 26 00:10:17 BRT 2014"],["br"]],["paragraph",["br"]],["paragraph",["text","Podemos escrever o mesmo código em Clojure usando o operador "],["monospaced",["text","."]],["text",", que já conhecemos."],["br"]],["code","clojure",["br"],["code-text","(import 'java.util.Calendar)"],["br"],["code-text","(.toString (.getTime (Calendar/getInstance)))"],["br"],["code-text","; \"Sat Jul 26 16:40:43 BRT 2014\""],["br"],["code-text","(. (. (Calendar/getInstance) getTime) toString)"],["br"],["code-text","; \"Sat Jul 26 16:41:27 BRT 2014\""],["br"]],["paragraph",["br"]],["index",["text",".."]],["paragraph",["br"]],["paragraph",["text","A segunda forma fica mais difícil de ler e de escrever, mas existe um pouco operador que simplifica essas chamadas encadeadas. Vamos reescrever a expressão usando o operador "],["monospaced",["text",".."]],["text",", que existe exatamente para isso."],["br"]],["code","clojure",["br"],["code-text","(.. (Calendar/getInstance) getTime toString)"],["br"],["code-text","; \"Sat Jul 26 16:43:14 BRT 2014\""],["br"]],["paragraph",["br"]],["paragraph",["text","Você pode também utilizar o operador "],["monospaced",["text","->"]],["text",", que já conhemos, para poder encadear as chamadas de função."],["br"]],["code","clojure",["br"],["code-text","(-> (Calendar/getInstance)"],["br"],["code-text","    .getTime"],["br"],["code-text","    .toString)"],["br"],["code-text","; \"Sat Jul 26 16:47:11 BRT 2014\""],["br"]],["paragraph",["br"]],["paragraph",["text","Essa última forma acaba sendo preferida por ter mais cara de Clojure e diminuir bastante a diferença entre chamadas Java e Clojure."],["br"]],["paragraph",["text","Já que estamos trabalhando com a classe "],["monospaced",["text","Calendar"]],["text",", vamos criar uma data de um jeito propositadamente extenso. Isso vai servir para explicarmos um novo operador. Primeiro vamos olhar o código equivalente em Java. Novamente as declarações de classes e métodos foram removidas."],["br"]],["paragraph",["text","Vamos modificar um objeto "],["monospaced",["text","Calendar"]],["text"," para que ele fique com a data de nascimento de um Gustavo."],["br"]],["code","java",["br"],["code-text","Calendar gustavo = Calendar.getInstance();"],["br"],["code-text","gustavo.set(Calendar.DAY_OF_MONTH, 10);"],["br"],["code-text","gustavo.set(Calendar.MONTH, Calendar.FEBRUARY);"],["br"],["code-text","gustavo.set(Calendar.YEAR, 2010);"],["br"],["code-text","System.out.println(gustavo.getTime().toString());"],["br"],["code-text","// Wed Feb 10 17:02:37 BRST 2010"],["br"]],["paragraph",["br"]],["paragraph",["text","Como um objeto "],["monospaced",["text","Calendar"]],["text"," do Java é mutável, você executa várias operações e modifica um mesmo objeto até que ele esteja da maneira desejada."],["br"]],["paragraph",["text","Em Clojure vamos criar um binding "],["monospaced",["text","gustavo"]],["text"," e sair modificando como se imutabilidade fosse uma preocupação só do Clojure."],["br"]],["paragraph",["text","Bem, na verdade a mutabilidade é sim uma preocupação só do Clojure nesse caso. É uma boa prática isolar toda a parte mutável das suas aplicações em pontos que você possa controlar."],["br"]],["code","clojure",["br"],["code-text","(let [gustavo (Calendar/getInstance)]"],["br"],["code-text","  (.set gustavo Calendar/DAY_OF_MONTH 10)"],["br"],["code-text","  (.set gustavo Calendar/MONTH Calendar/FEBRUARY)"],["br"],["code-text","  (.set gustavo Calendar/YEAR 2010)"],["br"],["code-text","  (.toString (.getTime gustavo)))"],["br"],["code-text","; \"Wed Feb 10 17:07:38 BRST 2010\""],["br"]],["paragraph",["br"]],["index",["text","doto"]],["paragraph",["br"]],["paragraph",["text","Nossos códigos Java e Clojure fazem exatamente a mesma coisa, mas perceba que escrevemos "],["monospaced",["text","gustavo"]],["text"," em cada uma das linhas. Podemos evitar isso usando o operador "],["monospaced",["text","doto"]],["text",". Esse operador simplifica a manipulação de um objeto mutável."],["br"]],["code","clojure",["br"],["code-text","(let [gustavo (doto (Calendar/getInstance)"],["br"],["code-text","                    (.set Calendar/DAY_OF_MONTH 10)"],["br"],["code-text","                    (.set Calendar/MONTH Calendar/FEBRUARY)"],["br"],["code-text","                    (.set Calendar/YEAR 2010))]"],["br"],["code-text","  (.toString (.getTime gustavo)))"],["br"],["code-text","; \"Wed Feb 10 17:24:31 BRST 2010\""],["br"]],["paragraph",["br"]],["index",["text","bean"]],["paragraph",["br"]],["paragraph",["text","Finalmente, temos também o operador "],["monospaced",["text","bean"]],["text",", que recebe um objeto Java qualquer e o converte em um mapa Clojure, com direito a imutabilidade e tudo o que temos direito."],["br"]],["code","clojure",["br"],["code-text","(import 'java.util.Date)"],["br"],["code-text","(def hoje (bean (Date.)))"],["br"],["code-text","hoje"],["br"],["code-text","; {:day 6, :date 26, :time 1406406543872, :month 6,"],["br"],["code-text","   :seconds 3, :year 114, :class java.util.Date,"],["br"],["code-text","   :timezoneOffset 180, :hours 17, :minutes 29}"],["br"],["code-text","(str \"Hoje é dia \" (:date hoje))"],["br"],["code-text","; Hoje é dia 26"],["br"]],["paragraph",["br"]],["section",["text","Entrando na toca do coelho"]],["paragraph",["br"]],["paragraph",["text","Daqui para frente, apenas o "],["italic",["text","REPL"]],["text"," não vai ser suficiente para o que vamos apresentar. Isso acontece porque o código que escrevemos no "],["italic",["text","REPL"]],["text"," é avaliado e compilado em memória, o que não nos deixa ver como as coisas acontecem por baixo dos panos. Por isso vamos criar um projeto bem simples, apenas para brincarmos com a compilação."],["br"]],["paragraph",["text","No terminal do seu sistema operacional, digite "],["monospaced",["text","lein new capitulo08"]],["text",". Ele será a nossa base para os experimentos que vamos fazer."],["br"]],["paragraph",["text","Vamos modificar o arquivo "],["monospaced",["text","project.clj"]],["text",", que está no diretório "],["monospaced",["text","capitulo08"]],["text",", onde podemos encontrar toda a estrutura do projeto, adicionando a opção "],["monospaced",["text",":main capitulo08.core"]],["text",". Nosso arquivo vai ficar com essa cara:"],["br"]],["code","clojure",["br"],["code-text","(defproject capitulo08 \"0.1.0-SNAPSHOT\""],["br"],["code-text","  ;; descricao, url, licença"],["br"],["code-text","  :dependencies [[org.clojure/clojure \"1.7.0\"]]"],["br"],["code-text","  :main capitulo08.core)"],["br"]],["paragraph",["br"]],["paragraph",["italic",["text","Lembrando que a versão do Clojure pode variar de acordo com a época em que você acompanhar os exemplos."]],["br"]],["paragraph",["text","Agora vamos editar o arquivo "],["monospaced",["text","capitulo08/core.clj"]],["text",", conforme o código a seguir."],["br"]],["code","clojure",["br"],["code-text","(ns capitulo08.core)"],["br"],["code-text","(defn ola-mundo []"],["br"],["code-text","  (.println (System/out) \"Olá, mundo!\"))"],["br"],["code-text","(defn -main [& args]"],["br"],["code-text","  (ola-mundo))"],["br"]],["paragraph",["br"]],["paragraph",["text","Criamos uma função chamada "],["monospaced",["text","ola-mundo"]],["text",", que imprime um texto no console, que é chamada pela função principal da nossa pequena aplicação."],["br"]],["paragraph",["text","Ao executarmos a aplicação, veremos a mensagem impressa na tela."],["br"]],["code",["br"],["code-text","lein run"],["br"],["code-text","> Olá, mundo!"],["br"]],["paragraph",["br"]],["paragraph",["text","Até aqui, nada de excepcional."],["br"]],["paragraph",["text","Ainda dentro do diretório "],["monospaced",["text","capitulo08"]],["text",", vamos abrir o "],["italic",["text","REPL"]],["text",". Lembre-se que eu disse que "],["italic",["text","apenas o REPL não seria suficiente"]],["text",", e não que ele não seria mais necessário."],["br"]],["paragraph",["monospaced",["text","lein repl"]],["br"]],["paragraph",["text","Vamos compilar o "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","capitulo08.core"]],["text"," através da função "],["monospaced",["text","compile"]],["text",". Sim, podemos compilar código Clojure dentro do próprio Clojure, forçando a geração de "],["italic",["text","bytecode"]],["text"," Java na hora que bem entendermos."],["br"]],["index",["text","compile"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(compile (symbol \"capitulo08.core\"))"],["br"],["code-text","; capitulo08.core"],["br"],["code-text","exit"],["br"]],["paragraph",["br"]],["paragraph",["text","Após executarmos a compilação, vamos sair do "],["italic",["text","REPL"]],["text"," e, no terminal, vamos entrar no diretório "],["monospaced",["text","target/classes"]],["text"," para listar os arquivos que foram gerados."],["br"]],["paragraph",["text","Dentro deste diretório, temos um diretório "],["monospaced",["text","capitulo08"]],["text",", por causa do "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","capitulo08.core"]],["text"," em que escrevemos nossas funções. Lembre-se de que, assim como acontece com os pacotes Java, os "],["italic",["text","namespaces"]],["text"," do Clojure também são organizados de forma hierárquica, usando árvores de diretórios."],["br"]],["paragraph",["text","Finalmente, dentro do diretório "],["monospaced",["text","capitulo08"]],["text"," temos uma série de arquivos de extensão "],["monospaced",["text","class"]],["text",", que nada mais são do que arquivos contendo "],["italic",["text","bytecode"]],["text"," Java. Quando você compila uma aplicação Java, são gerados os arquivos com a mesma extensão."],["br"]],["paragraph",["text","Recomendo a leitura da excelente série de textos de Nicholas Kariniemi"],["ref",["text","kariniemi-clojure"]],["text"," para que você entenda o porquê de tantos arquivos. Para os propósitos do livro, vamos focar em apenas um deles."],["br"]],["paragraph",["text","Dentre os vários arquivos, temos um chamado "],["monospaced",["text","core$ola_mundo.class"]],["text","."],["br"]],["paragraph",["text","Lembre-se que criamos uma função chamada "],["monospaced",["text","ola-mundo"]],["text"," dentro do "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","capitulo08.core"]],["text"," e que estamos dentro de um diretório chamado "],["monospaced",["text","capitulo08"]],["text",". Com isso podemos concluir que um "],["italic",["text","namespace"]],["text"," Clojure é uma classe contendo classes para cada função."],["br"]],["paragraph",["text","Vamos olhar o que há dentro deste arquivo, usando nossa nova ferramenta preferida, o "],["monospaced",["text","javap"]],["text","."],["br"]],["code","java",["br"],["code-text","$ javap core$ola_mundo.class"],["br"],["code-text","Compiled from \"core.clj\""],["br"],["code-text","public final class capitulo08.core$ola_mundo extends"],["br"],["code-text","clojure.lang.AFunction {"],["br"],["code-text","  public static {};"],["br"],["code-text","  public capitulo08.core$ola_mundo();"],["br"],["code-text","  public java.lang.Object invoke();"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["paragraph",["text","Temos então esse trecho de código "],["monospaced",["text","static"]],["text"," que é executado quando a classe é carregada pela JVM e dois métodos: um construtor e um método "],["monospaced",["text","invoke"]],["text",". Este método "],["monospaced",["text","invoke"]],["text"," é o que contém o código da nossa função, e é invocado sempre que mandamos executar a função no Clojure."],["br"]],["box",["text","Classes internas do Java"],["paragraph",["br"]],["paragraph",["text","Uma classe interna, no Java, é uma classe definida dentro de outras classe. Vamos olhar o código a seguir, ignorando boas práticas para fins de didática, para entendermos como isso funciona."],["br"]],["code","java",["br"],["code-text","public class Ola {"],["br"],["code-text","  private static class Mundo {"],["br"],["code-text","    public void exibirMensagem() {"],["br"],["code-text","      System.out.println(\"Olá mundo\");"],["br"],["code-text","    }"],["br"],["code-text","  }"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que todos os arquivos começam com "],["monospaced",["text","core"]],["text",". Isso acontece porque o Java gera um arquivo "],["monospaced",["text","class"]],["text"," para cada classe, incluindo aí classes internas. Podemos ver isso claramente nos nomes de arquivos que contém o caracter "],["monospaced",["text","$"]],["text","."],["br"]],["paragraph",["text","Temos aqui uma classe "],["monospaced",["text","Ola"]],["text"," que contém uma classe "],["monospaced",["text","Mundo"]],["text",". Ao compilarmos o arquivo "],["monospaced",["text","Ola.java"]],["text",", teremos um arquivo binário chamado "],["monospaced",["text","Ola.class"]],["text",", contendo a classe "],["monospaced",["text","Ola"]],["text",", e um arquivo chamado "],["monospaced",["text","Ola$Mundo.class"]],["text",", contendo a classe interna "],["monospaced",["text","Mundo"]],["text","."],["br"]],["code",["br"],["code-text","$ javac Ola.java"],["br"],["code-text","$ ls"],["br"],["code-text","Ola$Mundo.class  Ola.class  Ola.java"],["br"]],["paragraph",["br"]],["paragraph",["text","Se tivessemos uma classe "],["monospaced",["text","Estranho"]],["text"," dentro da classe interna "],["monospaced",["text","Mundo"]],["text",", o compilador criaria um arquivo "],["monospaced",["text","Ola$Mundo$Estranho.class"]],["text","."],["br"]]],["paragraph",["br"]],["paragraph",["text","A JVM não dá suporte a "],["italic",["text","high order functions"]],["text"," e nem a invocação de funções sem a criação de classes ou objetos. Para dar a volta nessa limitação e podermos ter uma linguagem funcional, internamente cada função do Clojure é implementada como uma classe Java."],["br"]],["paragraph",["text","Caso a função seja anônima, o compilador Clojure vai atribuir o nome "],["monospaced",["text","fn_"]],["text"," seguido de um número aleatório."],["br"]],["paragraph",["text","Enquanto escrevo os exemplos, tenho aqui o arquivo "],["monospaced",["text","core$fn_1209.class"]],["text"," no diretório "],["monospaced",["text","capitulo08"]],["text",", mas o número pode variar na sua máquina."],["br"]],["paragraph",["text","Como o Java permite que você passe objetos por parâmetro e receba objetos como resultado, podemos tratar a execução de uma função como um objeto sem usar qualquer truque que comprometa o tempo de execução."],["br"]],["index",["text","clojure.lang.AFunction"]],["paragraph",["br"]],["paragraph",["text","A nossa classe "],["monospaced",["text","capitulo08.core$ola_mundo"]],["text"," estende a classe "],["monospaced",["text","AFunction"]],["text"," da biblioteca padrão do Clojure. Toda função Clojure deve herdar de "],["monospaced",["text","AFunction"]],["text","."],["br"]],["img",["text","images/capitulo_08/uml_funcao.png \"Diagrama de classes de uma função\" w=95% label=cap08-uml-funcao"]],["paragraph",["br"]],["paragraph",["text","No diagrama "],["ref-label",["text","cap08-uml-funcao"]],["text"," vemos algumas implicações interessantes dessa herança."],["br"]],["index",["text","clojure.lang.AFn"]],["paragraph",["br"]],["index",["text","clojure.lang.IFn"]],["paragraph",["br"]],["index",["text","clojure.lang.Fn"]],["paragraph",["br"]],["paragraph",["text","A primeira é que toda função implementa "],["monospaced",["text","AFunction"]],["text",", "],["monospaced",["text","AFn"]],["text",", "],["monospaced",["text","IFn"]],["text"," e "],["monospaced",["text","Fn"]],["text",", numa clara mostra de amor à herança por parte dos criadores da linguagem."],["br"]],["index",["text","clojure.lang.IObj"]],["paragraph",["br"]],["paragraph",["text","Toda função implementa também a interface "],["monospaced",["text","IObj"]],["text",", que é o pedaço da linguagem responsável por guardar os metadados que vimos no capítulo "],["ref-label",["text","capitulo-dados"]],["text",". Se você quiser que seu objeto Java tenha suporte aos metadados do Clojure, basta implementar esta interface. Vamos ver mais para frente como criar uma classe no Java e utilizá-la no Clojure."],["br"]],["index",["text","java.util.Comparator"]],["paragraph",["br"]],["paragraph",["text","Funções Clojure também implementam a interface Java "],["monospaced",["text","Comparator"]],["text",", o que significa que você pode usá-las como critério de ordenação na "],["italic",["text","API"]],["text"," padrão do Java."],["br"]],["index",["text","java.jang.Runnable"]],["index",["text","thread"]],["paragraph",["br"]],["paragraph",["text","Finalmente, encerrando nosso passeio pela árvore genealógica de uma função Clojure, podemos ver também que toda função implementa "],["monospaced",["text","Runnable"]],["text",", permitindo que seja invocada por uma "],["italic",["text","thread"]],["text"," sem qualquer tipo de truque ou gambiarra."],["br"]],["index",["text","java.util.concurrent.Callable"]],["index",["text","future"]],["paragraph",["br"]],["paragraph",["text","As funções implementam também a interface "],["monospaced",["text","Callable"]],["text",", que é a irmã mais nova de "],["monospaced",["text","Runnable"]],["text",", cuja principal diferença é retornar um valor quando usamos "],["italic",["text","futures"]],["text","."],["br"]],["paragraph",["text","Os conceitos de "],["italic",["text","futures"]],["text"," e "],["italic",["text","threads"]],["text"," serão explicados em detalhes no capítulo "],["ref-label",["text","capitulo-concorrencia"]],["text","."],["br"]],["paragraph",["text","Voltando ao nosso arquivo, se olharmos o "],["italic",["text","bytecode"]],["text"," gerado para o método "],["monospaced",["text","invoke"]],["text",", vamos avaliar o que o Clojure gera durante sua compilação para tirarmos de uma vez por todas a aura de mágica e bruxaria."],["br"]],["paragraph",["text","Vou tomar a liberdade de quebrar o resultado em vários trechos para que seja possível explicar cada um deles."],["br"]],["paragraph",["text","Note que dessa vez vamos usar o parâmetro "],["monospaced",["text","-c"]],["text",", que exibe os mnemônicos contidos em cada método."],["br"]],["code","java",["br"],["code-text","$ javap -c core$ola_mundo.class"],["br"],["code-text","public final class capitulo08.core$ola_mundo extends"],["br"],["code-text","clojure.lang.AFunction {"],["br"]],["paragraph",["br"]],["paragraph",["text","Toda classe Java contém uma área de declaração de constantes. Essas constantes são numeradas. Vamos listar as contantes aqui para explicar em seguida."],["br"]],["code","java",["br"],["code-text","// #10 Method clojure/lang/AFunction.\"<init>\":()V"],["br"],["code-text","// #18 Field java/lang/System.out:Ljava/io/PrintStream;"],["br"],["code-text","// #20 class java/io/PrintStream"],["br"],["code-text","// #22 String Olá, mundo!"],["br"],["code-text","// #24 class java/lang/String"],["br"],["code-text","// #28 Method java/io/PrintStream.println:(Ljava/lang/String;)V"],["br"]],["paragraph",["br"]],["paragraph",["text","Inicialmente temos um bloco "],["monospaced",["text","static"]],["text",", que é executado na primeira vez que a classe for carregada pela JVM. Em seguida temos o construtor da classe "],["monospaced",["text","ola_mundo"]],["text",", que nada mais faz do que invocar o construtor de sua classe mãe. Esse código pode ser interpretado como "],["monospaced",["text","super()"]],["text"," em Java."],["br"]],["code","java",["br"],["code-text","  public static {};"],["br"],["code-text","    Code:"],["br"],["code-text","       0: return"],["br"],["code-text","  public capitulo08.core$ola_mundo();"],["br"],["code-text","    Code:"],["br"],["code-text","       0: aload_0"],["br"],["code-text","       1: invokespecial #10"],["br"],["code-text","       4: return"],["br"]],["paragraph",["br"]],["paragraph",["text","E chegamos a função "],["monospaced",["text","invoke"]],["text",". A linha "],["italic",["text","0"]],["text"," carrega o objeto "],["monospaced",["text","System.out"]],["text",", a linha "],["italic",["text","6"]],["text"," carrega o texto "],["italic",["text","Olá, mundo!"]],["text"," e a linha "],["italic",["text","11"]],["text"," invoca o método "],["monospaced",["text","println"]],["text"," do objeto "],["monospaced",["text","System.out"]],["text"," usando o texto "],["italic",["text","Olá, mundo!"]],["text"," como parâmetro."],["br"]],["code","java",["br"],["code-text","  public java.lang.Object invoke();"],["br"],["code-text","    Code:"],["br"],["code-text","       0: getstatic     #18"],["br"],["code-text","       3: checkcast     #20"],["br"],["code-text","       6: ldc           #22"],["br"],["code-text","       8: checkcast     #24"],["br"],["code-text","      11: invokevirtual #28"],["br"],["code-text","      14: aconst_null"],["br"],["code-text","      15: areturn"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["paragraph",["text","Tudo isso, de forma bem resumida, significa que executamos "],["monospaced",["text","System.out.println(\"Olá, mundo!\")"]],["text",". Se você escrever esse código em Java e comparar os "],["italic",["text","bytecodes"]],["text",", vai ver exatamente a mesma sequencia de instruções, com exceção dos números das constantes, que podem variar de acordo com o tamanho do código e a ordem das declarações."],["br"]],["paragraph",["text","As linhas "],["italic",["text","14"]],["text"," e "],["italic",["text","15"]],["text"," simplesmente equivalem a um "],["monospaced",["text","return null"]],["text",", já que nossa função não retorna valor algum."],["br"]],["section",["text","Compilação Ahead-of-time"]],["paragraph",["br"]],["paragraph",["text","Por padrão, o Clojure compila o código e a JVM carrega os "],["italic",["text","bytecodes"]],["text"," gerados sem a necessidade de arquivos "],["monospaced",["text","class"]],["text",". Isso permite que você recarregue ou substitua partes do código em tempo de execução, como vimos no capítulo sobre funções."],["br"]],["paragraph",["text","Esse modo, esquematizado na figura "],["ref-label",["text","cap08-dynamic-compilation"]],["text",", é chamado de "],["italic",["text","compilação dinâmica"]],["text",", e só acontece quando o código é utilizado ou referenciado."],["br"]],["img",["text","images/capitulo_08/clojure_dynamic_compilation.png \"Compilação dinâmica\" w=95% label=cap08-dynamic-compilation"]],["paragraph",["br"]],["paragraph",["text","Enquanto isso traz uma série de benefícios em termos de flexibilidade e dinamismo, existem situações em que é necessário ter os arquivos já compilados antes mesmo da aplicação ser executada."],["br"]],["paragraph",["text","Isso acontece quando você não quer, ou não pode, fornecer os fontes da aplicação, ou quando existe código Java que faz uso do seu código Clojure."],["br"]],["paragraph",["text","Ao contrário do que possa parecer, pré-compilar sua aplicação não a torna necessariamente mais rápida. Pode ocorrer um pequeno ganho durante a carga da aplicação, mas na prática o que acontece é a alteração do momento em que o código é compilado."],["br"]],["paragraph",["text","Essa pré-compilação é chamada de "],["italic",["text","compilação ahead-of-time"]],["text",", ou simplesmente "],["italic",["text","AOT"]],["text",". Como o nome diz, é uma compilação \"antes da hora\", mas a forma como o código é carregado pelo Clojure permanece a mesma."],["br"]],["img",["text","images/capitulo_08/clojure_aot_compilation.png \"Compilação AOT\" w=95% label=cap08-aot-compilation"]],["paragraph",["br"]],["paragraph",["text","Vamos criar um novo projeto para demonstrarmos quando a compilação ocorre com e sem "],["italic",["text","AOT"]],["text"," e também para aprendermos a configurar o projeto para utilizar esse recurso. A sequencia de comandos a seguir deve ser digitada no terminal do seu sistema operacional."],["br"]],["code",["br"],["code-text","lein new aot"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos editar o arquivo "],["monospaced",["text","project.clj"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(defproject aot \"0.1.0-SNAPSHOT\""],["br"],["code-text","  :dependencies [[org.clojure/clojure \"1.7.0\"]]"],["br"],["code-text","  :main aot.core)"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que a versão do Clojure pode variar."],["br"]],["paragraph",["text","Em seguida vamos modificar o arquivo "],["monospaced",["text","src/aot/core.clj"]],["text"," criando uma macro e a função "],["monospaced",["text","-main"]],["text",". A ideia aqui é mostrarmos o momento em que ocorre o tempo de compilação."],["br"]],["code","clojure",["br"],["code-text","(ns aot.core)"],["br"],["code-text","(defmacro uma-macro []"],["br"],["code-text","  (println \"Compilando\"))"],["br"],["code-text","(defn -main [& args]"],["br"],["code-text","  (uma-macro)"],["br"],["code-text","  (println \"Tempo de execução\"))"],["br"]],["paragraph",["br"]],["paragraph",["text","A macro "],["monospaced",["text","uma-macro"]],["text"," será executada em tempo de compilação e a função "],["monospaced",["text","-main"]],["text"," será executada em tempo de execução. Veremos macros e fases de execução da aplicação com detalhes no capítulo "],["ref-label",["text","capitulo-macros"]],["text",". O propósito desse exemplo é demonstrar como o momento da compilação muda de lugar, mas continua existindo."],["br"]],["paragraph",["text","Agora vamos executar nosso exemplo executando "],["monospaced",["text","lein run"]],["text"," no terminal:"],["br"]],["code",["br"],["code-text","$ lein run"],["br"],["code-text","> Compilando"],["br"],["code-text","> Tempo de execução"],["br"]],["paragraph",["br"]],["paragraph",["text","Aqui não temos novidade. Mandamos executar a aplicação, ela foi compilada e em seguida executada."],["br"]],["paragraph",["text","Vamos agora habilitar a compilação "],["italic",["text","AOT"]],["text"," adicionando a última linha no arquivo "],["monospaced",["text","project.clj"]],["br"]],["code","clojure",["br"],["code-text","(defproject aot \"0.1.0-SNAPSHOT\""],["br"],["code-text","  :dependencies [[org.clojure/clojure \"1.7.0\"]]"],["br"],["code-text","  :main aot.core"],["br"],["code-text","  :aot :all)"],["br"]],["paragraph",["br"]],["paragraph",["text","A opção "],["monospaced",["text",":aot :all"]],["text"," diz que devemos compilar previamente todos os "],["italic",["text","namespaces"]],["text"," da nossa aplicação."],["br"]],["paragraph",["text","Agora vamos adicionar a opção "],["monospaced",["text",":gen-class"]],["text"," na declaração de "],["italic",["text","namespaces"]],["text"," de "],["monospaced",["text","aot.core"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(ns aot.core"],["br"],["code-text","  (:gen-class))"],["br"],["code-text",";; e aqui vem o restante do código"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos então executar "],["monospaced",["text","lein uberjar"]],["text"," para compilar e gerar um pacote "],["monospaced",["text","JAR"]],["text"," sem executar a nossa aplicação. Um pacote "],["monospaced",["text","JAR"]],["text"," é um arquivo compactado contendo arquivos compilados em "],["italic",["text","bytecode"]],["text"," Java."],["br"]],["code",["br"],["code-text","$ lein uberjar"],["br"],["code-text","> Compiling aot.core"],["br"],["code-text","> Compilando"],["br"],["code-text","> Created /target/aot-0.1.0-SNAPSHOT.jar"],["br"],["code-text","> Created /target/aot-0.1.0-SNAPSHOT-standalone.jar"],["br"]],["paragraph",["br"]],["paragraph",["text","Na primeira linha vemos que "],["monospaced",["text","aot.core"]],["text"," está sendo compilado. A mensagem "],["italic",["text","Compilando"]],["text",", que está dentro da macro  "],["monospaced",["text","uma-macro"]],["text"," comprova isso. Em seguida são criados dois arquivos "],["italic",["text","JAR"]],["text",": um contendo apenas a aplicação e outro contendo a aplicação e os binários do próprio Clojure, permitindo que a aplicação seja executada sem termos que nos preocupar se o Clojure está instalado ou não."],["br"]],["paragraph",["text","Agora vamos executar como um arquivo binário Java qualquer. Lembre-se de não digitar o caracter "],["monospaced",["text","$"]],["text",". Ele representa o prompt do terminal:"],["br"]],["code",["br"],["code-text","$ java -jar target/aot-0.1.0-SNAPSHOT-standalone.jar"],["br"],["code-text","> Tempo de execução"],["br"]],["paragraph",["br"]],["paragraph",["text","Aqui vimos apenas a mensagem "],["italic",["text","Tempo de execução"]],["text"," e não vemos mais a mensagem "],["italic",["text","Compilando"]],["text",". Com isso fica claro que a compilação já ocorreu ao compilarmos o código e gerarmos os arquivos "],["italic",["text","JAR"]],["text","."],["br"]],["paragraph",["text","Durante o tempo de execução temos apenas código sendo executado, sem qualquer sinal de compilação. Na prática é como uma aplicação escrita em Java puro funciona."],["br"]],["section",["text","Criando classes Java dentro do Clojure"]],["paragraph",["br"]],["paragraph",["text","Fazendo uso de "],["monospaced",["text","gen-class"]],["text"," podemos criar uma classe Java dentro do próprio Clojure."],["br"]],["paragraph",["text","Para isso vamos criar um arquivo "],["monospaced",["text","src/gen.clj"]],["text"," dentro desse projeto "],["monospaced",["text","aot"]],["text"," e vamos declarar o "],["italic",["text","namespace"]],["text"," dessa forma:"],["br"]],["code","clojure",["br"],["code-text","(ns capitulo08.gen"],["br"],["code-text","  (:gen-class"],["br"],["code-text","    :name \"capitulo08.Uia\""],["br"],["code-text","    :methods [[hello [] void]]))"],["br"]],["paragraph",["br"]],["paragraph",["text","A opção "],["monospaced",["text",":name"]],["text"," informa ao compilador que queremos criar uma classe Java com um diferente do "],["italic",["text","namespace"]],["text"," atual. Aqui nossa classe vai se chamar "],["monospaced",["text","Uia"]],["text",", e estará em um pacote chamado "],["monospaced",["text","capitulo08"]],["text","."],["br"]],["paragraph",["text","Vamos dizer também que queremos que um objeto do tipo "],["monospaced",["text","Uia"]],["text"," tenha um método chamado "],["monospaced",["text","hello"]],["text",". Vamos informar que ele não recebe nenhum parâmetro passando um vetor vazio."],["br"]],["paragraph",["text","Se quiséssemos parâmetros, bastaria informarmos nesse vetor. Por fim, vamos dizer que esse método é do tipo "],["monospaced",["text","void"]],["text","."],["br"]],["paragraph",["text","Para criarmos nosso método "],["monospaced",["text","hello"]],["text",", basta o código abaixo:"],["br"]],["code","clojure",["br"],["code-text","(defn -hello [this]"],["br"],["code-text","  (println \"Olá!\"))"],["br"]],["paragraph",["br"]],["paragraph",["text","Primeiro, note que existe um "],["monospaced",["text","-"]],["text"," antes do nome da função. Esse é o prefixo padrão para informarmos ao Clojure que aquela função deve ser utilizada na criação do objeto. Qualquer função sem o prefixo vai ser considerado um código comum do Clojure e desconsiderado para a criação do objeto."],["br"]],["paragraph",["text","Mais para frente vamos aprender a modificar esse prefixo."],["br"]],["paragraph",["text","Note também que passâmos um parâmetro "],["monospaced",["text","this"]],["text","."],["br"]],["paragraph",["text","Todo método implementado num objeto criado com "],["monospaced",["text","gen-class"]],["text"," precisa receber por parâmetro uma referência a si mesmo. Dessa forma poderemos modificar ou acessar os dados encapsulados. Vamos chamar esse parâmetro de "],["monospaced",["text","this"]],["text"," apenas por convenção."],["br"]],["paragraph",["text","Agora vamos abrir o "],["italic",["text","REPL"]],["text"," e mandar compilar nosso novo "],["italic",["text","namespace"]],["text"," usando o operador "],["monospaced",["text","compile"]],["text","."],["br"]],["index",["text","compile"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(compile (symbol \"capitulo08.gen\"))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos importar nossa classe e criar um objeto, chamando o método "],["monospaced",["text","hello"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(import 'capitulo08.Uia)"],["br"],["code-text","(.hello (Uia.))"],["br"],["code-text","; Olá!"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que nosso método "],["monospaced",["text","hello"]],["text"," não usa nenhuma informação do próprio objeto. Podemos então transformá-lo num método estático, ou método de classe."],["br"]],["paragraph",["text","Para isso, basta adicionar a anotação "],["monospaced",["text","#^{:static true}"]],["text"," na declaração do método. Até a versão utilizada para escrever esse livro, a versão curta "],["monospaced",["text","^static"]],["text"," não estava funcionando."],["br"]],["code","clojure",["br"],["code-text","(ns capitulo08.gen"],["br"],["code-text","  (:gen-class"],["br"],["code-text","    :name \"capitulo08.Uia\""],["br"],["code-text","    :methods [#^{:static true} [hello [] void]]))"],["br"]],["paragraph",["br"]],["paragraph",["text","E o resto do código continua igual, com exceção do parâmetro "],["monospaced",["text","this"]],["text",", que não é mais necessário."],["br"]],["code","clojure",["br"],["code-text","(defn -hello []"],["br"],["code-text","  (println \"Olá!\"))"],["br"],["code-text","(capitulo08.Uia/hello)"],["br"],["code-text","; Olá!"],["br"]],["paragraph",["br"]],["paragraph",["text","Se você achar que esse "],["monospaced",["text","-"]],["text"," não é suficiente para deixar explícito que estamos implementando um método, você pode mudar o prefixo usando a opção "],["monospaced",["text",":prefix"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(ns capitulo08.gen"],["br"],["code-text","  (:gen-class"],["br"],["code-text","    :name \"capitulo08.Uia\""],["br"],["code-text","    :methods [#^{:static true} [hello [] void]]"],["br"],["code-text","    :prefix \"method-\"))"],["br"],["code-text","(defn method-hello []"],["br"],["code-text","  (println \"Olá!\"))"],["br"],["code-text","(capitulo08.Uia/hello)"],["br"],["code-text","; Olá!"],["br"]],["paragraph",["br"]],["paragraph",["text","O compilador vai procurar por todas as funções cujo nome começam com o texto informado na opção "],["monospaced",["text",":prefix"]],["text"," para associar aos métodos da classe que estamos criando."],["br"]],["section",["text","Estendendo classes e implementando interfaces"]],["paragraph",["br"]],["paragraph",["text","Nós podemos estender classes e implementar interfaces Java usando código Clojure. Para isso usamos a opção "],["monospaced",["text",":gen-class"]],["text"," ao declararmos o nosso "],["italic",["text","namespace"]],["text","."],["br"]],["paragraph",["text","Dessa forma, as funções que estão dentro do "],["italic",["text","namespace"]],["text"," podem fazer parte do objeto que estamos criando."],["br"]],["paragraph",["text","Vamos criar um novo projeto chamado "],["monospaced",["text","genclass"]],["text"," e modificar o "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","genclass.core"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(ns genclass.core"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos dizer ao compilador que este "],["italic",["text","namespace"]],["text"," vai gerar "],["italic",["text","bytecode"]],["text"," Java em disco numa classe chamada "],["monospaced",["text","genclass.MeuNumero"]],["text"," ."],["br"]],["code","clojure",["br"],["code-text","  (:gen-class"],["br"],["code-text","    :name genclass.MeuNumero"],["br"]],["paragraph",["br"]],["index",["text","java.lang.Number"]],["paragraph",["br"]],["paragraph",["text","E então vamos dizer que a classe "],["monospaced",["text","genclass.MeuNumero"]],["text"," estende a classe "],["monospaced",["text","java.lang.Number"]],["text","."],["br"]],["code","clojure",["br"],["code-text","    :extends java.lang.Number))"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos rechear o método "],["monospaced",["text","-main"]],["text"," com uma mensagem engraçadinha:"],["br"]],["code","clojure",["br"],["code-text","(defn -main [& args]"],["br"],["code-text","  (println \"Vá brincar no REPL\"))"],["br"]],["paragraph",["br"]],["box",["text","Classes abstratas e interfaces"],["paragraph",["br"]],["paragraph",["text","Caso você não tenha intimidade com Java, vamos dar uma revisada no que são classes abstratas e interfarces."],["br"]],["paragraph",["text","Uma classe abstrata não pode ser instanciada diretamente. Você deve criar uma classe filha que implemente qualquer método abstrato que a classe mãe tenha, e só então essa classe filha, caso também não seja abtrata, pode ser instanciada."],["br"]],["paragraph",["text","Uma classe que não é declarada como abstrata e não tem nenhum método sem implementação é chamada de "],["italic",["text","classe concreta"]],["text","."],["br"]],["paragraph",["text","Uma interface funciona como uma classe abstrata, mas contém apenas declarações de métodos, campos, constantes e enumerações e deve ser implementada por uma classe ou estendida por outra interface para ser usada. Essa classe pode ser abstrata ou concreta."],["br"]],["paragraph",["text","Uma classe Java só pode "],["italic",["text","estender"]],["text"," uma classe, abstrata ou não, mas pode "],["italic",["text","implementar"]],["text"," tantas interfaces quantas forem necessárias."],["br"]]],["paragraph",["br"]],["paragraph",["text","Recapitulando, nosso código inteiro ficou assim:"],["br"]],["code","clojure",["br"],["code-text","(ns genclass.core"],["br"],["code-text","  (:gen-class"],["br"],["code-text","    :name genclass.MeuNumero"],["br"],["code-text","    :extends java.lang.Number))"],["br"],["code-text","(defn -main [& args]"],["br"],["code-text","  (println \"Vá brincar no REPL\"))"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos brincar no REPL instanciando um objeto do tipo "],["monospaced",["text","MeuNumero"]],["text",". É um objeto vazio que acabamos de criar com nosso código. Sendo uma instância de um objeto que estende "],["monospaced",["text","java.lang.Number"]],["text",", podemos usar "],["monospaced",["text","MeuNumero"]],["text"," em qualquer operação matemática do Clojure."],["br"]],["code","clojure",["br"],["code-text","(def meu-numero (genclass.MeuNumero.))"],["br"],["code-text","meu-numero"],["br"],["code-text","; genclass.MeuNumero@19e9bbfe"],["br"],["code-text","(+ 42 meu-numero)"],["br"],["code-text","; AbstractMethodError java.lang.Number.longValue()J"],["br"],["code-text","; genclass.MeuNumero.longValue (:-1)"],["br"]],["paragraph",["br"]],["paragraph",["text","Como objeto vazio, não é nem um pouco útil, mas podemos melhorar. Vamos fazer com que esse número retorne automaticamente seu valor em hexadecimal ou receba um hexadecimal como valor inicial."],["br"]],["paragraph",["text","Vamos começar criando dois construtores para a classe: uma que recebe um inteiro longo e outro que recebe um texto."],["br"]],["paragraph",["text","Vamos implementar o método "],["monospaced",["text","longValue"]],["text",", que vai ser utilizado na operação de soma, e também o método "],["monospaced",["text","toString"]],["text",", que vai ser utilizado para exibirmos o valor do objeto no "],["italic",["text","REPL"]],["text","."],["br"]],["paragraph",["text","A classe "],["monospaced",["text","Number"]],["text"," disponibiliza um método para cada tipo primitivo numérico, mas vamos nos ater em trabalhar apenas com o tipo "],["monospaced",["text","long"]],["text","."],["br"]],["paragraph",["text","Para informar que vamos trabalhar com dois construtores vamos modificar a declaração do "],["italic",["text","namespace"]],["text",", na opção "],["monospaced",["text",":ns"]],["text",". Não é necessário informar que vamos implementar os métodos "],["monospaced",["text","longValue"]],["text"," ou "],["monospaced",["text","toString"]],["text",", já que eles já foram declarados nas classes-mãe "],["monospaced",["text","Number"]],["text"," e "],["monospaced",["text","Object"]],["text",", respectivamente."],["br"]],["code","clojure",["br"],["code-text","(ns genclass.core"],["br"],["code-text","  (:gen-class"],["br"],["code-text","    :name         genclass.MeuNumero"],["br"],["code-text","    :extends      java.lang.Number"],["br"],["code-text","    :constructors {[String] []"],["br"],["code-text","                   [Long]   []}"],["br"],["code-text","    :init         init"],["br"],["code-text","    :state        value))"],["br"]],["paragraph",["br"]],["paragraph",["text","A opção "],["monospaced",["text",":constructors"]],["text"," mapeia os tipos de parâmetros do construtor da nossa classe e os tipos de parâmetros do construtor da classe mãe. Como o construtor de "],["monospaced",["text","Number"]],["text"," não recebe parâmetros, nossos dois construtores vão mapear, respectivamente, "],["monospaced",["text","String"]],["text"," e "],["monospaced",["text","Long"]],["text"," para um vetor vazio."],["br"]],["paragraph",["text","Sempre que utilizarmos a opção "],["monospaced",["text",":construtors"]],["text"," devemos também informar a opção "],["monospaced",["text",":init"]],["text",", que vai informar ao Clojure qual função deve ser utilizada para inicializar o objeto."],["br"]],["paragraph",["text","Não se preocupe com a opção "],["monospaced",["text",":state"]],["text",". Já vamos chegar nela."],["br"]],["paragraph",["text","Vamos implementar a função "],["monospaced",["text","-init"]],["text"," para tratarmos os diferentes tipos de dados que podem ser utilizados na inicialização do objeto."],["br"]],["index",["text","type"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(defn -init [value]"],["br"],["code-text","  (println \"O valor informado foi\" (type value) value))"],["br"]],["paragraph",["br"]],["paragraph",["text","Aqui a nossa função de inicialização apenas exibe o tipo e o valor do parâmetro que foi passado na criação do objeto."],["br"]],["code","clojure",["br"],["code-text","(genclass.MeuNumero. 12)"],["br"],["code-text","; O valor informado foi java.lang.Long 12"],["br"],["code-text","; genclass.MeuNumero@436d3c34"],["br"],["code-text","(genclass.MeuNumero. \"12\")"],["br"],["code-text","; O valor informado foi java.lang.String 12"],["br"],["code-text","; genclass.MeuNumero@7bf2fa73"],["br"]],["paragraph",["br"]],["paragraph",["text","Funcionou bem com "],["monospaced",["text","Long"]],["text"," e "],["monospaced",["text","String"]],["text",". Se tentarmos passar qualquer outro tipo de dados, receberemos uma mensagem de erro."],["br"]],["code","clojure",["br"],["code-text","(genclass.MeuNumero. true)"],["br"],["code-text","; IllegalArgumentException No matching ctor found for class"],["br"],["code-text","; genclass.MeuNumero  clojure.lang.Reflector.invokeConstructor"],["br"],["code-text","; (Reflector.java:183)"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos escrever algum código para tratarmos e armazenarmos nosso número."],["br"]],["code","clojure",["br"],["code-text","(defn -init [value]"],["br"],["code-text","  (if (= (type value) java.lang.String)"],["br"],["code-text","    [[] (Long/parseLong value 16)]"],["br"],["code-text","    [[] value]))"],["br"]],["paragraph",["br"]],["paragraph",["text","Nossa função verifica se o valor recebido na inicialização é do tipo "],["monospaced",["text","String"]],["text"," e, se for, converte para "],["monospaced",["text","Long"]],["text",". Caso contrário retorna o próprio valor como "],["monospaced",["text","Long"]],["text",", já que nenhum outro tipo é permitido."],["br"]],["paragraph",["text","Percebe que os valores estão sendo retornados dentro de um vetor de duas posições. A primeira posição é o valor a ser passado para o construtor da classe mãe. Como o construtor de "],["monospaced",["text","Number"]],["text"," não recebe qualquer parâmetro, basta passarmos um vetor vazio."],["br"]],["paragraph",["text","Já a segunda posição do vetor guarda o valor a ser armazenado em "],["monospaced",["text","value"]],["text",", que declaramos como na opção "],["monospaced",["text",":state"]],["text",". Esse campo "],["monospaced",["text","value"]],["text"," é justamente o estado do objeto que estamos criando e não pode ser alterado depois da criação do objeto."],["br"]],["paragraph",["text","Vamos ver nosso código funcionando na prática com o que fizemos até agora."],["br"]],["code","clojure",["br"],["code-text","(def deci (genclass.MeuNumero. 15))"],["br"],["code-text","deci"],["br"],["code-text","; genclass.MeuNumero@303034c1"],["br"],["code-text","(def hexa (genclass.MeuNumero. \"1f\"))"],["br"],["code-text","hexa"],["br"],["code-text","; genclass.MeuNumero@1ec877d9"],["br"]],["paragraph",["br"]],["paragraph",["text","Certo, não deu erro, mas ainda não faz nada de útil. Vamos então implementar "],["monospaced",["text","toString"]],["text",", que vai retornar a representação hexadecimal do nosso número."],["br"]],["paragraph",["text","Note que "],["monospaced",["text","toString"]],["text"," precisa ter o prefixo, que por padrão é "],["monospaced",["text","-"]],["text",", e também uma referência ao próprio objeto, que aqui vamos continuar chamando de "],["monospaced",["text","this"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn -toString [this]"],["br"],["code-text","  (Long/toHexString (.value this)))"],["br"]],["paragraph",["br"]],["paragraph",["text","Como dissemos, ao declarar "],["monospaced",["text","value"]],["text"," na opção "],["monospaced",["text",":state"]],["text",", criamos um campo privado com este nome dentro de nosso objeto. Ele contém o valor inteiro longo atribuido na inicialização do objeto."],["br"]],["paragraph",["text","Vamos usar o método "],["monospaced",["text","toHexString"]],["text"," da classe "],["monospaced",["text","Long"]],["text"," para convertermos o valor numérico em hexadecimal e concluímos o código de "],["monospaced",["text","toString"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def deci (genclass.MeuNumero. 15))"],["br"],["code-text","deci"],["br"],["code-text","; 1f"],["br"],["code-text","(def hexa (genclass.MeuNumero. \"1f\"))"],["br"],["code-text","hexa"],["br"],["code-text","; 1f"],["br"]],["paragraph",["br"]],["paragraph",["text","Falta darmos suporte a operações matemáticas. A classe abstrata "],["monospaced",["text","Number"]],["text"," define seis métodos para seis tipos numéricos diferentes ("],["italic",["text","byte"]],["text",", "],["italic",["text","float"]],["text",", "],["italic",["text","double"]],["text",", "],["italic",["text","short"]],["text",", "],["italic",["text","int"]],["text"," e "],["italic",["text","long"]],["text","). Vamos nos ater apenas ao tipo inteiro para não deixar a explicação maior do que deveria ser."],["br"]],["paragraph",["text","Num objeto do mundo real você não pode deixar nenhum método abstrato sem implementação, correndo o risco de causar um erro durante a execução da sua aplicação."],["br"]],["paragraph",["text","O método que retorna o tipo "],["monospaced",["text","long"]],["text"," chama-se "],["monospaced",["text","longValue"]],["text",". Vamos declará-lo da mesma forma que fizemos com "],["monospaced",["text","toString"]],["text",", usando o prefixo "],["monospaced",["text","-"]],["text"," e o parâmetro "],["monospaced",["text","this"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn -longValue [this]"],["br"],["code-text","  (.value this))"],["br"]],["paragraph",["br"]],["paragraph",["text","Sem dúvida, um dos códigos mais complexos que já escrevemos até agora."],["br"]],["paragraph",["text","Vamos testar nosso objeto em uma operação aritmética qualquer:"],["br"]],["code","clojure",["br"],["code-text","(let [val1 (genclass.MeuNumero. \"1ff\")"],["br"],["code-text","      val2 (genclass.MeuNumero. \"e00\")]"],["br"],["code-text","  (+ val1 val2))"],["br"],["code-text","; 4095"],["br"],["code-text",";; 4095 em hexadecimal é fff, o mesmo que 1ff + e00"],["br"]],["paragraph",["br"]],["paragraph",["text","E eis o nosso objeto participando de uma soma, tranquilão e feliz."],["br"]],["title",["text","E as interfaces?"]],["paragraph",["br"]],["paragraph",["text","Foi dito também que, além de estender uma classe, é possívem implementar interfaces. É possível inclusive mesclar os dois recursos num mesmo objeto, assim como acontece numa classe Java qualquer."],["br"]],["paragraph",["text","Vamos utilizar o mesmo projeto "],["monospaced",["text","genclass"]],["text"," para demonstrar como implementar a interface "],["monospaced",["text","clojure.lang.IDeref"]],["text",", que é usada para definir estruturas de dados que retornem valor através dos operadores "],["monospaced",["text","@"]],["text"," ou "],["monospaced",["text","deref"]],["text","."],["br"]],["paragraph",["text","Vamos adicionar a opção "],["monospaced",["text",":implements"]],["text"," na opção "],["monospaced",["text",":gen-class"]],["text"," e, em seguida, informar em uma lista as interfaces que pretendemos implementar."],["br"]],["paragraph",["text","Lembre-se de informar as interfaces dentro de uma lista. Se você usar "],["monospaced",["text","quote"]],["text",", teremos um erro de compilação. Se usar vetor, não ocorrerá um erro, mas a opção "],["monospaced",["text",":implements"]],["text"," será ignorada."],["br"]],["todo",["text","verificar isso aqui"]],["paragraph",["br"]],["paragraph",["text","Apesar da documentação dizer que qualquer coleção serve, apenas a lista funciona corretamente nessa opção. Testei com as versões "],["monospaced",["text","1.5.1"]],["text",", "],["monospaced",["text","1.6.0"]],["text"," e "],["monospaced",["text","1.7.0"]],["text",", mas nada impede que isso volte a funcionar como é dito na documentação em alguma versão futura."],["br"]],["code","clojure",["br"],["code-text","(ns aot.core"],["br"],["code-text","  (:gen-class"],["br"],["code-text","    :name         aot.MeuNumero"],["br"],["code-text","    :extends      java.lang.Number"],["br"],["code-text","    :implements   (clojure.lang.IDeref) ; lista sem quote ou '"],["br"],["code-text","    :qualquercoisa true"],["br"],["code-text","    :constructors {[String] []"],["br"],["code-text","                   [Long]   []}"],["br"],["code-text","    :init         init"],["br"],["code-text","    :state        value))"],["br"]],["paragraph",["br"]],["paragraph",["text","A declaração permaneceu praticamente a mesma e apenas adicionamos a opção "],["monospaced",["text",":implements"]],["text",". Aqui o nome do pacote foi alterado para "],["monospaced",["text","aot.core"]],["text"," apenas para deixar claro que estamos usando a compilação "],["italic",["text","ahead of time"]],["text",". Você pode usar aqui o nome que vem entender."],["br"]],["paragraph",["text","Nosso código de "],["monospaced",["text","deref"]],["text"," não faz muito além de exibir o estado atual do nosso objeto, mas dá para termos uma ideia do que é possível fazer."],["br"]],["code","clojure",["br"],["code-text","(def n (aot.MeuNumero. 42))"],["br"],["code-text","@n"],["br"],["code-text","; 42"],["br"],["code-text","(deref n)"],["br"],["code-text","; 42"],["br"],["code-text","(+ 15 n)"],["br"],["code-text","; 57"],["br"]],["paragraph",["br"]],["section",["text","Criando objetos anônimos a partir de classes e interfaces"]],["paragraph",["br"]],["paragraph",["text","Até aqui vimos que podemos criar classes que estendem outras classes ou implementam interfaces. Isso é útil se precisarmos de vários objetos de uma mesma classe."],["br"]],["paragraph",["text","Em boa parte das vezes precisamos apenas de uma instância daquela classe ou de um objeto que implemente uma interface, sem que exista a necessidade de criarmos uma classe intermediária para isso."],["br"]],["index",["text","proxy"]],["paragraph",["br"]],["paragraph",["text","Para criar um objeto a partir de uma classe, concreta ou abstrata, usaremos o operador "],["monospaced",["text","proxy"]],["text","."],["br"]],["paragraph",["text","Além de eliminar a necessidade de criarmos uma classe explicitamente, este operador tem ainda a vantagem de não nos obrigar a usar "],["italic",["text","AOT"]],["text"," para que o objeto seja criado. Não há nada de errado em usar "],["italic",["text","AOT"]],["text",", desde que você possa escolher o melhor momento para isso."],["br"]],["paragraph",["text","Por outro lado, "],["monospaced",["text","proxy"]],["text"," não permite que você adicione métodos que não tenham sido declarados na classe mãe ou na interface que você deseja implementar."],["br"]],["paragraph",["text","Em Inglês, "],["italic",["text","proxy"]],["text"," significa "],["italic",["text","despachante"]],["text"," ou "],["italic",["text","procurador"]],["text",". É um intermediário para o qual você atribui um serviço e ele vai lá fazer para você. Na prática é como se você mesmo tivesse feito."],["br"]],["paragraph",["text","Em computação é qualquer computador, sistema ou coisa que o valha que fica entre as pontas do processo ou da comunicação."],["br"]],["paragraph",["text","Por exemplo, ao acessar um site pela rede da empresa, seu computador envia uma requisição para um servidor proxy, que é um computador que fica entre a rede da empresa e a Internet e esse servidor envia a requisição para a Internet."],["br"]],["paragraph",["text","A Internet enxerga o proxy, mas não o seu computador, enquanto seu computador enxerga o proxy, mas não a Internet."],["br"]],["paragraph",["text","Enquanto isso você, como usuário, acha que está acessando diretamente a Internet, feliz e tranquilão, como se ninguém estivesse lendo as coisas que você acessa."],["br"]],["paragraph",["text","Internamente o Clojure cria um mapa com as funções que você informa à macro "],["monospaced",["text","proxy"]],["text"," e, por baixo disso, é criado um objeto que executa cada função Clojure de acordo com o método invocado."],["br"]],["paragraph",["text","A macro tem esse nome exatamente por criar uma estrutura que fica no meio do caminho entre esse objeto e o código que você escreveu. Você acha que acessou o objeto diretamente, quando na verdade existe um intermediário no caminho."],["br"]],["paragraph",["text","Vamos começar com o objeto mais simples possível criando uma instância de "],["monospaced",["text","Object"]],["text",", a classe fundamental do Java."],["br"]],["paragraph",["text","O primeiro parâmetro é um vetor contendo a classe e/ou as interfaces que o nosso objeto vai implementar. Caso você misture classes e interfaces, a classe deve ser o primeiro item do vetor."],["br"]],["paragraph",["text","Já o segundo contém os parâmetros a serem passados para o construtor da classe que vai ser utilizado para implementarmos o objeto."],["br"]],["code","clojure",["br"],["code-text","(def obj (proxy [java.lang.Object] []))"],["br"],["code-text","obj"],["br"],["code-text","; #<Object$ff19274a user.proxy$java.lang.Object$ff19274a@40a72ff3>"],["br"]],["paragraph",["br"]],["paragraph",["text","Bacana, criamos um objeto do tipo "],["monospaced",["text","Object"]],["text",", o que por si só não serve para muita coisa. Vamos sobrescrever o método "],["monospaced",["text","toString"]],["text"," para vermos algo diferente acontecer."],["br"]],["code","clojure",["br"],["code-text","(def obj (proxy [java.lang.Object] []"],["br"],["code-text","           (toString [] \"É nóis, Jão.\")))"],["br"],["code-text","obj"],["br"],["code-text","; #<Object$ff19274a É nóis, Jão.>"],["br"]],["paragraph",["br"]],["title",["text","Implementando interfaces"]],["paragraph",["br"]],["paragraph",["text","Vamos agora fazer com que o nosso objeto seja executado em uma "],["italic",["text","thread"]],["text"," separada. Para isso, vamos implementar a classe "],["monospaced",["text","Runnable"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def thr (proxy [java.lang.Runnable] []"],["br"],["code-text","           (run [] (println \"Espero cinco segundos\")"],["br"],["code-text","                   (Thread/sleep 5000)"],["br"],["code-text","                   (println \"Executei a thread\"))"],["br"],["code-text","           (toString [] \"É nóis, Jão.\")))"],["br"],["code-text","thr"],["br"],["code-text","; #<Object$Runnable$c4146801 É nóis, Jão.>"],["br"],["code-text","(.start (Thread. thr))"],["br"],["code-text","; Espero cinco segundos"],["br"],["code-text",";; ...volta ao prompt do REPL..."],["br"],["code-text","; Executei a thread"],["br"]],["paragraph",["br"]],["paragraph",["text","Podemos passar qualquer objeto que implemente a interface "],["monospaced",["text","Runnable"]],["text"," como parâmetro para um objeto do tipo "],["monospaced",["text","Thread"]],["text",", e esse objeto "],["monospaced",["text","Thread"]],["text"," vai executar nossa implementação de "],["monospaced",["text","Runnable"]],["text","."],["br"]],["paragraph",["text","E cadê o "],["monospaced",["text","Object"]],["text"," que estava ali? Veja, se todo objeto Java é uma instância de "],["monospaced",["text","Object"]],["text"," ou de uma classe que estende "],["monospaced",["text","Object"]],["text",", não existe necessidade de informarmos essa classe quando estivermos implementando uma interface ou estendendo qualquer outra classe."],["br"]],["paragraph",["text","Toda função que você cria dentro com "],["monospaced",["text","proxy"]],["text"," pode fazer uso de "],["italic",["text","closures"]],["text",", guardando dados que existiam no contexto em que ela foi criada. Isso nos permite trabalhar com estados dentro do objeto que criamos."],["br"]],["paragraph",["text","Como "],["monospaced",["text","proxy"]],["text"," retorna um objeto, podemos usá-lo dentro de um "],["monospaced",["text","let"]],["text",", dentro de uma função ou onde mais você tiver necessidade."],["br"]],["paragraph",["text","No nosso exemplo, o parâmetro "],["monospaced",["text","texto"]],["text"," vai fazer parte do "],["italic",["text","closure"]],["text",", já que não vai mais existir após o fim da função, mas o objeto vai guardar a referência ao valor."],["br"]],["code","clojure",["br"],["code-text","(defn meu-deref [texto]"],["br"],["code-text","  (proxy [clojure.lang.IDeref java.lang.Runnable] []"],["br"],["code-text","    (run [] (println \"Espero cinco segundos\")"],["br"],["code-text","            (Thread/sleep 5000)"],["br"],["code-text","            (println \"Executei a thread\"))"],["br"],["code-text","    (toString [] \"É nóis, Jão.\")"],["br"],["code-text","    (deref [] texto)))"],["br"],["code-text","(def obj (meu-deref \"O mundo é bão, Sebastião\"))"],["br"],["code-text","obj"],["br"],["code-text","; #<Object$IDeref$Runnable$8011923@5444c89a:"],["br"],["code-text","; \"O mundo é bão, Sebastião\">"],["br"],["code-text","(.toString obj)"],["br"],["code-text","; \"É nóis, Jão.\""],["br"],["code-text","@obj"],["br"],["code-text","; \"O mundo é bão, Sebastião\""],["br"],["code-text","(.start (Thread. obj))"],["br"],["code-text","; Espero cinco segundos"],["br"],["code-text","; Executei a thread"],["br"]],["paragraph",["br"]],["title",["text","Acessando métodos da classe mãe"]],["paragraph",["br"]],["paragraph",["text","Todo objeto Java tem uma propriedade chamada "],["monospaced",["text","hashCode"]],["text",", que é utilizada na comparação entre dois objetos. Se o "],["monospaced",["text","hashCode"]],["text"," de dois objetos for diferente, é certeza de que estamos lidando com objetos diferentes."],["br"]],["paragraph",["text","Caso o "],["monospaced",["text","hashCode"]],["text"," seja igual, podemos partir para verificações mais lentas para termos certeza de que estamos falando de objetos com valores iguais. Comparar números inteiros é bem mais rápido e eficiente do que comparar textos ou outros valores mais complexos."],["br"]],["paragraph",["text","O "],["monospaced",["text","hashCode"]],["text"," também é utilizado como chave em um "],["monospaced",["text","hashmap"]],["text",". Quando você utiliza objetos mutáveis, o "],["monospaced",["text","hashCode"]],["text"," pode ser modificado durante a vida do objeto, e é por isso que você não deve nunca utilizar objetos mutáveis dentro de um "],["monospaced",["text","hashmap"]],["text",". Se você perder a chave de um item do "],["monospaced",["text","hashmap"]],["text"," é bem possível que você não encontre mais o objeto que você precisa."],["br"]],["paragraph",["text","Vamos modificar o método "],["monospaced",["text","hashCode"]],["text"," para exibir um número entre "],["italic",["text","0"]],["text"," e "],["italic",["text","9"]],["text",". Obviamente isso acaba com qualquer utilidade do "],["monospaced",["text","hashCode"]],["text",", mas vai nos ajudar a demonstrar uma chamada a um método de uma classe mãe."],["br"]],["paragraph",["text","Vamos aproveitar o código do nosso objeto atual."],["br"]],["code","clojure",["br"],["code-text","(defn meu-deref [texto]"],["br"],["code-text","  (proxy [clojure.lang.IDeref java.lang.Runnable] []"],["br"],["code-text","    (run [] (println \"Espero cinco segundos\")"],["br"],["code-text","            (Thread/sleep 5000)"],["br"],["code-text","            (println \"Executei a thread\"))"],["br"],["code-text","    (toString [] \"É nóis, Jão.\")"],["br"],["code-text","    (deref [] texto)"],["br"]],["paragraph",["br"]],["paragraph",["text","E agora vamos alterar "],["monospaced",["text","hashCode"]],["text"," para retornar sempre o mesmo valor. Isso não tem utilidade prática nenhuma, mas é um começo para testarmos se a função "],["monospaced",["text","hashCode"]],["text"," está sendo utilizada no nosso objeto."],["br"]],["code","clojure",["br"],["code-text","    (hashCode [] 10)))"],["br"]],["paragraph",["br"]],["paragraph",["text","E agora vamos verificar os valores."],["br"]],["code","clojure",["br"],["code-text","(def obj (meu-deref \"Wazaaaap\"))"],["br"],["code-text","@obj"],["br"],["code-text","; \"Wazaaaap\""],["br"],["code-text","(.hashCode obj)"],["br"],["code-text","; 10"],["br"]],["paragraph",["br"]],["index",["text","proxy-super"]],["paragraph",["br"]],["paragraph",["text","Agora vamos deixar o cálculo do "],["monospaced",["text","hashCode"]],["text"," para a classe "],["monospaced",["text","Object"]],["text",", que é a mãe. Dessa forma não precisaremos nos preocupar em utilizar algum algoritmo para isso. Para chamar o método correspondente da classe mãe vamos usar o operador "],["monospaced",["text","proxy-super"]],["text",", usando o nome do método como argumento."],["br"]],["code","clojure",["br"],["code-text","(defn meu-deref [texto]"],["br"],["code-text","  (proxy [clojure.lang.IDeref java.lang.Runnable] []"],["br"],["code-text","    (run [] (println \"Espero cinco segundos\")"],["br"],["code-text","            (Thread/sleep 5000)"],["br"],["code-text","            (println \"Executei a thread\"))"],["br"],["code-text","    (toString [] \"É nóis, Jão.\")"],["br"],["code-text","    (deref [] texto)"],["br"],["code-text","    (hashCode [] (proxy-super hashCode))))"],["br"],["code-text","(def obj (meu-deref \"hashCode padrão\"))"],["br"],["code-text","obj"],["br"],["code-text","; #<Object$IDeref$Runnable$8011923@79ff0a90: \"hashCode padrão\">"],["br"],["code-text","@obj"],["br"],["code-text","; \"hashCode padrão\""],["br"],["code-text","(.hashCode obj)"],["br"],["code-text","; 2046757520"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora o objeto está retornando o "],["monospaced",["text","hashCode"]],["text"," padrão."],["br"]],["paragraph",["text","A título de curiosidade, o nome do nosso objeto internamente é "],["monospaced",["text","Object$IDeref$Runnable$8011923@79ff0a90"]],["text",". O valor do "],["monospaced",["text","hashCode"]],["text",", que em decimal é "],["italic",["text","2046757520"]],["text",", convertido para hexadecimal é justamente o valor "],["italic",["text","79ff0a90"]],["text"," exibido após a arroba do nome do objeto."],["br"]],["paragraph",["text","Vamos finalmente alterar a função que nos retorna "],["monospaced",["text","hashCode"]],["text"," usando a função "],["monospaced",["text","mod"]],["text"," para termos o resto de divisão por "],["italic",["text","10"]],["text",", para termos apenas um dígito."],["br"]],["code","clojure",["br"],["code-text","(defn meu-deref [texto]"],["br"],["code-text","  (proxy [clojure.lang.IDeref java.lang.Runnable] []"],["br"],["code-text","    (run [] (println \"Espero cinco segundos\")"],["br"],["code-text","            (Thread/sleep 5000)"],["br"],["code-text","            (println \"Executei a thread\"))"],["br"],["code-text","    (toString [] \"É nóis, Jão.\")"],["br"],["code-text","    (deref [] texto)"],["br"],["code-text","    (hashCode [] (mod (proxy-super hashCode) 10))))"],["br"],["code-text","(def obj (meu-deref \"hashCode modificado\"))"],["br"],["code-text","@obj"],["br"],["code-text","; \"hashCode modificado\""],["br"],["code-text","(.hashCode obj)"],["br"],["code-text","; 2"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos gerar mais alguns objetos para ver os "],["italic",["text","hashCodes"]],["text"," que são gerados."],["br"]],["code","clojure",["br"],["code-text","(.hashCode (meu-deref \"Mais um\"))"],["br"],["code-text","; 9"],["br"],["code-text","(.hashCode (meu-deref \"E mais outro\"))"],["br"],["code-text","; 1"],["br"],["code-text","(.hashCode (meu-deref \"E ainda outro\"))="],["br"],["code-text","; 3"],["br"]],["paragraph",["br"]],["title",["text","Entendendo proxy por dentro"]],["paragraph",["br"]],["paragraph",["text","Falamos no início da explicação que o objeto "],["italic",["text","proxy"]],["text",", na verdade, executa código que está num "],["italic",["text","hashmap"]],["text"," que armazena as funções Clojures que foram passadas como parâmetro ao utilizarmos o operador "],["monospaced",["text","proxy"]],["text","."],["br"]],["index",["text","proxy-mappings"]],["paragraph",["br"]],["paragraph",["text","Podemos acessar esse "],["italic",["text","hashmap"]],["text"," através da função "],["monospaced",["text","proxy-mappings"]],["text",":"],["br"]],["code","clojure",["br"],["code-text","(proxy-mappings obj)"],["br"],["code-text","; {\"hashCode\" #<user$meu_deref$fn__769"],["br"],["code-text",";               user$meu_deref$fn__769@5181e7c3>,"],["br"],["code-text","; \"deref\" #<user$meu_deref$fn__773"],["br"],["code-text",";           user$meu_deref$fn__773@67808dd0>,"],["br"],["code-text","; \"toString\" #<user$meu_deref$fn__775"],["br"],["code-text",";              user$meu_deref$fn__775@15caeeb7>,"],["br"],["code-text","; \"run\" #<user$meu_deref$fn__777 user$meu_deref$fn__777@7b112e9a>}"],["br"]],["paragraph",["br"]],["paragraph",["text","Internamente, o objeto criado por "],["monospaced",["text","proxy"]],["text"," tem uma propriedade chamada "],["monospaced",["text","_getClojureFnMappings"]],["text",", que é acessada pelo método que invocarmos."],["br"]],["paragraph",["text","Se invocarmos o método "],["monospaced",["text","toString"]],["text",", por exemplo, internamente será executado um código Java similar a isso:"],["br"]],["code","clojure",["br"],["code-text","Object fn __getClojureFnMappings.get(\"toString\");"],["br"],["code-text","public String toString() {"],["br"],["code-text","  if(fn == null) {"],["br"],["code-text","    throw new UnsupportedOperationException();"],["br"],["code-text","  } else {"],["br"],["code-text","    ((IFn)fn).invoke(this);"],["br"],["code-text","  }"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que a função recebe uma referência ao objeto, exatamente como acontece quando usamos "],["monospaced",["text",":gen-class"]],["text",", mas ao contrário de "],["monospaced",["text",":gen-class"]],["text",", não precisamos declarar essa referência ao objeto. O próprio Clojure se encarrega de inserí-la ao gerar o código do objeto e das funções Clojure que serão invocadas."],["br"]],["paragraph",["text","Esse código é genérico e simples o bastante para que possa ser gerado rapidamente e para quantos métodos forem necessários."],["br"]],["paragraph",["text","Podemos executar qualquer uma das funções utilizadas pelo objeto "],["italic",["text","proxy"]],["text"," da mesma forma que o objeto faz internamente."],["br"]],["code","clojure",["br"],["code-text","(def m (proxy-mappings obj))"],["br"],["code-text","(m \"hashCode\")"],["br"],["code-text","; #<user$meu_deref$fn__769 user$meu_deref$fn__769@5181e7c3>"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos executar a função retornada pelo "],["italic",["text","hashmap"]],["text",", passando o objeto "],["monospaced",["text","obj"]],["text"," como parãmetro. Note que o resultado é exatamente o mesmo de chamarmos diretamente o método "],["monospaced",["text","hashCode"]],["text"," do objeto."],["br"]],["code","clojure",["br"],["code-text","((m \"hashCode\") obj)"],["br"],["code-text","; 2"],["br"],["code-text","(.hashCode obj)"],["br"],["code-text","; 2"],["br"]],["paragraph",["br"]],["paragraph",["text","Já que temos acesso ao "],["italic",["text","hashmap"]],["text"," que contém os nomes dos métodos do objeto e suas respectivas funções, não seria bom também se pudessemos modificar esse mapa em tempo de execução?"],["br"]],["paragraph",["text","Pois saiba que podemos, o que torna um objeto Java criado por dentro do Clojure ainda mais flexível que um objeto Java criado por dentro do Java."],["br"]],["index",["text","update-proxy"]],["paragraph",["br"]],["paragraph",["text","Vamos modificar nosso método "],["monospaced",["text","hashCode"]],["text"," para que ele retorne o valor gerado pela classe "],["monospaced",["text","Object"]],["text",", desfazendo o nosso experimento com um "],["italic",["text","hashCode"]],["text"," que só retorna um dígito. Para isso vamos usar a função "],["monospaced",["text","update-proxy"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(update-proxy obj {\"hashCode\" (fn [this] (proxy-super hashCode))})"],["br"],["code-text","(.hashCode obj)"],["br"],["code-text","; 31195642"],["br"]],["paragraph",["br"]],["paragraph",["text","A função "],["monospaced",["text","update-proxy"]],["text"," retorna uma cópia de "],["monospaced",["text","obj"]],["text"," e causa efeito colateral, modificando o "],["italic",["text","hashmap"]],["text"," que está dentro de "],["monospaced",["text","obj"]],["text",". Lembre-se disso ao compartilhar um objeto gerado por "],["monospaced",["text","proxy"]],["text"," entre várias "],["italic",["text","threads"]],["text","."],["br"]],["title",["text","Usando reify"]],["paragraph",["br"]],["index",["text","reify"]],["paragraph",["br"]],["paragraph",["text","Existe uma outra macro, chamada "],["monospaced",["text","reify"]],["text",", que retorna um objeto a partir de uma interface Java. A palavra "],["italic",["text","reify"]],["text"," significa "],["italic",["text","tornar algo real"]],["text"," ou, no contexto do Clojure, pegar uma interface e transformar em um objeto concreto."],["br"]],["paragraph",["text","O uso de "],["monospaced",["text","reify"]],["text"," tem certas vantagens sobre o uso de "],["monospaced",["text","proxy"]],["text",", mas também ter limitações."],["br"]],["paragraph",["text","A macro "],["monospaced",["text","reify"]],["text"," cria um objeto sem o mapa no meio do caminho, e as funções que você declara são os próprios métodos do objeto. Isso faz com que a criação e o uso do objeto seja mais rápido e ocupe menos memória."],["br"]],["paragraph",["text","Por outro lado, você só pode implementar interfaces e protocolos e também não pode substituir um método por outro em tempo de execução."],["br"]],["paragraph",["text","Assim como aconteceu com "],["monospaced",["text","proxy"]],["text",", você não pode definir métodos que não tenham sido declarados nas interfaces que você estiver implementando."],["br"]],["paragraph",["text","Se isso não for problema para você, use "],["monospaced",["text","reify"]],["text"," e seja feliz."],["br"]],["paragraph",["text","Vamos escrever com "],["monospaced",["text","reify"]],["text"," um código equivalente ao que escrevemos com "],["monospaced",["text","proxy"]],["text",", implementando um objeto "],["monospaced",["text","Runnable"]],["text"," que aguarde cinco segundos em uma "],["italic",["text","thread"]],["text"," separada."],["br"]],["paragraph",["text","Primeiro informamos a interface que estamos implementando, sem a necessidade de um vetor."],["br"]],["code","clojure",["br"],["code-text","(let [obj (reify java.lang.Runnable"],["br"],["code-text",";]"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos implementar o método "],["monospaced",["text","run"]],["text",". Ao contrário de "],["monospaced",["text","proxy"]],["text",", aqui precisamos declarar um parâmetro que vai receber uma referência ao objeto."],["br"]],["code","clojure",["br"],["code-text","            (run [this]"],["br"],["code-text","              (println \"Espero cinco segundos\")"],["br"],["code-text","              (Thread/sleep 5000)"],["br"],["code-text","              (println \"Executei a thread\")))"],["br"]],["paragraph",["br"]],["paragraph",["text","E agora criamos uma nova "],["italic",["text","thread"]],["text"," e a iniciamos."],["br"]],["code","clojure",["br"],["code-text","      thread (Thread. obj)]"],["br"],["code-text","  (.start thread))"],["br"],["code-text","; Espero cinco segundos"],["br"],["code-text",";; ...volta para o REPL..."],["br"],["code-text","; Executei a thread"],["br"]],["paragraph",["br"]],["paragraph",["text","Se precisarmos implementar mais de uma interface, basta declararmos a próxima após terminarmos de implementar os métodos da interface anterior, e assim por diante."],["br"]],["paragraph",["text","Vamos implementar agora a interface "],["monospaced",["text","clojure.lang.IDeref"]],["text"," no nosso objeto."],["br"]],["paragraph",["text","Vou incluir aqui o código completo do exemplo anterior para que você tenha uma boa noção de como o código fica."],["br"]],["code","clojure",["br"],["code-text","(let [obj (reify java.lang.Runnable"],["br"],["code-text","      ;; método de Runnable"],["br"],["code-text","            (run [this]"],["br"],["code-text","              (println \"Espero cinco segundos\")"],["br"],["code-text","              (Thread/sleep 5000)"],["br"],["code-text","              (println \"Executei a thread\"))"],["br"],["code-text","            clojure.lang.IDeref"],["br"],["code-text","            (deref [this]"],["br"],["code-text","              \"Aqui rolou um deref\"))]"],["br"],["code-text","  (println @obj))"],["br"],["code-text","; Aqui rolou um deref"],["br"]],["paragraph",["br"]],["paragraph",["text","Por padrão, "],["monospaced",["text","reify"]],["text"," já implementa "],["monospaced",["text","clojure.lang.IObj"]],["text",", o que nos dá de brinde suporte a metadados."],["br"]],["code","clojure",["br"],["code-text","(let [obj ^{:texto \"Este eh um objeto criado dinamicamente"],["br"],["code-text","                    com reify\"}"],["br"],["code-text","         (reify java.lang.Runnable"],["br"],["code-text","            (run [this]"],["br"],["code-text","              (println \"Espero cinco segundos\")"],["br"],["code-text","              (Thread/sleep 5000)"],["br"],["code-text","              (println \"Executei a thread\"))"],["br"],["code-text","            clojure.lang.IDeref"],["br"],["code-text","            (deref [this]"],["br"],["code-text","              \"Aqui rolou um deref\"))"],["br"],["code-text","      vdoc (var doc)]"],["br"],["code-text","  (println @obj)"],["br"],["code-text","  (println (meta obj)))"],["br"],["code-text","; Aqui rolou um deref"],["br"],["code-text","; {:texto Este eh um objeto criado dinamicamente com reify,"],["br"],["code-text",";  :column 11, :line 1}"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora você sabe criar praticamente qualquer objeto que precisar dentro do Clojure."],["br"]],["section",["text","Usando Java e Clojure no mesmo projeto"]],["paragraph",["br"]],["paragraph",["text","Mas, e quando você descobre que criar o objeto por dentro do Clojure não é o bastante, seja por precisar extrair o máximo de velocidade, seja porque você já tem um código pronto em Java?"],["br"]],["paragraph",["text","Com a ajuda do nosso amigo "],["italic",["text","Leiningen"]],["text"," podemos usar Clojure e Java num mesmo projeto."],["br"]],["paragraph",["text","Com alguns plugins a mais você pode inclusive misturar Clojure, Java, Frege (um dialeto Haskell), Groovy e Scala num mesmo projeto. Eu realmente não sei porque alguém iria querer fazer essa mistureba, mas é possível de qualquer maneira."],["br"]],["paragraph",["text","Vamos criar um projeto chamado "],["monospaced",["text","integracao"]],["text","."],["br"]],["code",["br"],["code-text","lein new app integracao"],["br"],["code-text","> Generating a project called integracao based on the 'app' template."],["br"]],["paragraph",["br"]],["paragraph",["text","Ao criarmos uma aplicação usando o "],["italic",["text","Leiningen"]],["text",", será criada a seguinte estrutura de diretórios:"],["br"]],["code",["br"],["code-text","+-- doc"],["br"],["code-text","|"],["br"],["code-text","+-- resources"],["br"],["code-text","|"],["br"],["code-text","+-- src"],["br"],["code-text","|   |"],["br"],["code-text","|   +-- integracao"],["br"],["code-text","|"],["br"],["code-text","+-- test"],["br"],["code-text","    |"],["br"],["code-text","    +-- integracao"],["br"]],["paragraph",["br"]],["paragraph",["text","Por padrão, nosso código Clojure vai ficar dentro do diretório "],["monospaced",["text","/src"]],["text",". Vamos modificar essa estrutura para podermos abrigar os fontes Java e Clojure de forma organizada."],["br"]],["paragraph",["text","Eu costumo usar a estrutura a seguir, mas fique a vontade para usar a estrutura que for mais conveniente para você ou para sua equipe."],["br"]],["paragraph",["text","Note que dentro de "],["monospaced",["text","/src"]],["text"," eu crio um diretório para o Java e outro para o Clojure. Se eu fosse misturar Groovy, criaria um diretório "],["monospaced",["text","groovy"]],["text"," dentro de "],["monospaced",["text","/src"]],["text"," e assim por diante."],["br"]],["code","clojure",["br"],["code-text","+-- doc"],["br"],["code-text","|"],["br"],["code-text","+-- resources"],["br"],["code-text","|"],["br"],["code-text","+-- src"],["br"],["code-text","|   |"],["br"],["code-text","|   +-- clojure"],["br"],["code-text","|   |   |"],["br"],["code-text","|   |   +-- integracao"],["br"],["code-text","|   |"],["br"],["code-text","|   +-- java"],["br"],["code-text","|"],["br"],["code-text","+-- test"],["br"],["code-text","    |"],["br"],["code-text","    +-- integracao"],["br"]],["paragraph",["br"]],["paragraph",["text","Perceba que o diretório "],["monospaced",["text","integracao"]],["text",", por fazer parte da estrutura do código Clojure, foi movido para o local devido."],["br"]],["paragraph",["text","Note também que não mexemos no diretório "],["monospaced",["text","test"]],["text"," por não ser importante para o que estamos fazendo agora. Mais para frente teremos um capítulo todo só para testes."],["br"]],["paragraph",["text","Agora que modificamos a estrutura de diretórios teremos problemas para compilar nossa aplicação. Claro, o "],["italic",["text","Leiningen"]],["text"," não sabe para foi o nosso código."],["br"]],["code",["br"],["code-text","lein run"],["br"],["code-text","> Can't find 'integracao.core' as .class or .clj for lein run: please"],["br"],["code-text","> check the spelling."],["br"],["code-text","> Exception in thread \"main\" java.io.FileNotFoundException: Could not"],["br"],["code-text","> locate integracao/core__init.class or integracao/core.clj on"],["br"],["code-text","> classpath: , compiling:"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos editar o arquivo "],["monospaced",["text","project.clj"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defproject integracao \"0.1.0-SNAPSHOT\""],["br"],["code-text","  ; licenças, descrição, URL"],["br"],["code-text","  :dependencies [[org.clojure/clojure \"1.7.0\"]]"],["br"],["code-text","  :main integracao.core"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos adicionar as opções "],["monospaced",["text","source-paths"]],["text",", com um vetor contendo os diretórios onde o código fonte escrito em Clojure pode ser encontrado; e "],["monospaced",["text","java-source-paths"]],["text",", contendo um vetor com os diretórios onde o código fonte escrito em Java puro pode ser encontrado."],["br"]],["code","clojure",["br"],["code-text","  :source-paths [\"src/clojure\"]"],["br"],["code-text","  :java-source-paths [\"src/java\"])"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora podemos executar o nosso projeto para ver a mensagem padrão da aplicação."],["br"]],["code",["br"],["code-text","lein run"],["br"],["code-text","> Hello, World!"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos escrever um código Java bem simples dentro do diretório "],["monospaced",["text","src/java"]],["text","."],["br"]],["paragraph",["text","Nossa classe Java vai ficar dentro de um pacote "],["monospaced",["text","meu.codigo.java"]],["text",", o que significa que devemos escrever nosso arquivo Java dentro do diretório "],["monospaced",["text","meu/codigo/java"]],["text",", que por sua vez fica dentro de "],["monospaced",["text","src/java"]],["text","."],["br"]],["code","java",["br"],["code-text","package meu.codigo.java;"],["br"],["code-text","public class MinhaClasse {"],["br"],["code-text","  public static final String UMA_CONSTANTE = \"Uma constante\";"],["br"],["code-text","  public String umMembro = \"Esse aqui pode ser alterado\";"],["br"],["code-text","  private String texto = \"Um texto qualquer\";"],["br"],["code-text","  public static String metodoEstatico() {"],["br"],["code-text","    return \"Um método estático de classe\";"],["br"],["code-text","  }"],["br"],["code-text","  public String metodoDeClasse() {"],["br"],["code-text","    return \"Um método de classe\";"],["br"],["code-text","  }"],["br"],["code-text","  public void setTexto(String texto) {"],["br"],["code-text","    this.texto = texto;"],["br"],["code-text","  }"],["br"],["code-text","  public String getTexto() {"],["br"],["code-text","    return texto;"],["br"],["code-text","  }"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["paragraph",["text","Misturei métodos e membros publicos, privados, estáticos e de objeto para mostrar como cada um se comporta dentro do Clojure."],["br"]],["paragraph",["text","Agora vamos voltar ao arquivo "],["monospaced",["text","src/clojure/core.clj"]],["text"," e importar essa classe que acabamos de criar."],["br"]],["code","clojure",["br"],["code-text","(ns integracao.core"],["br"],["code-text","  (:import [meu.codigo.java MinhaClasse])"],["br"],["code-text","  (:gen-class))"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que há um espaço entre "],["monospaced",["text","java"]],["text"," e "],["monospaced",["text","MinhaClasse"]],["text","."],["br"]],["paragraph",["text","Vamos abrir o REPL para podermos brincar a vontade para o objeto que vamos criar."],["br"]],["code","clojure",["br"],["code-text","(def meu-objeto (MinhaClasse.))"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos utilizar os membros estáticos da classe que criamos."],["br"]],["code","clojure",["br"],["code-text","MinhaClasse/UMA_CONSTANTE"],["br"],["code-text","; \"Uma constante\""],["br"],["code-text","(MinhaClasse/metodoEstatico)"],["br"],["code-text","; \"Um método estático de classe"],["br"]],["paragraph",["br"]],["paragraph",["text","Enquanto no Java é possível acessar membros estáticos através do objeto, mesmo sendo uma má prática, no Clojure isso não é possível, já que o compilador vai achar que o nome do objeto é um "],["italic",["text","namespace"]],["text","."],["br"]],["code","clojure",["br"],["code-text","meu-objeto/UMA_CONSTANTE"],["br"],["code-text","; java.lang.RuntimeException: No such namespace: meu-objeto"],["br"],["code-text","(meu-objeto/metodoEstatico)"],["br"],["code-text","; java.lang.RuntimeException: No such namespace: meu-objeto"],["br"]],["paragraph",["br"]],["paragraph",["text","Podemos acessar os membros de objeto, ou de instância, da forma como já conhecemos."],["br"]],["code","clojure",["br"],["code-text","(.umMembro meu-objeto)"],["br"],["code-text","; \"Esse aqui pode ser alterado\""],["br"],["code-text","(.metodoDeInstancia meu-objeto)"],["br"],["code-text","; \"Um método de instancia\"\""],["br"]],["paragraph",["br"]],["index",["text","set!"]],["paragraph",["br"]],["paragraph",["text","Podemos alterar campos de um objeto Java através da forma especial "],["monospaced",["text","set!"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(set! (.umMembro meu-objeto) \"Novo valor\")"],["br"],["code-text","; \"Novo valor\""],["br"],["code-text","integracao.core=> (.umMembro meu-objeto)"],["br"],["code-text","; \"Novo valor\""],["br"]],["paragraph",["br"]],["paragraph",["text","Note que "],["monospaced",["text","set!"]],["text"," causa um efeito colateral ao modificar o objeto que criamos. Pelo fato do objeto ser mutável, tome cuidado ao compartilhá-lo entre diferentes "],["italic",["text","threads"]],["text"," da aplicação, já que todos os problemas que temos com concorrência em Java vão acontecer também com nosso objeto no Clojure."],["br"]],["paragraph",["text","Veremos concorrência mais para frente e abordaremos esses tais problemas."],["br"]],["paragraph",["text","Por fim, podemos executar também "],["italic",["text","getters"]],["text"," e "],["italic",["text","setters"]],["text"," do objeto."],["br"]],["code","clojure",["br"],["code-text","(.getTexto meu-objeto)"],["br"],["code-text","; \"Um texto qualquer\""],["br"],["code-text","(.setTexto meu-objeto \"Um novo texto qualquer\")"],["br"],["code-text","; nil"],["br"],["code-text","(.getTexto meu-objeto)"],["br"],["code-text","; \"Um novo texto qualquer\""],["br"]],["paragraph",["br"]],["paragraph",["text","E você pode manipular o objeto normalmente, sem novidade nenhuma até aqui."],["br"]],["section",["text","Chamando Clojure dentro do Java"]],["paragraph",["br"]],["paragraph",["text","Pode acontecer o contrário, sendo necessário invocar código Clojure de dentro do Java."],["br"]],["paragraph",["text","Vamos aproveitar criar um novo projeto utilizando uma ferramenta chamada "],["italic",["text","Maven"]],["text",", que é uma das mais utilizadas para gerenciar tarefas e dependências em projetos Java."],["br"]],["paragraph",["text","Você pode encontrar o "],["italic",["text","Maven"]],["text"," no endereço:"],["br"]],["paragraph",["text","https://maven.apache.org/"],["br"]],["paragraph",["text","Após seguir as instruções do site para instalar e configurar, vamos criar um projeto chamado "],["monospaced",["text","meu-java"]],["text","."],["br"]],["paragraph",["text","Para isso, vamos executar o comando a seguir numa mesma linha. Vou quebrar em linhas diferentes para deixar mais fácil de ler, mas ele deve ser digitado em apenas uma linha."],["br"]],["code",["br"],["code-text","mvn archetype:generate"],["br"],["code-text","    -DgroupId=capitulo08"],["br"],["code-text","    -DartifactId=meu-java"],["br"],["code-text","    -DinteractiveMode=false"],["br"]],["paragraph",["br"]],["paragraph",["text","Com isso será criado um diretório "],["monospaced",["text","meu-java"]],["text",", com a estrutura padrão de diretórios do "],["italic",["text","Maven"]],["text"," e um arquivo "],["monospaced",["text","pom.xml"]],["text","."],["br"]],["paragraph",["text","Se você preferir, pode poupar a trabalheira que é configurar um projeto "],["italic",["text","Maven"]],["text",", com todas as dependências e características, pode pegar o projeto pronto no repositório do livro, no diretório do capítulo "],["ref-label",["text","capitulo-integracao-java"]],["text","."],["br"]],["paragraph",["text","O que nos interessa é a classe "],["monospaced",["text","capitulo08.meujava.Main"]],["text",", que fica no diretório "],["monospaced",["text","src/main/java"]],["text",". É lá que vamos demonstrar como fazer a integração com Java."],["br"]],["index",["text","clojure.java.api.Clojure"]],["paragraph",["br"]],["index",["text","clojure.lang.IFn"]],["paragraph",["br"]],["paragraph",["text","Primeiro vamos importar duas classes: "],["monospaced",["text","clojure.java.api.Clojure"]],["text",", que nos fornece uma interface para invocarmos métodos e operações do Clojure através do Java; e "],["monospaced",["text","clojure.lang.IFn"]],["text",", que é a interface que toda função Clojure implementa."],["br"]],["code","java",["br"],["code-text","package capitulo08.meujava;"],["br"],["code-text","import clojure.java.api.Clojure;"],["br"],["code-text","import clojure.lang.IFn;"],["br"]],["paragraph",["br"]],["paragraph",["text","E vamos usar o próprio método "],["monospaced",["text","main"]],["text"," para brincarmos com as funções do Clojure."],["br"]],["code","clojure",["br"],["code-text","public class Main {"],["br"],["code-text","  public static void main (String ... args) {"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos atribuir a função Clojure "],["monospaced",["text","+"]],["text"," a uma variável do Java que vamos chamar de "],["monospaced",["text","soma"]],["text"," e usá-la para efetuar uma operação simples."],["br"]],["paragraph",["text","Vamos também guardar uma referência à função "],["monospaced",["text","println"]],["text"," para podermos exibir o resultado."],["br"]],["code","clojure",["br"],["code-text","  final IFn soma = Clojure.var(\"clojure.core\", \"+\");"],["br"],["code-text","  final IFn println = Clojure.var(\"clojure.core\", \"println\");"],["br"],["code-text","  println.invoke("],["br"],["code-text","    \"A soma de 3 e 2 é: \","],["br"],["code-text","    soma.invoke(3, 2));"],["br"]],["paragraph",["br"]],["paragraph",["text","E fechamos as chaves do código."],["br"]],["code","clojure",["br"],["code-text","//"],["br"],["code-text","  }"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos executar no terminal."],["br"]],["code",["br"],["code-text","mvn clean install"],["br"],["code-text","java -jar target/meu-java-0.1.0.jar"],["br"],["code-text","> A soma de 3 e 2 é:  5"],["br"]],["paragraph",["br"]],["paragraph",["text","Acabamos de executar a soma entre dois números usando funções Java. Escreva os códigos Java a seguir dentro desse método "],["monospaced",["text","main"]],["text"," e execute os comandos "],["monospaced",["text","mvn"]],["text"," e "],["monospaced",["text","java -jar"]],["text"," da maneira que já vimos para ver o código sendo executado."],["br"]],["paragraph",["text","Vamos agora pegar uma lista de dez elementos, somar um a todos os elementos e depois calcular a soma de todos os itens."],["br"]],["paragraph",["text","Em Clojure o nosso código ficaria assim. Pode testar no "],["italic",["text","REPL"]],["text"," para conferir:"],["br"]],["code","clojure",["br"],["code-text","(reduce + (map inc (range 1 11)))"],["br"],["code-text","; 65"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos precisar de cinco funções para executar esse código: "],["monospaced",["text","reduce"]],["text",", "],["monospaced",["text","+"]],["text",", "],["monospaced",["text","map"]],["text",", "],["monospaced",["text","inc"]],["text"," e "],["monospaced",["text","range"]],["text",". A função "],["monospaced",["text","+"]],["text"," já foi atribuída à variável "],["monospaced",["text","soma"]],["text",", então vamos nos preocupar apenas com as outras."],["br"]],["code","java",["br"],["code-text","  final IFn reduce = Clojure.var(\"clojure.core\", \"reduce\");"],["br"],["code-text","  final IFn map    = Clojure.var(\"clojure.core\", \"map\");"],["br"],["code-text","  final IFn inc    = Clojure.var(\"clojure.core\", \"inc\");"],["br"],["code-text","  final IFn range  = Clojure.var(\"clojure.core\", \"range\");"],["br"]],["paragraph",["br"]],["paragraph",["text","A expressão mais interna da nossa expressão é "],["monospaced",["text","(range 1 11)"]],["text",". Vamos atribuir o resultado à variável "],["monospaced",["text","lista1"]],["text"," e mandar imprimir o resultado."],["br"]],["index",["text","range"]],["paragraph",["br"]],["code","java",["br"],["code-text","  Object lista1 = range.invoke(1, 11);"],["br"],["code-text","  println.invoke(lista1);"],["br"],["code-text","// (1 2 3 4 5 6 7 8 9 10)"],["br"]],["paragraph",["br"]],["paragraph",["text","Olha que bonito uma lista do Clojure sendo impressa dentro do Java."],["br"]],["paragraph",["text","Vamos agora aplicar a função "],["monospaced",["text","inc"]],["text"," a todos os itens de "],["monospaced",["text","lista1"]],["text"," e atribuir o resultado."],["br"]],["index",["text","map"]],["paragraph",["br"]],["index",["text","inc"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","  Object lista2 = map.invoke(inc, lista1);"],["br"],["code-text","  println.invoke(lista2);"],["br"],["code-text","// (2 3 4 5 6 7 8 9 10 11)"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos aplicar a função "],["monospaced",["text","soma"]],["text"," na "],["monospaced",["text","lista2"]],["text"," para termos o somatório de todos os itens da lista."],["br"]],["index",["text","reduce"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","  Object resultado = reduce.invoke(soma, lista2);"],["br"],["code-text","  println.invoke(resultado);"],["br"],["code-text","// 65"],["br"]],["paragraph",["br"]],["paragraph",["text","E eis o nosso resultado "],["italic",["text","65"]],["text",", o mesmo que obtivemos no código Clojure."],["br"]],["paragraph",["text","Então você vai se perguntar qual a utilidade de usar Clojure dentro do Java para efetuar operações que você poderia muito bem resolver com um "],["monospaced",["text","for"]],["text"," e o operador de adição do próprio Java."],["br"]],["paragraph",["text","Nenhuma, mas você pode aproveitar as estruturas de dados persistentes na sua aplicação para obter as vantagens da imutabilidade e do aproveitamento de memória, tornando mais fácil a criação de aplicações concorrentes com Java puro."],["br"]],["index",["text","atom"]],["paragraph",["br"]],["paragraph",["text","Por exemplo, podemos utilizar um "],["italic",["text","atom"]],["text"," para armazenar informações que são lidar e talvez modificadas em um ambiente com várias "],["italic",["text","threads"]],["text","."],["br"]],["code","java",["br"],["code-text","  final IFn atom  = Clojure.var(\"clojure.core\", \"atom\");"],["br"],["code-text","  final IFn swap  = Clojure.var(\"clojure.core\", \"swap!\");"],["br"],["code-text","  final IFn deref = Clojure.var(\"clojure.core\", \"deref\");"],["br"],["code-text","  final Object contador = atom.invoke(0);"],["br"]],["paragraph",["br"]],["paragraph",["text","Um "],["italic",["text","atom"]],["text"," é uma estrutura do Clojure que permite que a modificação do valor seja feitas de forma atômica e "],["italic",["text","thread-safe"]],["text",", ou seja, só grava se tudo estiver certinho, mesmo que várias "],["italic",["text","threads"]],["text"," diferentes tentarem gravar ao mesmo tempo."],["br"]],["paragraph",["text","Criamos um "],["italic",["text","atom"]],["text"," com valor inicial zero, mas poderíamos ter usado qualquer outro valor, inclusive qualquer estrutura de dados, vazia ou não."],["br"]],["index",["text","deref"]],["paragraph",["br"]],["paragraph",["text","Para lermos o conteúdo de um "],["italic",["text","atom"]],["text"," precisamos utilizar o operador "],["monospaced",["text","deref"]],["text",":"],["br"]],["code","java",["br"],["code-text","  println.invoke(\"O valor de contador é:\", deref.invoke(contador));"],["br"],["code-text","// O valor de contador é: 0"],["br"]],["paragraph",["br"]],["index",["text","swap!"]],["paragraph",["br"]],["paragraph",["text","Para modificarmos o valor de um "],["italic",["text","atom"]],["text",", usamos a função "],["monospaced",["text","swap!"]],["text",", passando como argumentos o próprio "],["italic",["text","atom"]],["text"," e a função que vai modificar seu valor."],["br"]],["code","java",["br"],["code-text","  swap.invoke(contador, inc);"],["br"],["code-text","  println.invoke(\"O valor de contador agora é:\","],["br"],["code-text","                 deref.invoke(contador));"],["br"],["code-text","// O valor de contador agora é: 1"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos agora criar uma "],["italic",["text","thread"]],["text"," que modifique o valor do "],["italic",["text","atom"]],["text",", iniciar sua execução e, em seguida, fora dessa nova "],["italic",["text","thread"]],["text"," vamos incrementar novamente o valor do "],["italic",["text","atom"]],["text",". Não há qualquer garantia a respeito da ordem em que isso ocorre, e esse é um dos principais problemas na programação concorrente. Veremos isso no próximo capítulo."],["br"]],["code","java",["br"],["code-text","  (new Thread () {"],["br"],["code-text","    public void run() {"],["br"],["code-text","      swap.invoke(contador, inc);"],["br"],["code-text","      println.invoke(\"Dentro da thread:\", deref.invoke(contador));"],["br"],["code-text","    };"],["br"],["code-text","  }).start();"],["br"],["code-text","  println.invoke(\"E finalmente o contador agora é:\","],["br"],["code-text","                 deref.invoke(contador));"],["br"],["code-text","// E finalmente o contador agora é: 1"],["br"],["code-text","// Dentro da thread: 2"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que o código da "],["italic",["text","thread"]],["text"," foi executado após o código fora dela, mesmo tendo sido declarado antes. Como eu disse, não existe como prever a ordem de execução do código ao utilizarmos várias "],["italic",["text","threads"]],["text",", mas com "],["italic",["text","atom"]],["text"," podemos ao menos garantir que o valor não vai ser corrompido ou modificado incorretamente."],["br"]],["index",["text","classe interna"]],["paragraph",["br"]],["paragraph",["text","Note que criamos uma classe interna e anônima ao declaramos um novo objeto do tipo "],["monospaced",["text","Thread"]],["text",". Como essa classe interna utiliza membros da classe externa "],["monospaced",["text","Main"]],["text",", emulando "],["italic",["text","closures"]],["text",", esses membros obrigatoriamente precisam ser declarados como "],["monospaced",["text","final"]],["text",", para garantir que elas sejam inicializadas apenas uma vez e suas referências na memória não sejam alteradas"],["ref",["text","jvm8-spec"]],["text","."],["br"]],["paragraph",["text","Uma boa prática, sendo inclusive o que o próprio Clojure faz, é declarar todos os "],["italic",["text","vars"]],["text"," que serão usados no código Java como membros estáticos e finais da classe. Dessa forma você terá a referência atribuída durante a carga da classe pela "],["italic",["text","JVM"]],["text",", uma única vez durante toda a existência da sua aplicação."],["br"]],["paragraph",["text","A sua lição de casa agora vai ser modificar o código usando essa boa prática."],["br"]],["title",["text","Require"]],["paragraph",["br"]],["paragraph",["text","Mas ainda não acabou."],["br"]],["paragraph",["text","Todas os operadores declarados no "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.core"]],["text"," estão disponíveis automaticamente. Operadores de quaisquer outros "],["italic",["text","namespaces"]],["text"," devem ser requeridos, como se fosse um código Clojure comum."],["br"]],["index",["text","require"]],["paragraph",["br"]],["index",["text","clojure.pprint"]],["paragraph",["br"]],["paragraph",["text","Vamos utilizar o operador "],["monospaced",["text","require"]],["text"," para podermos utilizar a função "],["monospaced",["text","pprintln"]],["text",", que está no "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.pprint"]],["text"," e assim vermos dados formatados na tela."],["br"]],["code","clojure",["br"],["code-text","(def livro {:nome \"Plínio\" :sobrenome \"Balduino\" :titulo \"Clojure\""],["br"],["code-text","  :editora \"Casa do Código\"})"],["br"],["code-text","(clojure.pprintln/pprintln livro)"],["br"],["code-text","; {:nome \"Plínio\","],["br"],["code-text","   :editora \"Casa do Código\","],["br"],["code-text","   :titulo \"Clojure\","],["br"],["code-text","   :sobrenome \"Balduino\"}"],["br"],["code-text","(println livro)"],["br"],["code-text","; {:nome Plínio, :editora Casa do Cídigo, :titulo Clojure,"],["br"],["code-text","; :sobrenome Balduino}"],["br"]],["paragraph",["br"]],["paragraph",["text","Vamos primeiro referenciar o operador "],["monospaced",["text","require"]],["text"," e mais alguns que vão se mostrar úteis no decorrer do exemplo. Não vou declarar novamente as funções que já usamos porque, bem, já declaramos e usamos."],["br"]],["code","java",["br"],["code-text","  final IFn require = Clojure.var(\"clojure.core\", \"require\");"],["br"],["code-text","  final IFn symbol  = Clojure.var(\"clojure.core\", \"symbol\");"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos carregar o "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.pprint"]],["text"," usando "],["monospaced",["text","require"]],["text"," e referenciar a função "],["monospaced",["text","pprint"]],["text"," que lá está."],["br"]],["code","java",["br"],["code-text","  require.invoke(symbol.invoke(\"clojure.pprint\"));"],["br"],["code-text","  final IFn pprint  = Clojure.var(\"clojure.pprint\", \"pprint\");"],["br"]],["paragraph",["br"]],["index",["text","Clojure.read"]],["paragraph",["br"]],["paragraph",["text","Agora um macete que pode ser perigoso. Podemos declarar um "],["italic",["text","hashmap"]],["text"," utilizando a função "],["monospaced",["text","hash-map"]],["text"," ou podemos passar código Clojure para o compilador em formato texto através da função "],["monospaced",["text","Clojure.read"]],["text","."],["br"]],["paragraph",["text","Tome cuidado ao executar diretamente valores vindos do usuário ou de fontes externas, já que isso pode se tornar uma grave falha de segurança."],["br"]],["paragraph",["text","Com isso em mente, vamos exibir o "],["italic",["text","hashmap"]],["text"," com a função "],["monospaced",["text","pprint"]],["text","."],["br"]],["code","java",["br"],["code-text","  Object livro = Clojure.read(\"{:nome \\\"Plínio\\\" :sobrenome \" +"],["br"],["code-text","    \"\\\"Balduino\\\" :titulo \\\"Clojure\\\" :editora \\\"Casa do Código\\\"}\");"],["br"],["code-text","  pprint.invoke(livro);"],["br"],["code-text","// {:nome \"Plínio\","],["br"],["code-text","//  :sobrenome \"Balduino\","],["br"],["code-text","//  :titulo \"Clojure\","],["br"],["code-text","//  :editora \"Casa do Código\"}"],["br"]],["paragraph",["br"]],["paragraph",["text","Você pode executar qualquer código Clojure que precisar dessa forma. Adicione a biblioteca contendo seu código como dependência do projeto Java e aproveite todas as ferramentas que a linguagem oferece para lidar com estruturas de dados persistentes, concorrência e o que mais você achar necessário."],["br"]],["section",["text","Otimizando com type hints"]],["paragraph",["br"]],["paragraph",["text","Por padrão você não informa os tipos dos dados ao Clojure. Internamente o dado vai ser tratado como "],["monospaced",["text","Object"]],["text",", que é a classe base de qualquer objeto Java."],["br"]],["paragraph",["text","Qualquer método ou propriedade que você invocar desse objeto será localizado e chamado através de "],["italic",["text","reflection"]],["text","."],["br"]],["paragraph",["text","Exemplificando, esse código Clojure:"],["br"]],["code","clojure",["br"],["code-text","(defn upper-case [text]"],["br"],["code-text","  (.toUpperCase text))"],["br"],["code-text","(upper-case \"umba umba umba ê\")"],["br"],["code-text","; \"UMBA UMBA UMBA Ê\""],["br"]],["paragraph",["br"]],["paragraph",["text","Vai ser transformado em algo equivalente a isso:"],["br"]],["code","java",["br"],["code-text","public Object invoke(Object par01) {"],["br"],["code-text","  return (Object)(par01"],["br"],["code-text","                    .getClass()"],["br"],["code-text","                    .getDeclaredMethod(\"toUpperCase\", null)"],["br"],["code-text","                    .invoke(par01));"],["br"],["code-text","}"],["br"],["code-text","(new user$upper_case()).invoke(\"umba umba umba ê\");"],["br"],["code-text","// \"UMBA UMBA UMBA Ê\""],["br"]],["paragraph",["br"]],["paragraph",["text","Eu disse "],["italic",["text","equivalente"]],["text"," porque o seu código Clojure vai ser compilado diretamente para "],["italic",["text","bytecode"]],["text"," ao invés de ser convertido primeiro para código Java."],["br"]],["paragraph",["text","Como podemos notar, além de termos que invocar três métodos para fazer a chamada de um e termos que fazer "],["italic",["text","typecasting"]],["text"," - ou "],["italic",["text","coerção de tipos"]],["text",", se preferir - para que tudo seja tratado como "],["monospaced",["text","Object"]],["text",", o próprio processo de "],["italic",["text","reflection"]],["text"," é lento por si só."],["br"]],["paragraph",["text","Note como informamos o nome do método "],["monospaced",["text","toUpperCase"]],["text"," como um texto. Com isso o método "],["monospaced",["text","getDeclaredMethod"]],["text"," vai pesquisar uma tabela interna daquela objeto comparando cada nome de método até encontrar o que procuramos."],["br"]],["paragraph",["text","Para ajudar, como o Clojure não tem a mais remota ideia do que queremos transformar em letras maiúsculas, a função aceita qualquer coisa."],["br"]],["code","clojure",["br"],["code-text","(upper-case 3.14159)"],["br"],["code-text","; IllegalArgumentException No matching field found: toUpperCase for"],["br"],["code-text","; class java.lang.Double"],["br"]],["paragraph",["br"]],["paragraph",["italic",["text","Ah, então o compilador do Clojure é mal feito?"]],["br"]],["paragraph",["text","Não. Acontece algo muito parecido quando escrevemos código JavaScript, Ruby, Python ou qualquer outra linguagem dinâmica para a JVM. Como você não informou o tipo, o compilador tem que adivinhar ou confiar cegamente no que você está dizendo."],["br"]],["paragraph",["text","Porém, existe uma forma de diminuir essa trabalheira toda dando dicas ao compilador sobre o tipo de dado que ele deve utilizar. Essas dicas chamam-se "],["italic",["text","type hints"]],["text",", ou dicas de tipos."],["br"]],["paragraph",["text","Mas atenção: que fique claro que estamos dando dicas ao compilador ao invés de declararmos estaticamente o tipo de dados que estamos utilizando."],["br"]],["paragraph",["text","Podemos reescrever nosso código dessa forma para que o compilador receba nossas dicas:"],["br"]],["code","clojure",["br"],["code-text","(defn upper-case [^String text]"],["br"],["code-text","  (.toUpperCase text))"],["br"],["code-text","(upper-case \"umba umba umba ê\")"],["br"],["code-text","; \"UMBA UMBA UMBA Ê\""],["br"]],["paragraph",["br"]],["paragraph",["text","Essa marcação "],["monospaced",["text","^String"]],["text"," antes do tipo indica ao compilador que "],["monospaced",["text","text"]],["text"," deve ser do tipo "],["monospaced",["text","java.lang.String"]],["text",". Se tentarmos passar qualquer coisa diferente de "],["monospaced",["text","String"]],["text",", a JVM vai reclamar na mesma hora."],["br"]],["code","clojure",["br"],["code-text","(upper-case 3.14159)"],["br"],["code-text","; ClassCastException java.lang.Double cannot be cast to"],["br"],["code-text","; java.lang.String  user/upper-case (NO_SOURCE_FILE:2)"],["br"]],["paragraph",["br"]],["paragraph",["text","Aí você pensa "],["italic",["text","ah, tá. era para ter passado "],["monospaced",["text","String"]],["text"," e passei "],["monospaced",["text","Double"]]],["text",". Bonito, não?"],["br"]],["paragraph",["text","Mas não é só isso. Ao usar "],["italic",["text","type hints"]],["text"," você ainda leva uma otimização de código totalmente de graça."],["br"]],["paragraph",["text","O "],["italic",["text","bytecode"]],["text"," gerado fica equivalente a esse código Java:"],["br"]],["code","java",["br"],["code-text","public Object invoke(Object par01) {"],["br"],["code-text","  return ((String)par01).toUpperCase();"],["br"],["code-text","}"],["br"],["code-text","(new user$upper_case()).invoke(\"umba umba umba ê\");"],["br"],["code-text","// \"UMBA UMBA UMBA Ê\""],["br"]],["paragraph",["br"]],["paragraph",["text","Se você imaginou que o código, além de menor, também ficou mais rápido, acertou."],["br"]],["paragraph",["italic",["text","Então vou usar isso no meu código inteiro!"]],["br"]],["paragraph",["text","Calma lá. Clojure não deixa de ser uma linguagem dinâmica apenas por ter "],["italic",["text","type hints"]],["text",". A contrapartida dessas dicas é que elas poluem o código e dificilmente você vai precisar que todo seu código seja otimizado."],["br"]],["title",["text","Quando otimizar"]],["paragraph",["br"]],["paragraph",["text","Não adianta sair adicionando "],["italic",["text","type hints"]],["text"," no código sem critério. A primeira coisa a ser feita é detectar onde estão os gargalos, os pontos que consomem mais recursos sem trazer resultados imediatos."],["br"]],["paragraph",["text","Uma vez que você localize os pontos lentos da aplicação, adicione a seguinte linha no início do seu código:"],["br"]],["code","clojure",["br"],["code-text","(set! *warn-on-reflection* true)"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora o compilador vai nos avisar toda vez que for obrigado a usar "],["italic",["text","reflection"]],["text"," para invocar um método ou acessar um membro."],["br"]],["paragraph",["text","Vamos usar a nossa função "],["monospaced",["text","upper-case"]],["text"," para detectar os pontos que podem ser otimizados com "],["italic",["text","type hinting"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(set! *warn-on-reflection* true)"],["br"],["code-text","(defn upper-case [text]"],["br"],["code-text","  (.toUpperCase text))"],["br"],["code-text","; Reflection warning, NO_SOURCE_PATH:2:3 - reference to field"],["br"],["code-text","; toUpperCase can't be resolved."],["br"],["code-text","; #'user/upper-case"],["br"]],["paragraph",["br"]],["paragraph",["text","Essa é a mensagem do compilador nos avisando que não sabe que tipo contém o método "],["monospaced",["text","toUpperCase"]],["text",". Como estamos usando "],["monospaced",["text","toUpperCase"]],["text"," em "],["monospaced",["text","text"]],["text",", vamos adicionar o "],["italic",["text","type hint"]],["text"," nele."],["br"]],["paragraph",["text","Perceba que o erro ocorreu durante a compilação da função, e não durante sua execução. Lembre-se que todo código executado já foi compilado em algum momento, incluindo o código que escrevemos no "],["italic",["text","REPL"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn upper-case-2 [^String text]"],["br"],["code-text","  (.toUpperCase text))"],["br"],["code-text","; #'user/upper-case-2"],["br"],["code-text","(upper-case-2 \"umba umba umba ê\")"],["br"],["code-text","; \"UMBA UMBA UMBA Ê\""],["br"]],["paragraph",["br"]],["paragraph",["text","Sem erros nem avisos, resolvemos a questão do "],["italic",["text","reflection"]],["text"," na expressão."],["br"]],["paragraph",["text","Falamos sobre otimização e gargalos mas não mostramos na prática o que isso significa."],["br"]],["paragraph",["text","Vamos posicionar as duas funções, com e sem "],["italic",["text","type hint"]],["text"," e executar uma iteração apresentando o tempo gasto com cada versão."],["br"]],["code","clojure",["br"],["code-text","(defn upper-case [texto]"],["br"],["code-text","  (.toUpperCase texto))"],["br"],["code-text","; Reflection warning, NO_SOURCE_PATH:2:3 - reference to field"],["br"],["code-text","; toUpperCase can't be resolved."],["br"],["code-text","; #'user/upper-case"],["br"],["code-text","(defn upper-case-2 [^String texto]"],["br"],["code-text","  (.toUpperCase texto))"],["br"],["code-text","; #'user/upper-case-2"],["br"],["code-text","(time (dotimes [_ 100000] (upper-case \"mandarina\")))"],["br"],["code-text","; \"Elapsed time: 327.720765 msecs\""],["br"],["code-text","(time (dotimes [_ 100000] (upper-case-2 \"mandarina\")))"],["br"],["code-text","; \"Elapsed time: 55.403849 msecs\""],["br"]],["paragraph",["br"]],["paragraph",["text","Nesse nosso exemplo simples o processamento ficou de seis a sete vezes mais rápido."],["br"]],["paragraph",["text","Essa marcação de "],["italic",["text","type hint"]],["text"," é tratada como um metadado, sendo que os códigos abaixo são equivalentes:"],["br"]],["code","clojure",["br"],["code-text","(defn upper-case-2 [^String texto]"],["br"],["code-text","  (.toUpperCase texto))"],["br"],["code-text","(defn upper-case-3 [^{String true} texto]"],["br"],["code-text","  (.toUpperCase texto))"],["br"]],["paragraph",["br"]],["paragraph",["text","A forma utilizada em "],["monospaced",["text","upper-case-2"]],["text"," é preferida, mais limpa e mais concisa."],["br"]],["section",["text","Usando tipos primitivos"]],["paragraph",["br"]],["paragraph",["text","Vimos que utilizar "],["italic",["text","type hints"]],["text"," com objetos não tem segredo, bastando colocar o nome da classe como uma marcação no argumento da função."],["br"]],["paragraph",["text","Para utilizarmos "],["italic",["text","type hints"]],["text"," com tipos primitivos o procedimento é praticamente o mesmo, mas você precisa conhecer as marcações especiais para cada tipo de dado."],["br"]],["paragraph",["text","Podemos forçar o uso de tipos primitivos para ganharmos velocidade no código, ou para manter a compatibilidade com bibliotecas que já existam."],["br"]],["index",["text","byte"]],["paragraph",["br"]],["index",["text","char"]],["paragraph",["br"]],["index",["text","int"]],["paragraph",["br"]],["index",["text","double"]],["paragraph",["br"]],["index",["text","float"]],["paragraph",["br"]],["index",["text","short"]],["paragraph",["br"]],["index",["text","boolean"]],["paragraph",["br"]],["index",["text","bytes"]],["paragraph",["br"]],["index",["text","chars"]],["paragraph",["br"]],["index",["text","ints"]],["paragraph",["br"]],["index",["text","doubles"]],["paragraph",["br"]],["index",["text","floats"]],["paragraph",["br"]],["index",["text","shorts"]],["paragraph",["br"]],["index",["text","booleans"]],["paragraph",["br"]],["paragraph",["text","Para isso usamos as anotações "],["monospaced",["text","^byte"]],["text",", "],["monospaced",["text","^char"]],["text",", "],["monospaced",["text","^int"]],["text",", %^double"],["monospaced",["text",", "]],["text","^float"],["monospaced",["text",", "]],["text","^short"],["monospaced",["text"," e "]],["text","^boolean"],["monospaced",["text"," se estivermos lidando com valores escalares, e "]],["text","^bytes"],["monospaced",["text",", "]],["text","^chars"],["monospaced",["text",", "]],["text","^ints"],["monospaced",["text",", %^doubles"]],["text",", "],["monospaced",["text","^floats"]],["text"," e "],["monospaced",["text","^shorts"]],["text"," ao lidarmos com "],["italic",["text","arrays"]],["text"," dos respectivos tipos. Note o símbolo de "],["monospaced",["text","^"]],["text"," antes do nome do tipo e seu respectivo o plural quando estamos falando de "],["italic",["text","arrays"]],["text","."],["br"]],["paragraph",["text","Vale lembrar que um "],["italic",["text","array"]],["text"," Java é diferente de um vetor Clojure. Um "],["italic",["text","array"]],["text"," Java é um tipo primitivo e mutável, criado para acesso rápido a seus itens e consumo mínimo de memória, enquanto um vetor do Clojure é uma estrutura imutável e persistente, criada para equilibrar confiabilidade em ambientes concorrentes com melhor aproveitamento de memória."],["br"]],["box",["text","Tipos primitivos e objetos"],["paragraph",["br"]],["paragraph",["text","Lá no início, quando o Java ainda se chamava "],["italic",["text","Oak"]],["ref",["text","oak-language"]],["text",", seu principal foco era ser um ambiente e uma linguagem de programação para dispositivos móveis e eletrodomésticos. Como a memória e o processamento desses dispositivos são escassos, a solução foi separar os dados numéricos e lógicos em "],["italic",["text","tipos primitivos"]],["text"," e deixar o resto como especializações da classe "],["monospaced",["text","Object"]],["text","."],["br"]],["paragraph",["text","Tipos primitivos ocupam menos memória e permitem operações aritméticas mais rápidas, mas conforme as aplicações foram aumentando de tamanho e a memória deixando de ser um problema, foi necessário criar classes equivalentes aos tipos primitivos, chamadas de "],["italic",["text","wrappers"]],["text",". Essas classes "],["italic",["text","wrapper"]],["text"," são usadas também pelo Clojure."],["br"]]],["paragraph",["br"]],["paragraph",["text","Para convertermos um valor, basta usarmos uma função que tenha o mesmo nome do tipo primitivo: "],["monospaced",["text","byte"]],["text",", "],["monospaced",["text","char"]],["text",", "],["monospaced",["text","int"]],["text",", "],["monospaced",["text","double"]],["text",", "],["monospaced",["text","float"]],["text",", "],["monospaced",["text","short"]],["text"," e "],["monospaced",["text","boolean"]],["text",", respectivamente."],["br"]],["code","clojure",["br"],["code-text","(let [^ints numeros (int-array 10)]"],["br"],["code-text","  (println numeros)"],["br"],["code-text","; #<int[] [I@260c1645>"],["br"],["code-text","  (println (.getBytes \"Clojure\")))"],["br"],["code-text","; #<byte[] [B@709724c7>"],["br"],["code-text",";; ]"],["br"]],["paragraph",["br"]],["index",["text","byte-array"]],["paragraph",["br"]],["index",["text","char-array"]],["paragraph",["br"]],["index",["text","int-array"]],["paragraph",["br"]],["index",["text","double-array"]],["paragraph",["br"]],["index",["text","float-array"]],["paragraph",["br"]],["index",["text","short-array"]],["paragraph",["br"]],["index",["text","boolean-array"]],["paragraph",["br"]],["paragraph",["text","Usamos a função "],["monospaced",["text","int-array"]],["text"," para criarmos um "],["italic",["text","array"]],["text"," de "],["monospaced",["text","int"]],["text",". Você pode usar os tipos primitivos que citamos seguido de "],["monospaced",["text","-array"]],["text"," para descobrir o nome da função que cria um "],["italic",["text","array"]],["text"," de um tipo primitivo."],["br"]],["index",["text","to-array"]],["paragraph",["br"]],["index",["text","into-array"]],["paragraph",["br"]],["paragraph",["text","Para convertermos uma sequencia em um "],["italic",["text","array"]],["text",", podemos utilizar as funções "],["monospaced",["text","to-array"]],["text"," e "],["monospaced",["text","into-array"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(def numeros (range 1 11))"],["br"],["code-text","(to-array numeros)"],["br"],["code-text","; #<Object[] [Ljava.lang.Object;@47cd705>"],["br"],["code-text",";; ]"],["br"]],["paragraph",["br"]],["paragraph",["text","O problema de "],["monospaced",["text","to-array"]],["text"," é que ele nos retorna um "],["italic",["text","array"]],["text"," de "],["monospaced",["text","Object"]],["text",", já que todos os valores em Clojure são tratados como "],["monospaced",["text","Object"]],["text"," por padrão."],["br"]],["paragraph",["text","Note o nome que o Java retorna para esse "],["italic",["text","array"]],["text"," de objetos."],["br"]],["code",["br"],["code-text","[Ljava.lang.Object;@47cd705"],["br"],["code-text",";;]"],["br"]],["paragraph",["br"]],["paragraph",["text","Temos um caracter "],["monospaced",["text","▷"]],["text",", que indica que estamos lidando com um "],["italic",["text","array"]],["text"," de uma posição, e "],["monospaced",["text","L"]],["text"," que indica que é do tipo "],["monospaced",["text","Object"]],["text",". Não me perguntem porque é "],["monospaced",["text","L"]],["text"," ao invés de "],["monospaced",["text","O"]],["text",", porque eu também queria saber."],["br"]],["paragraph",["text","Em seguida temos o nome da classe, "],["monospaced",["text","java.lang.Object"]],["text"," e a referência do objeto após a arroba."],["br"]],["paragraph",["text","Para criarmos um "],["italic",["text","array"]],["text"," de um tipo específico precisamos utilizar a função "],["monospaced",["text","into-array"]],["text",". Para isso precisamos informar o tipo que queremos usando o campo "],["monospaced",["text","TYPE"]],["text"," do respectivo "],["italic",["text","wrapper"]],["text","."],["br"]],["paragraph",["text","Se quisermos um "],["italic",["text","array"]],["text"," de "],["monospaced",["text","int"]],["text",", precisamos usar "],["monospaced",["text","Integer/TYPE"]],["text",". De "],["monospaced",["text","long"]],["text"," devemos usar "],["monospaced",["text","Long/TYPE"]],["text"," e assim por diante."],["br"]],["code","clojure",["br"],["code-text","(into-array Integer/TYPE numeros)"],["br"],["code-text","; #<int[] [I@4202c561>"],["br"],["code-text","(into-array Long/TYPE numeros)"],["br"],["code-text","; #<long[] [J@18f7a9d0>"],["br"],["code-text",";;]"],["br"]],["paragraph",["br"]],["paragraph",["text","Todos os itens da sequencia devem ter o mesmo tipo, uma vez que um "],["italic",["text","array"]],["text"," Java é uma estrutura que permite apenas um tipo de dado."],["br"]],["paragraph",["text","Note o nome interno do objeto que é retornado por "],["monospaced",["text","into-array"]],["text",": "],["monospaced",["text","▷I"]],["text"," indica um "],["italic",["text","array"]],["text"," de "],["monospaced",["text","int"]],["text",", enquanto "],["monospaced",["text","▷J"]],["text"," indica um "],["italic",["text","array"]],["text"," de "],["monospaced",["text","long"]],["text",". Da mesma forma temos "],["monospaced",["text","▷C"]],["text"," para "],["monospaced",["text","char"]],["text",", "],["monospaced",["text","▷S"]],["text"," para "],["monospaced",["text","short"]],["text",", "],["monospaced",["text","▷Z"]],["text"," para "],["monospaced",["text","boolean"]],["text"," (também não me pergunte o porquê), "],["monospaced",["text","▷F"]],["text"," para "],["monospaced",["text","float"]],["text"," e "],["monospaced",["text","▷D"]],["text"," para "],["monospaced",["text","double"]],["text",". Esse nome interno é um padrão da "],["italic",["text","JVM"]],["text"," e vai ser encontrado tanto no Clojure quanto no Java puro."],["br"]],["paragraph",["text","Se tivermos um "],["italic",["text","array"]],["text"," de duas dimensões, teremos dois caracteres "],["monospaced",["text","▷"]],["text"," e assim por diante, seguidos da letra que indica o tipo armazenado pelo vetor."],["br"]],["paragraph",["text","Vamos usar "],["monospaced",["text","make-array"]],["text"," para criar "],["italic",["text","arrays"]],["text"," de quantas dimensões quisermos e a função "],["monospaced",["text","alength"]],["text"," vai nos dizer o tamanho do vetor ou matriz."],["br"]],["code","clojure",["br"],["code-text","(def vetor (make-array Integer/TYPE 1000))"],["br"],["code-text","(alength vetor)"],["br"],["code-text","; 1000"],["br"],["code-text","(def matriz-10-15 (make-array Integer/TYPE 10 15))"],["br"],["code-text","(alength matriz-10-15)"],["br"],["code-text","; 10"],["br"],["code-text","(alength (aget matriz-10-15 0))"],["br"],["code-text","; 15"],["br"],["code-text","user=> (type matriz-10-15)"],["br"],["code-text","; [[I"],["br"],["code-text",";;]"],["br"]],["paragraph",["br"]],["paragraph",["text","Note que o tipo da matriz é "],["monospaced",["text","▷▷I"]],["text",", que indica que temos uma matriz de duas dimensões do tipo "],["monospaced",["text","int"]],["text","."],["br"]],["paragraph",["text","Como dissemos anteriormente, tipos primitivos permitem que operações aritméticas sejam executadas com maior velocidade e menor consumo de memória."],["br"]],["paragraph",["text","Primeiro vamos reaproveitar nosso projeto "],["monospaced",["text","integracao"]],["text"," e adicionar um método à classe Java "],["monospaced",["text","meu.codigo.java.MinhaClasse"]],["text",":"],["br"]],["code","java",["br"],["code-text","  public static long soma(long a, long b) {"],["br"],["code-text","    return a + b;"],["br"],["code-text","  }"],["br"]],["paragraph",["br"]],["paragraph",["text","Esse método vai nos ser útil para efetuarmos uma soma entre valores primitivos."],["br"]],["index",["text","areduce"]],["paragraph",["br"]],["paragraph",["text","Vamos criar uma lista com um milhão de números e também um "],["italic",["text","array"]],["text"," de "],["monospaced",["text","long"]],["text"," com os mesmos valores."],["br"]],["code","clojure",["br"],["code-text","(def numeros (range 0 1000000))"],["br"],["code-text","(def vetor (into-array Long/TYPE numeros))"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos calcular a soma de todos os itens da lista e do "],["italic",["text","array"]],["text",". Para isso vamos usar "],["monospaced",["text","reduce"]],["text"," com a lista, "],["monospaced",["text","reduce"]],["text"," com o "],["italic",["text","array"]],["text"," e a macro "],["monospaced",["text","areduce"]],["text",", que serve especificamente para processar informações em "],["italic",["text","arrays"]],["text"," de tipos primitivos."],["br"]],["paragraph",["text","Para medir o tempo de cada execução, vamos criar uma macro que executa mil vezes o trecho de código informado e retorna o tempo gasto na execução. É necessário executar várias vezes para tentarmos tirar a influência das otimizações da "],["italic",["text","JVM"]],["text"," da conta."],["br"]],["paragraph",["text","Após algumas execuções com o mesmo resultado, a "],["italic",["text","JVM"]],["text"," faz uma otimização chamada "],["italic",["text","inlining"]],["text",", que reduz muito o tempo de execução do cóigo. Se simplesmente executarmos um código depois do outro, existe sempre a possibilidade da primeira execução ser bem mais lenta que as demais por conta disso."],["br"]],["code","clojure",["br"],["code-text","(defmacro benchmark [code]"],["br"],["code-text","  `(time (first (doall (repeatedly 1000 (fn [] ~code))))))"],["br"]],["paragraph",["br"]],["code","clojure",["br"],["code-text","(benchmark (reduce + numeros))"],["br"],["code-text","; \"Elapsed time: 6678.846631 msecs\""],["br"],["code-text","(benchmark (reduce + vetor))"],["br"],["code-text","; \"Elapsed time: 36814.423599 msecs\""],["br"],["code-text","(benchmark (areduce ^long vetor"],["br"],["code-text","                    idx"],["br"],["code-text","                    ret"],["br"],["code-text","                    0"],["br"],["code-text","                    (MinhaClasse/soma ret"],["br"],["code-text","                                    ^long (aget ^longs vetor idx))))"],["br"],["code-text","\"Elapsed time: 1941.822068 msecs\""],["br"]],["paragraph",["br"]],["paragraph",["text","As duas operações que usam o "],["italic",["text","array"]],["text"," são, ao mesmo tempo, muito mais lenta e muito mais rápida, e é por isso que devemos tomar cuidado ao utilizar valores primitivos para ganhar velocidade."],["br"]],["index",["text","autoboxing"]],["paragraph",["br"]],["paragraph",["text","Quando utilizamos "],["monospaced",["text","reduce"]],["text"," com o "],["italic",["text","array"]],["text",", cada um dos valores inteiros primitivos é convertido para seu respectivo "],["italic",["text","wrapper"]],["text",", a classe "],["monospaced",["text","Integer"]],["text",". Essa conversão é feita automaticamente pela própria "],["italic",["text","JVM"]],["text"," e chama-se "],["italic",["text","autoboxing"]],["text","."],["br"]],["index",["text","boxing"]],["paragraph",["br"]],["index",["text","unboxing"]],["paragraph",["br"]],["paragraph",["text","Converter um valor primitivo para um "],["italic",["text","wrapper"]],["text"," chama-se "],["italic",["text","boxing"]],["text"," e o caminho contrário chama-se "],["italic",["text","unboxing"]],["text","."],["br"]],["paragraph",["text","O "],["italic",["text","array"]],["text",", que por si só também é uma estrutura primitiva, é convertido internamente para uma sequencia do Clojure, o que também consome tempo. No final das contas, o que achamos que seria mais eficiente acaba sendo seis vezes mais lento."],["br"]],["paragraph",["text","Já quando usamos "],["monospaced",["text","reduce"]],["text"," com uma sequencia contendo objetos, não existe a necessidade de "],["italic",["text","autoboxing"]],["text"," nem de criar uma nova estrutura de dados."],["br"]],["paragraph",["text","Já com "],["monospaced",["text","areduce"]],["text"," a situação é diferente, já que é uma macro que trabalha sem converter o "],["italic",["text","array"]],["text"," para uma sequencia e também sem perder tempo com "],["italic",["text","autoboxing"]],["text","."],["br"]],["paragraph",["text","Mas, se velocidade for algo realmente crítico, experimente escrever o código diretamente em Java e chamá-lo no Clojure."],["br"]],["paragraph",["text","Vamos criar um método em Java e executar o teste de velocidade sob as mesmas condições dos anteriores."],["br"]],["code","java",["br"],["code-text","  public static long somaArray(long[] vetor) {"],["br"],["code-text","    long soma = 0;"],["br"],["code-text","    for (long i = 0; i < vetor.length; i++) {"],["br"],["code-text","      soma += vetor[i];"],["br"],["code-text","    }"],["br"],["code-text","    return soma;"],["br"],["code-text","  }"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos executar o nosso método recém-criado."],["br"]],["code","clojure",["br"],["code-text","(benchmark (MinhaClasse/somaArray ^ints vetor))"],["br"],["code-text","; \"Elapsed time: 53.776577 msecs\""],["br"]],["paragraph",["br"]],["paragraph",["text","Nosso código em Java puro foi "],["italic",["text","126"]],["text"," vezes mais rápido que a versão usando sequencia e "],["monospaced",["text","reduce"]],["text",", e "],["italic",["text","36"]],["text"," vezes mais rápido que a versão utilizando "],["italic",["text","array"]],["text"," e tipos primitivos."],["br"]],["paragraph",["text","Ah, então Clojure é lento? Nesse caso específico ganhamos muito mais escrevendo a operação diretamente no Java, mas você precisa pesar todas as suas necessidades, o seu tempo de desenvolvimento e a quantidade de problemas que você pode ter sem as abstrações já testadas do Clojure."],["br"]],["paragraph",["text","A minha opinião, se você quiser saber, é que você deve conhecer as ferramentas que tem para saber qual usar no melhor momento. Nesse último exemplo nós usamos o melhor de cada mundo para chegar ao melhor resultado possível."],["br"]],["paragraph",["text","No final, antes mesmo de otimizar, pergunte-se se realmente vale a pena investir tempo, e dinheiro do projeto ou da empresa, para ganhar tempo naquele trecho de código em específico. Quase sempre a resposta é um "],["italic",["text","não"]],["text"," bem sonoro."],["br"]],["paragraph",["text","Para encerrar o assunto, vamos às limitações do uso de tipos primitivos. Você deve estar se perguntando por que então não usamos tipos primitivos para tudo?"],["br"]],["paragraph",["text","A resposta curta é "],["italic",["text","não"]],["text","."],["br"]],["paragraph",["text","Primeiro temos a questão da perda de "],["italic",["text","performance"]],["text"," quando utilizamos tipos primitivos e ocorre "],["italic",["text","autoboxing"]],["text","."],["br"]],["paragraph",["text","Como vimos, além de poluirmos o código com "],["italic",["text","type hints"]],["text"," ainda temos um código mais lento quando não utilizamos tipos primitivos corretamente."],["br"]],["paragraph",["text","Depois temos uma limitação do próprio Clojure, onde uma função não pode ter mais de quatro parâmetros com tipos primitivos."],["br"]],["paragraph",["text","Vamos escrever uma função chamada "],["monospaced",["text","hypo2d"]],["text",", onde calculamos a "],["italic",["text","hipotenusa"]],["text"," de um triângulo retângulo."],["br"]],["paragraph",["text","A hipotenusa nada mais é do que a diagonal entre dois segmentos de reta perpendiculares. Esses dois segmentos são chamados "],["italic",["text","catetos"]],["text","."],["br"]],["index",["text","Teorema de Pitágoras"]],["paragraph",["br"]],["paragraph",["text","O tamanho da hipotenusa é igual à raiz quadrada da soma dos quadrados dos catetos. Essa fórmula é conhecida como "],["italic",["text","Teorema de Pitágoras"]],["text","."],["br"]],["index",["text","java.lanh.Math"]],["paragraph",["br"]],["index",["text","pow"]],["paragraph",["br"]],["index",["text","sqrt"]],["paragraph",["br"]],["paragraph",["text","Para calcularmos a potência de um número vamos usar a função Java "],["monospaced",["text","pow"]],["text",", e para calcularmos a raiz quadrada vamos utilizar o método "],["monospaced",["text","sqrt"]],["text",", ambos pertencentes à classe "],["monospaced",["text","java.lang.Math"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn hypo2d [^double x1 ^double y1"],["br"],["code-text","              ^double x2 ^double y2]"],["br"],["code-text","  (Math/sqrt (+ (Math/pow (- x2 x1) 2)"],["br"],["code-text","                (Math/pow (- y2 y1) 2))))"],["br"],["code-text","(hypo2d 0 0 3 4)"],["br"],["code-text","; 5.0"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora vamos calcular a diagonal de um paralelepípedo. Para isso vamos extrapolar o "],["italic",["text","Teorema de Pitágoras"]],["text"," para trabalhar com três dimensões ao invés de duas."],["br"]],["paragraph",["text","Para chegarmos nesse valor precisamos calcular a raiz cúbica da soma dos quadrados das arestas do paralelepípedo."],["br"]],["paragraph",["text","Só para lembrar, um cubo é um paralelepípedo cujas arestas tem o mesmo tamanho nas três dimensões."],["br"]],["code","clojure",["br"],["code-text","(defn hypo3d [^double x1 ^double y1"],["br"],["code-text","              ^double z1 ^double x2"],["br"],["code-text","              ^double y2 ^double z2]"],["br"],["code-text","  (Math/pow (+ (Math/pow (- x2 x1) 2)"],["br"],["code-text","               (Math/pow (- y2 y1) 2)"],["br"],["code-text","               (Math/pow (- z2 z1) 2))"],["br"],["code-text","            1/3))"],["br"],["code-text","; CompilerException java.lang.IllegalArgumentException:"],["br"],["code-text","; fns taking primitives support only 4 or fewer args"],["br"]],["paragraph",["br"]],["paragraph",["text","Não podemos utilizar tipos primitivos nesse caso, mas se escrevermos o código utilizando os tipos do próprio Clojure, a nossa função compila e executa sem problemas."],["br"]],["code","clojure",["br"],["code-text","(defn hypo3d [x1 y1"],["br"],["code-text","              z1 x2"],["br"],["code-text","              y2 z2]"],["br"],["code-text","  (Math/pow (+ (Math/pow (- x2 x1) 2)"],["br"],["code-text","               (Math/pow (- y2 y1) 2)"],["br"],["code-text","               (Math/pow (- z2 z1) 2))"],["br"],["code-text","            1/3))"],["br"],["code-text","(hypo3d 0 0 0 1 1 1)"],["br"],["code-text","; 1.4422495703074083"],["br"]],["paragraph",["br"]],["section",["text","Polimorfismo com interfaces"]],["paragraph",["br"]],["paragraph",["text","Por mais que a programação funcional nos permita resolver qualquer problema que possa ser resolvido com orientação a objetos, não podemos fechar os olhos para o fato de que um lado tem muito a aprender com o outro e que, apesar de Clojure não ser uma linguagem híbrida como acontece com "],["italic",["text","JavaScript"]],["text"," e "],["italic",["text","Scala"]],["text",", e apesar de ser uma linguagem dinâmica, podemos fazer uso de interfaces para garantir que uma estrutura de dados vai obedecer a um contrato predeterminado."],["br"]],["paragraph",["text","A forma mais próxima ao modo de trabalhar do Java, é usando interfaces. Uma interface define o conjunto mínimo de características que a estrutura de dados, classe ou objeto, precisa ter para ser aceito. É um contrato que deve ser cumprido para que um objeto seja aceito como uma implementação de um determinado tipo ou classe."],["br"]],["paragraph",["text","Vamos pensar em um polígono e que características ele precisa ter para ser aceito como tal."],["br"]],["paragraph",["text","Só para deixar claro, um polígono é uma forma geométrica fechada bidimensional formada por linhas retas"],["ref",["text","elementos"]],["text",", o que exclui segmentos de retas, círculos, elípses."],["br"]],["paragraph",["text","Um polígono precisa ter uma quantidade de arestas e cada aresta deve ter um tamanho, então já temos aqui duas características. Um polígono tem também perímetro, área e o nosso vai ter também um nome."],["br"]],["paragraph",["text","As precondições que exigem que o polígono tenha pelo menos três arestas, que o tamanho de cada aresta seja maior que zero e que suas dimesnões devem ser suficientes para que a figura fique fechada podem ficar por conta da função que vai criá-los para nós ou da função que você achar mais conveniente."],["br"]],["index",["text","Interfaces"]],["paragraph",["br"]],["title",["text","Interfaces"]],["paragraph",["br"]],["paragraph",["text","Vamos então criar uma interface Java que atenda a essas características, e para isso vamos usar o operador "],["monospaced",["text","definterface"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(definterface Poligono"],["br"],["code-text","  (^String nome      [])"],["br"],["code-text","  (arestas           [])"],["br"],["code-text","  (^long   vertices  [])"],["br"],["code-text","  (^double perimetro [])"],["br"],["code-text","  (^double area      []))"],["br"],["code-text","; user.Poligono"],["br"]],["paragraph",["br"]],["paragraph",["text","Criamos cinco propriedades em forma de método, todos sem nenhum argumento, com seus respectivos tipos, com exceção de "],["monospaced",["text","arestas"]],["text",". Como não definimos um tipo nesse caso, o retorno do método é definido como "],["monospaced",["text","Object"]],["text","."],["br"]],["paragraph",["text","Vamos então implementar uma função "],["monospaced",["text","criar-quadrado"]],["text",", que gera quadrados do tamanho que quisermos."],["br"]],["code","clojure",["br"],["code-text","(defn criar-quadrado [^double lado]"],["br"],["code-text","  {:pre  [(> lado 0)]}"],["br"],["code-text","  (reify user.Poligono"],["br"],["code-text","    (nome [this]  \"quadrado\")"],["br"],["code-text","    (arestas [this]"],["br"],["code-text","      [lado lado lado lado])"],["br"],["code-text","    (vertices [this]"],["br"],["code-text","      (count (.arestas this)))"],["br"],["code-text","    (perimetro [this]"],["br"],["code-text","      (reduce + (.arestas this)))"],["br"],["code-text","    (area [this]"],["br"],["code-text","      (* lado lado))))"],["br"],["code-text","(def quadrado-3 (criar-quadrado 3.0))"],["br"],["code-text","(.area quadrado-3)"],["br"],["code-text","; 9.0"],["br"],["code-text","(.vertices quadrado-3)"],["br"],["code-text","; 4"],["br"],["code-text","(.perimetro quadrado-3)"],["br"],["code-text","; 12.0"],["br"],["code-text","(def quadrado-4 (criar-quadrado 4.0))"],["br"],["code-text","(.area quadrado-4)"],["br"],["code-text","; 16.0"],["br"],["code-text","(.vertices quadrado-4)"],["br"],["code-text","; 4"],["br"],["code-text","(.perimetro quadrado-4)"],["br"],["code-text","; 16"],["br"]],["paragraph",["br"]],["paragraph",["text","Lembre-se que dissemos que uma precondição para a existência de um polígono é que o tamanho das arestas deve ser maior que zero."],["br"]],["code","clojure",["br"],["code-text","(criar-quadrado 0)"],["br"],["code-text","; AssertionError Assert failed: (> lado 0)  user/criar-quadrado"],["br"]],["paragraph",["br"]],["paragraph",["text","Até aqui, nenhuma novidade. Utilizamos uma "],["italic",["text","closure"]],["text"," para armazenar o tamanho de uma aresta qualquer do quadrado para criarmos nosso objeto Java, precondição para garantirmos que os dados estão dentro das restrições, "],["italic",["text","type hints"]],["text"," para definirmos o retorno do método e o tipo de dado que vamos utilizar e "],["monospaced",["text","reify"]],["text"," para criarmos o objeto."],["br"]],["section",["text","Lidando com exceções"]],["paragraph",["br"]],["paragraph",["text","Quando escrevemos código que não trabalha diretamente com classes Java, como quando manipulamos estruturas de dados do Clojure por exemplo, não é comum termos que nos preocupar com manipulação e tratamento de exceções, como acontece em Java."],["br"]],["paragraph",["text","Porém, ao lidarmos com bibliotecas Java ou com recursos externos, como arquivos, conexões com bancos de dados ou rede, passamos a ter exatamente as mesmas preocupações e precauções que teríamos se estivessemos escrevendo código Java."],["br"]],["title",["text","Erros e exceções"]],["paragraph",["br"]],["paragraph",["text","Quando falamos da forma como erros são tratados na JVM, é comum falarmos em "],["italic",["text","lançar"]],["text"," e "],["italic",["text","capturar"]],["text"," exceções."],["br"]],["paragraph",["text","Primeiro, falamos em "],["italic",["text","exceções"]],["text"," por se tratar de um comportamento que não deveria ser regra. É um dos motivos pelo qual está conceitualmente incorreto usarmos exceções para definir o fluxo de uma aplicação."],["br"]],["index",["text","java.lang.OutOfMemoryError"]],["paragraph",["br"]],["paragraph",["text","Uma exceção é diferente de um erro, uma vez que um erro não deve ser recuperado. Um exemplo disso é quando acaba a memória disponível para a aplicação e temos um "],["monospaced",["text","OutOfMemoryError"]],["text",". Via de regra, um erro é algo fatal que vai finalizar a aplicação, enquanto uma exceção oferece uma chance de ser tratada."],["br"]],["index",["text","java.lang.Exception"]],["paragraph",["br"]],["index",["text","java.lang.Error"]],["paragraph",["br"]],["index",["text","java.lang.Throwable"]],["paragraph",["br"]],["paragraph",["text","Toda exceção herda da classe Java "],["monospaced",["text","java.lang.Exception"]],["text",", enquanto todo erro herda de "],["monospaced",["text","java.lang.Error"]],["text",". Ambos herdam de "],["monospaced",["text","java.lang.Throwable"]],["text","."],["br"]],["img",["text","images/capitulo_08/exceptions.jpg \"Diagrama de exceções na JVM\" label=cap08-exceptions w=80%"]],["paragraph",["br"]],["title",["text","Lançando exceções"]],["paragraph",["br"]],["paragraph",["monospaced",["text","Throwable"]],["text",", em português, significa "],["italic",["text","algo que pode ser arremessado ou lançado"]],["text",". Para entender o porque desse nome, vamos olhar para a "],["italic",["text","pilha de execução"]],["text",", ou "],["italic",["text","pilha de chamadas"]],["text",", de uma aplicação na JVM."],["br"]],["paragraph",["text","Quando você inicia uma aplicação, temos uma pilha de chamadas vazia. O primeiro método a ser executado, conhecido por "],["italic",["text","entrypoint"]],["text",", é inserido na pilha, numa posição imediatamente abaixo."],["br"]],["paragraph",["text","Quando algum método (ou função) é executado, ele também é inserido na pilha de chamadas. Se esse método chama outro método, esse outro também vai para a pilha e assim por diante."],["br"]],["index",["text","java.lang.StackOverflowError"]],["paragraph",["br"]],["paragraph",["text","Essa pilha tem um tamanho fixo predeterminado pela JVM. Quando a pilha fica cheia e tentamos colocar mais um item, temos um "],["monospaced",["text","StackOverflowError"]],["text",", ou "],["italic",["text","estouro de pilha"]],["text",". É o que acontece quando uma função chama a si mesma indefinidamente sem o uso de "],["italic",["text","tail call recursion"]],["text","."],["br"]],["paragraph",["text","Quando ocorre algum problema na execução de um desses métodos, uma exceção é lançada. Isso significa que algo que não é o comportamento padrão causou um problema e a notificação desse problema foi jogada para cima. Sim, "],["italic",["text","lançar"]],["text"," é exatamente isso: jogar o problema para cima, para que o método imediatamente acima na pilha se vire para resolver."],["br"]],["paragraph",["text","Se esse método imediatamente acima não tratar a exceção, ela é lançada para o método acima, e assim por diante até chegar ao topo da pilha. Caso a exceção não seja tratada no topo da pilha a aplicação é finalizada."],["br"]],["paragraph",["text","Por outro lado, um método pode "],["italic",["text","capturar"]],["text"," a exceção, escolhendo tratá-la, executando algum código que faça a aplicação continuar sem maiores problemas; ou pode escolher lançar novamente uma exceção, esperando que os métodos que estiverem acima na pilha de execução cuidem do problema."],["br"]],["paragraph",["text","Quando um método é finalizado normalmente ou através do lançamento de uma exceção, ele é retirado da pilha, abrindo espaço para que outro método seja alocado."],["br"]],["title",["text","Tratando e capturando exceções"]],["paragraph",["br"]],["index",["text","try"]],["paragraph",["br"]],["index",["text","catch"]],["paragraph",["br"]],["index",["text","finally"]],["paragraph",["br"]],["paragraph",["text","No Java temos, basicamente, um bloco "],["monospaced",["text","try"]],["text",", que contém o código que pode lançar a exceção, um ou mais blocos "],["monospaced",["text","catch"]],["text",", onde a exceção é "],["italic",["text","capturada"]],["text"," ("],["italic",["text","catch"]],["text"," é "],["italic",["text","capturar"]],["text"," em Inglês) e tratada, e um bloco "],["monospaced",["text","finally"]],["text",", onde fica o código que deve ser executado havendo lançamento de exceção ou não."],["br"]],["code","java",["br"],["code-text","try {"],["br"],["code-text","  acessaArquivo();"],["br"],["code-text","} catch (IOException e) {"],["br"],["code-text","  System.out.println(\"Ocorreu um problema: \" + e.getMessage());"],["br"],["code-text","} finally {"],["br"],["code-text","  System.out.println(\"Essa linha vai aparecer sempre\");"],["br"],["code-text","}"],["br"]],["paragraph",["br"]],["paragraph",["text","Um bloco "],["monospaced",["text","try"]],["text"," pode estar acompanhado por um ou mais blocos "],["monospaced",["text","catch"]],["text"," e/ou um bloco "],["monospaced",["text","finally"]],["text",", mas nunca sozinho."],["br"]],["paragraph",["text","No Clojure temos os mesmos operadores "],["monospaced",["text","try"]],["text",", "],["monospaced",["text","catch"]],["text"," e "],["monospaced",["text","finally"]],["text",", mas com sutis diferenças."],["br"]],["index",["text","slurp"]],["paragraph",["br"]],["paragraph",["text","Vamos começar criando uma função "],["monospaced",["text","ler-mostrar"]],["text"," que tenta ler o conteúdo de um arquivo texto para então o exibir na tela. Para isso vamos usar a função "],["monospaced",["text","slurp"]],["text",", que retorna todo o conteúdo do arquivo como texto."],["br"]],["paragraph",["text","Vamos fazer nossa função tentar abrir um arquivo que não existe para que ocorra um erro."],["br"]],["code","clojure",["br"],["code-text","(defn ler-mostrar [arquivo]"],["br"],["code-text","  (let [texto (slurp arquivo)]"],["br"],["code-text","    (println \"Conteúdo do arquivo\" arquivo)"],["br"],["code-text","    (println texto)))"],["br"],["code-text","(ler-mostrar \"batatas\")"],["br"],["code-text","; FileNotFoundException batatas (O sistema não pode encontrar o"],["br"],["code-text","; arquivo especificado)  java.io.FileInputStream.open (:-2)"],["br"]],["paragraph",["br"]],["paragraph",["text","A função "],["monospaced",["text","slurp"]],["text"," lançou uma exceção que não foi tratada pelo nosso código, então nossa função foi finalizada e a exceção lançada para quem chamou nosso código que, no nosso exemplo, foi o "],["italic",["text","REPL"]],["text","."],["br"]],["paragraph",["text","Vamos então tratar a exceção, exibindo uma mensagem de erro menos assustadora."],["br"]],["code","clojure",["br"],["code-text","(defn ler-mostrar [arquivo]"],["br"],["code-text","  (try"],["br"],["code-text","    (let [texto (slurp arquivo)]"],["br"],["code-text","      (println \"Conteúdo do arquivo\" arquivo)"],["br"],["code-text","      (println texto))"],["br"],["code-text","  (catch java.io.FileNotFoundException e"],["br"],["code-text","    (println \"Arquivo\" arquivo \"não encontrado\"))))"],["br"],["code-text","(ler-mostrar \"batatas\")"],["br"],["code-text","; Arquivo batatas não encontrado"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora a exceção foi capturada pelo bloco "],["monospaced",["text","catch"]],["text"," e pudemos exibir uma mensagem melhor."],["br"]],["paragraph",["text","Podemos utilizar também o operador "],["monospaced",["text","finally"]],["text"," para exibir uma mensagem ocorrendo erro ou não."],["br"]],["code","clojure",["br"],["code-text","(defn ler-mostrar [arquivo]"],["br"],["code-text","  (try"],["br"],["code-text","    (let [texto (slurp arquivo)]"],["br"],["code-text","      (println \"Conteúdo do arquivo\" arquivo)"],["br"],["code-text","      (println texto))"],["br"],["code-text","    (finally"],["br"],["code-text","      (println \"Essa mensagem vai aparecer de qualquer jeito\"))))"],["br"],["code-text","(ler-mostrar \"batatas\")"],["br"],["code-text","; Essa mensagem vai aparecer de qualquer jeito"],["br"],["code-text","; FileNotFoundException batatas (O sistema não pode encontrar o"],["br"],["code-text","; arquivo especificado)  java.io.FileInputStream.open (:-2)"],["br"]],["paragraph",["br"]],["paragraph",["text","Um desenvolvedor que tenha experiência com Java ou Ruby vai notar algo estranho aqui. A exceção foi exibida na tela mesmo utilizando "],["monospaced",["text","finally"]],["text",", que faz com que o código ignore a exceção quando não está acompanhada de "],["monospaced",["text","catch"]],["text","."],["br"]],["paragraph",["text","Isso acontece porque em Clojure, como já sabemos, um código é uma lista de listas, sendo cada lista a representação de uma expressão. Toda expressão retorna um valor - mesmo "],["monospaced",["text","nil"]],["text"," é um valor - e isso inclui a expressão que esteja capturando e tratando uma exceção."],["br"]],["index",["text","java.io.FileNotFoundException"]],["paragraph",["br"]],["paragraph",["text","O operador "],["monospaced",["text","try"]],["text",", por padrão, retorna a exceção que foi capturada, e por isso a função "],["monospaced",["text","ler-mostrar"]],["text"," retornou "],["monospaced",["text","FileNotFoundException"]],["text","."],["br"]],["paragraph",["text","Podemos modificar esse comportamento fazendo com que "],["monospaced",["text","catch"]],["text"," retorne um texto ao invés de uma exceção."],["br"]],["code","clojure",["br"],["code-text","(defn ler-mostrar [arquivo]"],["br"],["code-text","  (let [texto (try"],["br"],["code-text","                (slurp arquivo)"],["br"],["code-text","                (catch Exception e"],["br"],["code-text","                  (str \"== Arquivo \" arquivo \" não encontrado ==\")))]"],["br"],["code-text","    (println \"Conteúdo do arquivo\" arquivo)"],["br"],["code-text","    (println texto)))"],["br"],["code-text","(ler-mostrar \"batatas\")"],["br"],["code-text","; Conteúdo do arquivo batatas"],["br"],["code-text","; == Arquivo batatas não encontrado =="],["br"]],["paragraph",["br"]],["paragraph",["text","Podemos também utilizar o operador "],["monospaced",["text","finally"]],["text"," ao mesmo tempo que "],["monospaced",["text","catch"]],["text","."],["br"]],["code","clojure",["br"],["code-text","(defn ler-mostrar [arquivo]"],["br"],["code-text","  (let [texto (try"],["br"],["code-text","                (slurp arquivo)"],["br"],["code-text","                (catch Exception e"],["br"],["code-text","                  (str \"== Arquivo \" arquivo \" não encontrado ==\"))"],["br"],["code-text","                (finally"],["br"],["code-text","                  (println \"Conteúdo do arquivo\" arquivo)))]"],["br"],["code-text","    (println texto)))"],["br"],["code-text","(ler-mostrar \"batatas\")"],["br"],["code-text","; Conteúdo do arquivo batatas"],["br"],["code-text","; == Arquivo batatas não encontrado =="],["br"]],["paragraph",["br"]],["paragraph",["text","O operador "],["monospaced",["text","try"]],["text"," retorna o texto retornado pelo operador "],["monospaced",["text","catch"]],["text",", enquanto "],["monospaced",["text","finally"]],["text"," é executado havendo ou não uma exceção."],["br"]],["paragraph",["text","Podemos também esconder a ocorrência de uma exceção. Para isso, basta não executarmos nenhuma expressão no bloco "],["monospaced",["text","catch"]],["text",". É uma prática que pode causar problemas, já que você simplesmente não sabe que ocorreu algum erro."],["br"]],["code","clojure",["br"],["code-text","(try"],["br"],["code-text","  (slurp \"batatas\")"],["br"],["code-text","  (catch Exception e))"],["br"],["code-text","; nil"],["br"]],["paragraph",["br"]],["paragraph",["text","Agora informamos apenas o tipo da exceção e o "],["italic",["text","binding"]],["text"," e nenhuma mensagem foi exibida."],["br"]],["title",["text","Lançando exceções"]],["paragraph",["br"]],["paragraph",["text","Nem só de limpar a sujeira alheia vive o código Clojure. Podemos também lançar nossas próprias exceções."],["br"]],["index",["text","throw"]],["paragraph",["br"]],["paragraph",["text","Para isso usamos a forma especial "],["monospaced",["text","throw"]],["text","."],["br"]],["paragraph",["text","Basta criar uma instância de "],["monospaced",["text","Throwable"]],["text"," ou de qualquer outra classe que herde dela com uma mensagem de erro ou outra exceção que deve ser encapsulada. Se você tem experiência com Java não vai ver nenhuma novidade aqui."],["br"]],["code","clojure",["br"],["code-text","(defn lanca-excecao []"],["br"],["code-text","  (throw (Exception. \"Lancei uma exceção\")))"],["br"],["code-text","(defn captura-excecao []"],["br"],["code-text","  (try"],["br"],["code-text","    (lanca-excecao)"],["br"],["code-text","    (catch Exception e"],["br"],["code-text","      (println \"Erro:\" (.getMessage e)))))"],["br"],["code-text","(captura-excecao)"],["br"],["code-text","; Erro: Lancei uma exceção"],["br"]],["paragraph",["br"]],["index",["text","*e"]],["paragraph",["br"]],["index",["text","pst"]],["paragraph",["br"]],["box",["text","*e e pst"],["paragraph",["br"]],["paragraph",["text","Quando uma exceção é capturada e tratada dentro do código, o "],["italic",["text","var"]],["text"," "],["monospaced",["text","*e"]],["text"," e a função "],["monospaced",["text","pst"]],["text",", presentes no "],["italic",["text","REPL"]],["text",", não exibem informações sobre o erro."],["br"]]],["paragraph",["br"]],["section",["text","Perdendo o medo da pilha de chamadas"]],["paragraph",["br"]],["index",["text","stacktrace"]],["index",["text","pilha de chamadas"]],["paragraph",["br"]],["paragraph",["text","Quando ocorre uma exceção não tratada, ou quando executamos o método "],["monospaced",["text","printStackTrace"]],["text"," de uma exceção, é exibida na tela uma lista de chamadas conhecida como "],["italic",["text","stacktrace"]],["text"," ou "],["italic",["text","pilha de chamadas"]],["text","."],["br"]],["paragraph",["text","Para quem está começando, a pilha de chamadas é uma das partes mais desagradáveis e assustadores de lidar"],["ref",["text","state-clojure"]],["text",", independente da linguagem. O iniciante tende a ignorar ou evitar se aprofundar na pilha e, muitas vezes, as informações exibidas ali acabam sendo a única forma de descobrir a causa do problema."],["br"]],["index",["text","pst"]],["paragraph",["br"]],["paragraph",["text","Vamos reaproveitar nossa função "],["monospaced",["text","lanca-excecao"]],["text"," e vamos criar uma nova, chamada "],["monospaced",["text","estoura-excecao"]],["text",", que ao invés de capturar e tratar a exceção, apenas joga para cima. Em seguida vamos invocar a função "],["monospaced",["text","pst"]],["text"," para ver a pilha de chamadas no momento da exceção."],["br"]],["code","clojure",["br"],["code-text","(defn lanca-excecao []"],["br"],["code-text","  (throw (Exception. \"Lancei uma exceção\")))"],["br"],["code-text","(defn estoura-excecao []"],["br"],["code-text","  (println \"Vou lançar uma exceção\")"],["br"],["code-text","  (lanca-excecao))"],["br"],["code-text","(estoura-excecao)"],["br"],["code-text","; Vou lançar uma exceção"],["br"],["code-text","; Exception Lancei uma exceção  user/lanca-excecao (NO_SOURCE_FILE:1)"],["br"],["code-text","(pst)"],["br"],["code-text","; java.lang.Exception: Lancei uma exceção"],["br"],["code-text",";                NO_SOURCE_FILE:1 user/lanca-excecao"],["br"],["code-text",";                NO_SOURCE_FILE:3 user/estoura-excecao"],["br"],["code-text",";                NO_SOURCE_FILE:1 user/eval775"],["br"],["code-text",";              Compiler.java:6703 clojure.lang.Compiler.eval"],["br"],["code-text",";              Compiler.java:6666 clojure.lang.Compiler.eval"],["br"],["code-text",";                   core.clj:2927 clojure.core/eval"],["br"],["code-text",";                    main.clj:239 clojure.main/repl[fn]"],["br"],["code-text",";                    main.clj:239 clojure.main/repl[fn]"],["br"],["code-text",";                    main.clj:257 clojure.main/repl[fn]"],["br"],["code-text",";                    main.clj:257 clojure.main/repl"],["br"],["code-text",";                       ... mais 14 linhas ..."],["br"]],["paragraph",["br"]],["paragraph",["text","A pilha de chamadas começa da linha mais abaixo, onde fica o primeiro método a ter sido invocado. Dessa forma, o último método a ser invocado, onde geralmente ocorre a exceção, fica logo no topo, facilitando a leitura."],["br"]],["paragraph",["text","No nosso exemplo, note as três primeiras linhas. Temos "],["monospaced",["text","NO_SOURCE_FILE"]],["text"," no lugar do nome do arquivo porque estamos usando o "],["italic",["text","REPL"]],["text",". A função "],["monospaced",["text","lanca-excecao"]],["text"," foi chamada pela função "],["monospaced",["text","estoura-excecao"]],["text",", que foi chamada por uma tal de "],["monospaced",["text","eval775"]],["text","."],["br"]],["paragraph",["text","Vemos em seguida que essa "],["monospaced",["text","eval775"]],["text"," é invocada através de um método Java chamado "],["monospaced",["text","eval"]],["text",", que fica na linha "],["italic",["text","6703"]],["text"," da classe "],["monospaced",["text","clojure.lang.Compiler"]],["text"," no arquivo "],["monospaced",["text","Compiler.java"]],["text","."],["br"]],["paragraph",["text","Nesse ponto a informação já não é mais relevante, já que não pretendemos olhar como o compilador do Clojure funciona por dentro. É algo bem legal de se fazer, mas não é o foco desse livro."],["br"]],["paragraph",["text","De volta ao topo da pilha, vemos que "],["monospaced",["text","lanca-excecao"]],["text"," é realmente a causadora do problema, já que usamos um "],["monospaced",["text","throw"]],["text"," dentro dela."],["br"]],["paragraph",["text","Vamos complicar um pouco e reutilizar a função "],["monospaced",["text","ler-mostrar"]],["text"," para tentar ler um arquivo que não existe e lançar uma exceção."],["br"]],["code","clojure",["br"],["code-text","(defn ler-mostrar [arquivo]"],["br"],["code-text","  (let [texto (slurp arquivo)]"],["br"],["code-text","    (println \"Conteúdo do arquivo\" arquivo)"],["br"],["code-text","    (println texto)))"],["br"],["code-text","(ler-mostrar \"batatas\")"],["br"],["code-text","; FileNotFoundException batatas (O sistema não pode encontrar o"],["br"],["code-text","; arquivo especificado)  java.io.FileInputStream.open (:-2)"],["br"],["code-text","(pst)"],["br"],["code-text",";java.io.FileNotFoundException: batatas (O sistema não pode encontrar"],["br"],["code-text","; o arquivo especificado)"],["br"],["code-text",";            (Unknown Source) java.io.FileInputStream.open"],["br"],["code-text",";            (Unknown Source) java.io.FileInputStream.<init>"],["br"],["code-text",";                  io.clj:229 clojure.java.io/fn"],["br"],["code-text",";                   io.clj:69 clojure.java.io/fn[fn]"],["br"],["code-text",";                  io.clj:258 clojure.java.io/fn"],["br"],["code-text",";                   io.clj:69 clojure.java.io/fn[fn]"],["br"],["code-text",";                  io.clj:165 clojure.java.io/fn"],["br"],["code-text",";                   io.clj:69 clojure.java.io/fn[fn]"],["br"],["code-text",";                  io.clj:102 clojure.java.io/reader"],["br"],["code-text",";             RestFn.java:410 clojure.lang.RestFn.invoke"],["br"],["code-text",";                AFn.java:154 clojure.lang.AFn.applyToHelper"],["br"],["code-text",";             RestFn.java:132 clojure.lang.RestFn.applyTo"],["br"],["code-text",";                core.clj:626 clojure.core/apply"],["br"],["code-text",";               core.clj:6390 clojure.core/slurp"],["br"],["code-text",";             RestFn.java:410 clojure.lang.RestFn.invoke"],["br"],["code-text",";            NO_SOURCE_FILE:2 user/ler-mostrar"],["br"],["code-text",";            NO_SOURCE_FILE:1 user/eval776"],["br"],["code-text",";          Compiler.java:6703 clojure.lang.Compiler.eval"],["br"],["code-text",";          Compiler.java:6666 clojure.lang.Compiler.eval"],["br"]],["paragraph",["br"]],["paragraph",["text","O próprio tipo da exceção e sua respectiva mensagem já entregam o que aconteceu: o arquivo "],["italic",["text","batatas"]],["text"," não foi encontrado."],["br"]],["paragraph",["text","Supondo que o código do "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.java.io"]],["text"," fosse meu ou da empresa em que trabalho, ou que eu tivesse livre acesso ao código fonte (sim, nós temos), eu começaria olhando essa pilha da seguinte forma:"],["br"]],["paragraph",["text","Primeiro eu procuraria a função que invoquei e causou o erro. No caso foi a função "],["monospaced",["text","ler-mostrar"]],["text",". Sabemos que "],["monospaced",["text","invoke"]],["text"," é o método chamado pela classe Java responsável por implementar todas as funções do Clojure quando a função é executada."],["br"]],["paragraph",["text","Em seguida vemos que o erro ocorreu na chamada da função "],["monospaced",["text","slurp"]],["text",", que está na segunda linha do nosso código. Vemos depois chamadas a "],["monospaced",["text","apply"]],["text",", "],["monospaced",["text","applyTo"]],["text"," e "],["monospaced",["text","applyToHelper"]],["text",", que inferimos que tenha a ver com a passagem de parâmetros da função "],["monospaced",["text","slurp"]],["text",". Vemos então a chamada a "],["monospaced",["text","invoke"]],["text",", que é onde o código de "],["monospaced",["text","slurp"]],["text"," será executado."],["br"]],["paragraph",["text","Temos então a chamada à função "],["monospaced",["text","reader"]],["text"," do "],["italic",["text","namespace"]],["text"," "],["monospaced",["text","clojure.java.io"]],["text"," e uma série de chamadas a funções anônimas até chegar à classe Java "],["monospaced",["text","java.io.FileInputStream"]],["text","."],["br"]],["paragraph",["text","Você vai dessa forma, testando os argumentos e acompanhando o fluxo da aplicação até entender ou encontrar a causa do problema."],["br"]],["paragraph",["text","Não custa repetir que, apesar da pilha de chamadas ser assustadora e longa, muitas vezes ela é sua única amiga na busca de uma solução para o problema."],["br"]],["paragraph",["text","Recentemente eu me deparei com uma mensagem de erro numa aplicação Web que pouco ajudava e uma pilha de chamadas que não era das mais amigáveis. Após prestar atenção no fluxo da aplicação e ler a pilha de chamadas pela décima vez, acabei descobrindo que o problema estava no modo como o browser lida com parâmetros muito longos na URL."],["br"]],["paragraph",["text","Depois de descobrir isso, todo o resto da pilha fez sentido e eu percebi que toda a informação que eu precisava estava lá. Só foi necessário pesquisar e prestar atenção."],["br"]],["paragraph",["text","Moral da história: não tenha medo da pilha de chamadas e não tenha preguiça de ler atentamente o que está ali."],["br"]],["section",["text","Escolhendo o melhor tipo no Clojure"]],["paragraph",["br"]],["paragraph",["text","O diagrama "],["ref-label",["text","definindo-tipos"]],["text"," nos ajuda a selecionar o tipo correto de dados ao integrar nosso código Clojure com bibliotecas Java já existentes ou mesmo fazendo o oposto, usando o bytecode gerado pelo Clojure dentro da sua aplicação Java."],["br"]],["index",["text","Emerick, Chas"]],["index",["text","Suzart, Paulo"]],["paragraph",["br"]],["paragraph",["text","Este diagrama foi criado por Chas Emerick"],["ref",["text","type-definition-en"]],["text",", coautor de "],["italic",["text","Clojure Programming"]],["ref",["text","clojure-programming"]],["text"," e traduzido para o português por Paulo Suzart"],["ref",["text","type-definition-pt"]],["text","."],["br"]],["paragraph",["text","Ambos foram bacanas ao ceder a imagem e a tradução para este livro sem qualquer complicação, desde que citássemos o repositório"],["ref",["text","github-diagram"]],["text"," onde o diagrama se encontra para que você também possa colaborar."],["br"]],["img",["text","images/capitulo_08/definindo_tipos.png \"Definindo tipos no Clojure\" label=definindo-tipos w=99%"]],["paragraph",["br"]]]